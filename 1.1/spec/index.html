<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <style type="text/css">
div.added    { background-color: #ffff99; }
div.deleted  { text-decoration: line-through;
               background-color: #FF7F7F; }
div.changed  { background-color: #99ff99; }
div.off      {  }

span.added   { background-color: #ffff99; }
span.deleted { text-decoration: line-through;
               background-color: #FFDDDD; }
span.changed { background-color: #99ff99; }
span.off     {  }
</style><title>Bean Validation specification</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>Bean Validation specification</h1></div><div><div class="authorgroup"><h3 class="corpauthor">Bean Validation Expert Group</h3><div class="author"><h3 class="author"><span class="firstname">Emmanuel</span> <span class="surname">Bernard</span></h3><div class="affiliation"><span class="orgname">Red Hat, Inc.<br></span></div></div></div></div><div><p class="releaseinfo">1.1 Final</p></div><div><p class="copyright">Copyright &copy; 2007-2013 Red Hat, Inc.</p></div><div><p class="pubdate">2013-04-10</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e36">1.1. Expert group</a></span></dt><dt><span class="section"><a href="#d0e168">1.2. Specification goals</a></span></dt><dt><span class="section"><a href="#d0e182">1.3. Required Java version</a></span></dt><dt><span class="section"><a href="#d0e187">1.4. How this document is organized</a></span></dt><dt><span class="section"><a href="#d0e224">1.5. How to comment</a></span></dt></dl></dd><dt><span class="chapter"><a href="#whatsnew">2. What's new in 1.1</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e237">2.1. Openness</a></span></dt><dt><span class="section"><a href="#d0e247">2.2. Dependency injection</a></span></dt><dt><span class="section"><a href="#d0e267">2.3. Method validation</a></span></dt><dt><span class="section"><a href="#d0e288">2.4. Integration with Context and Dependency Injection</a></span></dt><dt><span class="section"><a href="#d0e293">2.5. Group conversion</a></span></dt><dt><span class="section"><a href="#d0e298">2.6. Message interpolation via the unified expression language</a></span></dt><dt><span class="section"><a href="#d0e303">2.7. Others</a></span></dt></dl></dd><dt><span class="chapter"><a href="#constraintsdefinitionimplementation">3. Constraint Definition</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintdefinition">3.1. Constraint annotation</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintdefinition-properties">3.1.1. Constraint definition properties</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintdefinition-parameters-message">3.1.1.1. message</a></span></dt><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintdefinition-groups">3.1.1.2. groups</a></span></dt><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintdefinition-payload">3.1.1.3. payload</a></span></dt><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintdefinition-validationappliesto">3.1.1.4. validationAppliesTo</a></span></dt><dt><span class="section"><a href="#d0e662">3.1.1.5. Constraint specific parameter</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e670">3.1.2. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#constraintsdefinitionimplementation-multipleconstraints">3.2. Applying multiple constraints of the same type</a></span></dt><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintcomposition">3.3. Constraint composition</a></span></dt><dt><span class="section"><a href="#constraintsdefinitionimplementation-validationimplementation">3.4. Constraint validation implementation</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintsdefinitionimplementation-validationimplementation-example">3.4.1. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintfactory">3.5. The ConstraintValidatorFactory</a></span></dt></dl></dd><dt><span class="chapter"><a href="#constraintdeclarationvalidationprocess">4. Constraint declaration and validation process</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-requirements">4.1. Requirements on classes to be validated</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-requirements-object">4.1.1. Object validation</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-requirements-property">4.1.2. Field and property validation</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-requirements-graphvalidation">4.1.3. Graph validation</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1678">4.2. Constraint declaration</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-inheritance">4.3. Inheritance (interface and superclass)</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence">4.4. Group and group sequence</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence-groupinheritance">4.4.1. Group inheritance</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence-groupsequence">4.4.2. Group sequence</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup">4.4.3. Redefining the Default group for a class</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence-implicitgrouping">4.4.4. Implicit grouping</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence-groupconversion">4.4.5. Group conversion</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2295">4.4.5.1. Group conversion examples</a></span></dt></dl></dd><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence-formaldefinition">4.4.6. Formal group definitions</a></span></dt></dl></dd><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-methodlevelconstraints">4.5. Method and constructor constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2815">4.5.1. Requirements on methods to be validated</a></span></dt><dt><span class="section"><a href="#d0e2825">4.5.2. Declaring parameter constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-crossparameterconstraints">4.5.2.1. Cross-parameter constraints</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-methodlevelconstraints-definingparameterconstraints-namingparameters">4.5.2.2. Naming parameters</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2978">4.5.3. Declaring return value constraints</a></span></dt><dt><span class="section"><a href="#d0e3048">4.5.4. Marking parameters and return values for cascaded
      validation</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance">4.5.5. Method constraints in inheritance hierarchies</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3176">4.5.5.1. Examples</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-validationroutine">4.6. Validation routine</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation">4.6.1. Object graph validation</a></span></dt><dt><span class="section"><a href="#d0e3506">4.6.2. Method and constructor validation</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-validationroutine-traversable">4.6.3. Traversable property</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-validationroutine-traversable-examples">4.6.3.1. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#typevalidatorresolution">4.6.4. ConstraintValidator resolution algorithm</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4436">4.7. Examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#validationapi">5. Validation APIs</a></span></dt><dd><dl><dt><span class="section"><a href="#validationapi-validatorapi">5.1. Validator API</a></span></dt><dd><dl><dt><span class="section"><a href="#validationapi-validatorapi-validationmethods">5.1.1. Validation methods</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4932">5.1.1.1. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#validationapi-validatorapi-methodlevelvalidationmethods">5.1.2. Methods for validating method and constructor constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5144">5.1.2.1. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#validationapi-validatorapi-groups">5.1.3. groups</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5254">5.1.3.1. Examples</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#validationapi-constraintviolation">5.2. ConstraintViolation</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6641">5.2.1. Examples</a></span></dt><dt><span class="section"><a href="#d0e6700">5.2.2. Examples for method and constructor constraint violations</a></span></dt></dl></dd><dt><span class="section"><a href="#validationapi-message">5.3. Message interpolation</a></span></dt><dd><dl><dt><span class="section"><a href="#default-messageresolver">5.3.1. Default message interpolation</a></span></dt><dd><dl><dt><span class="section"><a href="#default-resolution-algorithm">5.3.1.1. Default message interpolation algorithm</a></span></dt><dt><span class="section"><a href="#message-interpolation-default-locale">5.3.1.2. Locale for default message interpolation</a></span></dt><dt><span class="section"><a href="#message-expressions">5.3.1.3. Message expressions using Expression Language (EL)</a></span></dt></dl></dd><dt><span class="section"><a href="#custom-message-resolution">5.3.2. Custom message interpolation</a></span></dt><dt><span class="section"><a href="#validationapi-message-examples">5.3.3. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#validationapi-triggeringmethodvalidation">5.4. Triggering method validation</a></span></dt><dt><span class="section"><a href="#bootstrapping">5.5. Bootstrapping</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7450">5.5.1. Examples</a></span></dt><dt><span class="section"><a href="#d0e7526">5.5.2. ValidatorFactory</a></span></dt><dt><span class="section"><a href="#d0e7757">5.5.3. Configuration</a></span></dt><dt><span class="section"><a href="#d0e8183">5.5.4. ValidationProvider and ValidationProviderResolver</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8193">5.5.4.1. ValidationProviderResolver</a></span></dt><dt><span class="section"><a href="#id-bootstrap-validationprovider">5.5.4.2. ValidationProvider</a></span></dt></dl></dd><dt><span class="section"><a href="#boostrapping-validation">5.5.5. Validation</a></span></dt><dt><span class="section"><a href="#xml-config">5.5.6. XML configuration: META-INF/validation.xml</a></span></dt><dt><span class="section"><a href="#bootstrapping-usageandcontainerexpectation">5.5.7. Bootstrapping considerations</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#constraintmetadata">6. Constraint metadata request APIs</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8764">6.1. Validator</a></span></dt><dt><span class="section"><a href="#constraintmetadata-elementdescriptor">6.2. ElementDescriptor</a></span></dt><dt><span class="section"><a href="#d0e8976">6.3. BeanDescriptor</a></span></dt><dt><span class="section"><a href="#d0e9065">6.4. CascadableDescriptor</a></span></dt><dt><span class="section"><a href="#d0e9097">6.5. GroupConversionDescriptor</a></span></dt><dt><span class="section"><a href="#d0e9122">6.6. PropertyDescriptor</a></span></dt><dt><span class="section"><a href="#d0e9146">6.7. ExecutableDescriptor, MethodDescriptor and
    ConstructorDescriptor</a></span></dt><dt><span class="section"><a href="#d0e9263">6.8. ParameterDescriptor</a></span></dt><dt><span class="section"><a href="#d0e9289">6.9. CrossParameterDescriptor</a></span></dt><dt><span class="section"><a href="#d0e9314">6.10. ReturnValueDescriptor</a></span></dt><dt><span class="section"><a href="#constraintmetadata-constraintdescriptor">6.11. ConstraintDescriptor</a></span></dt><dt><span class="section"><a href="#d0e9438">6.12. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#builtinconstraints">7. Built-in Constraint definitions</a></span></dt><dt><span class="chapter"><a href="#xml">8. XML deployment descriptor</a></span></dt><dd><dl><dt><span class="section"><a href="#xml-mapping">8.1. Constraint definition and declaration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9606">8.1.1. Constraint declaration in XML</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9654">8.1.1.1. Class-level overriding</a></span></dt><dt><span class="section"><a href="#d0e9703">8.1.1.2. Field-level overriding</a></span></dt><dt><span class="section"><a href="#d0e9783">8.1.1.3. Property-level overriding</a></span></dt><dt><span class="section"><a href="#xml-mapping-constraintdeclarationinxml-constructorleveloverriding">8.1.1.4. Constructor-level overriding</a></span></dt><dt><span class="section"><a href="#xml-mapping-constraintdeclarationinxml-methodleveloverriding">8.1.1.5. Method-level overriding</a></span></dt><dt><span class="section"><a href="#d0e10228">8.1.1.6. Constraint declaration</a></span></dt><dt><span class="section"><a href="#d0e10345">8.1.1.7. Declaration of group conversions</a></span></dt></dl></dd><dt><span class="section"><a href="#xml-mapping-constraintdefinition">8.1.2. Overriding constraint definitions in XML</a></span></dt><dt><span class="section"><a href="#xml-mapping-typeconversion">8.1.3. Converting the string representation of a value</a></span></dt><dt><span class="section"><a href="#xml-mapping-xsd">8.1.4. XML Schema</a></span></dt></dl></dd><dt><span class="section"><a href="#xml-config-xsd">8.2. Configuration schema</a></span></dt></dl></dd><dt><span class="chapter"><a href="#exception">9. Exception model</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10711">9.1. Error report:
    ConstraintViolationException</a></span></dt><dt><span class="section"><a href="#d0e10753">9.2. Constraint definition:
    ConstraintDefinitionException</a></span></dt><dt><span class="section"><a href="#d0e10776">9.3. Constraint declaration:
    ConstraintDeclarationException and
    UnexpectedTypeException</a></span></dt><dt><span class="section"><a href="#d0e10828">9.4. Group definition:
    GroupDefinitionException</a></span></dt></dl></dd><dt><span class="chapter"><a href="#integration">10. Integration</a></span></dt><dd><dl><dt><span class="section"><a href="#integration-general">10.1. General requirements</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10860">10.1.1. Objects lifecycle</a></span></dt><dt><span class="section"><a href="#integration-general-executable">10.1.2. Method and constructor validation</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11200">10.1.2.1. Examples</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#integration-javaee">10.2. Java EE</a></span></dt><dt><span class="section"><a href="#integration-cdi">10.3. Context and Dependency Injection (CDI) integration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11327">10.3.1. ValidatorFactory and
      Validator</a></span></dt><dt><span class="section"><a href="#d0e11379">10.3.2. ConstraintValidatorFactory,
      MessageInterpolator,
      ParameterNameProvider and
      TraversableResolver</a></span></dt><dt><span class="section"><a href="#d0e11475">10.3.3. Method and constructor validation</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e11518">10.4. Java Persistence 2.0 integration</a></span></dt><dt><span class="section"><a href="#d0e11529">10.5. Java Server Faces 2.0 integration</a></span></dt><dt><span class="section"><a href="#d0e11540">10.6. JAX-RS 2 integration</a></span></dt></dl></dd><dt><span class="appendix"><a href="#terminology">A. Terminology</a></span></dt><dt><span class="appendix"><a href="#standard-resolver-messages">B. Standard ResourceBundle messages</a></span></dt><dt><span class="appendix"><a href="#appendix-jpa">C. Java Persistence 2.0 and schema generation</a></span></dt><dt><span class="appendix"><a href="#changelog">D. Changelog</a></span></dt></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="introduction"></a>Chapter&nbsp;1.&nbsp;Introduction</h2></div></div><div></div></div><p>This document is the specification of the Java API for JavaBean
  validation in Java EE and Java SE. The technical objective of this work is
  to provide an object level constraint declaration and validation facility
  for the Java application developer, as well as a constraint metadata
  repository and query API.</p><p>It also offers method and constructor validation facilities to ensure
  constraints on their parameters and return values.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e36"></a>1.1.&nbsp;Expert group</h2></div></div><div></div></div><p>This work has been conducted as part of JSR 349 and formerly JSR 303
    under the Java Community Process Program. This specification is the result
    of the collaborative work of the members of the JSR 349 Expert Group and
    the community at large. The following persons have actively contributed to
    Bean Validation 1.1 in alphabetical order:</p><div class="itemizedlist"><ul type="disc"><li><p>Matt Benson</p></li><li><p>Paul Benedict</p></li><li><p>Emmanuel Bernard (Red Hat, Inc.) - Specification Lead</p></li><li><p>Edward Burns (Oracle)</p></li><li><p>Peter Davis</p></li><li><p>Linda DeMichiel (Oracle)</p></li><li><p>Hardy Ferentschik (Red Hat, Inc.)</p></li><li><p>Antonio Goncalves</p></li><li><p>Cemalettin Ko&ccedil;</p></li><li><p>Rich Midwinter</p></li><li><p>Gunnar Morling (individual then Red Hat, Inc.)</p></li><li><p>Pete Muir (Red Hat, Inc.)</p></li><li><p>Michael Nascimento Santos</p></li><li><p>Gerhard Petracek</p></li><li><p>Kevin Pollet (SERLI)</p></li><li><p>Jagadish Prasath Ramu (Oracle)</p></li><li><p>Bill Shannon (Oracle)</p></li><li><p>Sebastian Thomschke</p></li></ul></div><p>Former expert group members of JSR-303 in alphabetical order
    are:</p><div class="itemizedlist"><ul type="disc"><li><p>Geert Bevin</p></li><li><p>Emmanuel Bernard (Red Hat, Inc.) - Specification Lead</p></li><li><p>Uri Boness</p></li><li><p>Erik Brakkee (Ericsson AB)</p></li><li><p>Ed Burns (Sun Microsystems, Inc.)</p></li><li><p>Jason Carreira</p></li><li><p>Robert Clevenger (Oracle - retired)</p></li><li><p>Linda DeMichiel (Sun Microsystems, Inc.)</p></li><li><p>Tim Fennel</p></li><li><p>Bharath Ganesh (Pramati Technologies)</p></li><li><p>Romain Guy (Google Inc.)</p></li><li><p>Robert Harrop</p></li><li><p>Jacob J. Hookom</p></li><li><p>Bob Lee (Google Inc.)</p></li><li><p>Craig R. McClanahan (Sun Microsystems, Inc.)</p></li><li><p>Niall K. Pemberton</p></li><li><p>Steve Peterson</p></li><li><p>Dhanji R. Prasanna (Google Inc., formerly individual)</p></li><li><p>Gerhard Petracek</p></li><li><p>Matt Raible</p></li><li><p>Michael Nascimento Santos</p></li><li><p>Sebastian Thomschke</p></li><li><p>Jon Wetherbee (Oracle)</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e168"></a>1.2.&nbsp;Specification goals</h2></div></div><div></div></div><p>Validating data is a common task that occurs throughout an
    application, from the presentation layer to the persistence layer. Often
    the same validation logic is implemented in each layer, proving to be time
    consuming and error-prone. To avoid duplication of these validations in
    each layer, developers often bundle validation logic directly into the
    domain model, cluttering domain classes with validation code that is, in
    fact, metadata about the class itself.</p><p>This JSR defines a metadata model and API for JavaBean validation.
    The default metadata source is annotations, with the ability to override
    and extend the meta-data through the use of XML validation
    descriptors.</p><p>The validation API developed by this JSR is not intended for use in
    any one tier or programming model. It is specifically not tied to either
    the web tier or the persistence tier, and is available for both
    server-side application programming, as well as rich client Swing
    application developers. This API is seen as a general extension to the
    JavaBeans object model, and as such is expected to be used as a core
    component in other specifications. Ease of use and flexibility have
    influenced the design of this specification.</p><p>As of version 1.1, Bean Validation constraints can also be applied
    to the parameters and return values of methods of arbitrary Java types.
    Thus the Bean Validation API can be used to describe and validate the
    contract (comprising pre- and postconditions) applying to a given method
    ("Programming by Contract", PbC). Note that it is <span class="emphasis"><em>not</em></span>
    the goal of this specification to develop a fully-fledged PbC solution but
    rather an easy-to-use facility satisfying the most common needs related to
    applying constraints to method parameters and return values, based on the
    proven concepts of the Bean Validation API.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e182"></a>1.3.&nbsp;Required Java version</h2></div></div><div></div></div><p>The specification uses Java 6.0 language features. There is no
    requirement that implementations be compatible with Java language versions
    prior to 6.0.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e187"></a>1.4.&nbsp;How this document is organized</h2></div></div><div></div></div><p>This document describes each aspect of the bean validation
    specification in a separate chapter. One should remember that the
    specification is a consistent whole.</p><p><a href="#constraintsdefinitionimplementation" title="Chapter&nbsp;3.&nbsp;Constraint Definition">Chapter&nbsp;3, <i>Constraint Definition</i></a> describes how
    constraints are defined.</p><p><a href="#constraintdeclarationvalidationprocess" title="Chapter&nbsp;4.&nbsp;Constraint declaration and validation process">Chapter&nbsp;4, <i>Constraint declaration and validation process</i></a> describes
    how a JavaBean class is decorated with annotations to describe
    constraints.</p><p><a href="#validationapi" title="Chapter&nbsp;5.&nbsp;Validation APIs">Chapter&nbsp;5, <i>Validation APIs</i></a> describes how to programmatically
    validate a JavaBean.</p><p><a href="#constraintmetadata" title="Chapter&nbsp;6.&nbsp;Constraint metadata request APIs">Chapter&nbsp;6, <i>Constraint metadata request APIs</i></a> describes how the metadata
    query API works.</p><p><a href="#builtinconstraints" title="Chapter&nbsp;7.&nbsp;Built-in Constraint definitions">Chapter&nbsp;7, <i>Built-in Constraint definitions</i></a> list all the built-in
    constraints.</p><p><a href="#xml" title="Chapter&nbsp;8.&nbsp;XML deployment descriptor">Chapter&nbsp;8, <i>XML deployment descriptor</i></a> describes the XML deployment descriptors for
    the configuration and the mapping.</p><p><a href="#exception" title="Chapter&nbsp;9.&nbsp;Exception model">Chapter&nbsp;9, <i>Exception model</i></a> describes the exception model and
    hierarchy used by Bean Validation.</p><p><a href="#integration" title="Chapter&nbsp;10.&nbsp;Integration">Chapter&nbsp;10, <i>Integration</i></a> describes the different integration
    points of Bean Validation with other technologies. In some cases one has
    to refer to the to the respective specifications for the up-to-date
    integration rules.</p><p>In <a href="#terminology" title="Appendix&nbsp;A.&nbsp;Terminology">Appendix&nbsp;A, <i>Terminology</i></a>, key concepts are summarized. Some
    reviewers have found that reading the terminology section first helps to
    better understand the specification.</p><p>The changelog can be found at <a href="#changelog" title="Appendix&nbsp;D.&nbsp;Changelog">Appendix&nbsp;D, <i>Changelog</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e224"></a>1.5.&nbsp;How to comment</h2></div></div><div></div></div><p>The expert group is eager to receive feedback from readers. Feel
    free to contact us. You can get all the details at <a href="http://beanvalidation.org/contribute/" target="_top">http://beanvalidation.org/contribute/</a>.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="whatsnew"></a>Chapter&nbsp;2.&nbsp;What's new in 1.1</h2></div></div><div></div></div><p>Bean Validation 1.1 improves and build upon Bean Validation 1.0. The
  expert group and the community have been working on a few specific
  areas.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e237"></a>2.1.&nbsp;Openness</h2></div></div><div></div></div><p>All of Bean Validation 1.1 work has been done in the open and in an
    open source way. Source code for the API, reference implementation, test
    compatibility kit as well as the specification and the website sources are
    available in the open. All discussions are done in the open in the
    publicly available development mailing list. Road map and proposals are
    also published on the website.</p><p>You can find all the details (mailing lists, source repositories
    etc.) at <a href="http://beanvalidation.org" target="_top">http://beanvalidation.org</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e247"></a>2.2.&nbsp;Dependency injection</h2></div></div><div></div></div><p>Bean Validation uses a few components
    <tt class="classname">MessageInterpolator</tt>,
    <tt class="classname">TraversableResolver</tt>,
    <tt class="classname">ParameterNameProvider</tt>,
    <tt class="classname">ConstraintValidatorFactory</tt> and
    <tt class="classname">ConstraintValidator</tt>. Bean Validation 1.1
    standardizes how these objects are managed by a container and how these
    objects can benefit from container services. In particular, CDI support
    within Java EE is being defined.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e267"></a>2.3.&nbsp;Method validation</h2></div></div><div></div></div><p>Bean Validation 1.1 allows to put constraints to the parameters and
    return values of arbitrary methods and constructors. That way the Bean
    Validation API can be used to describe and validate the contract applying
    to a given method or constructor, that is:</p><div class="itemizedlist"><ul type="disc"><li><p>the preconditions that must be met by the caller before the
        method or constructor may be invoked and</p></li><li><p>the postconditions that are guaranteed to the caller after a
        method or constructor invocation returns.</p></li></ul></div><p>This enables a programming style known as "Programming by Contract"
    (PbC). Compared to traditional means of checking the sanity of argument
    and return values this approach has several advantages:</p><div class="itemizedlist"><ul type="disc"><li><p>These checks are expressed declaratively and don't have to be
        performed manually, which results in less code to write, read and
        maintain.</p></li><li><p>The pre- and postconditions applying for a method or constructor
        don't have to be expressed again in the documentation, since any of
        its annotations will automatically be included in the generated
        JavaDoc. This reduces redundancies, thus avoiding efforts and
        inconsistencies between implementation and documentation.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e288"></a>2.4.&nbsp;Integration with Context and Dependency Injection</h2></div></div><div></div></div><p>The integration points with Context and Dependency Injection (CDI)
    have been increased and reworked. This opens up for a more natural and
    standard integration both in Java EE and Java SE and encompass dependency
    injection, component lifecycle management and interception for method
    validation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e293"></a>2.5.&nbsp;Group conversion</h2></div></div><div></div></div><p>The specification offers a way to alter the targeted group when
    validation cascading in happening. This feature is particularly useful to
    reuse a given object (graph) and to avoid leaking groups between various
    object subgraphs. It also makes for more readable constraints.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e298"></a>2.6.&nbsp;Message interpolation via the unified expression language</h2></div></div><div></div></div><p>Constraint violation messages can now use EL expressions for a much
    more flexible rendering and string formatting. In particular a formatter
    object is injected in the EL context to convert numbers dates etc. into
    the locale specific string representation. Likewise, the validated value
    is also available in the EL context.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e303"></a>2.7.&nbsp;Others</h2></div></div><div></div></div><p>Many more minor changes have been done. Check out the change log for
    more details at <a href="#changelog" title="Appendix&nbsp;D.&nbsp;Changelog">Appendix&nbsp;D, <i>Changelog</i></a>.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="constraintsdefinitionimplementation"></a>Chapter&nbsp;3.&nbsp;Constraint Definition</h2></div></div><div></div></div><p>Constraints are defined by the combination of a constraint annotation
  and a list of constraint validation implementations. The constraint
  annotation is applied on types, fields, methods, constructors, parameters or
  other constraint annotations in case of composition.</p><p>Unless stated otherwise the default package name for the Bean
  Validation APIs is <tt class="classname">javax.validation</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintsdefinitionimplementation-constraintdefinition"></a>3.1.&nbsp;Constraint annotation</h2></div></div><div></div></div><p>A constraint on a JavaBean is expressed through one or more
    annotations. <span class="tck-not-testable">An annotation is considered a
    constraint definition if its retention policy contains
    <tt class="literal">RUNTIME</tt> and if the annotation itself is annotated with
    <tt class="literal">javax.validation.Constraint</tt></span>.</p><pre class="programlisting">/**
 * Marks an annotation as being a Bean Validation constraint.
 * &lt;p/&gt;
 * A given constraint annotation must be annotated by a {@code @Constraint}
 * annotation which refers to its list of constraint validation implementations.
 * &lt;p/&gt;
 * Each constraint annotation must host the following attributes:
 * &lt;ul&gt;
 *     &lt;li&gt;{@code String message() default [...];} which should default to an error
 *     message key made of the fully-qualified class name of the constraint followed by
 *     {@code .message}. For example {@code "{com.acme.constraints.NotSafe.message}"}&lt;/li&gt;
 *     &lt;li&gt;{@code Class&lt;?&gt;[] groups() default {};} for user to customize the targeted
 *     groups&lt;/li&gt;
 *     &lt;li&gt;{@code Class&lt;? extends Payload&gt;[] payload() default {};} for
 *     extensibility purposes&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * When building a constraint that is both generic and cross-parameter, the constraint
 * annotation must host the {@code validationAppliesTo()} property.
 * A constraint is generic if it targets the annotated element and is cross-parameter if
 * it targets the array of parameters of a method or constructor.
 * &lt;pre&gt;
 *     ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;
 * &lt;/pre&gt;
 * This property allows the constraint user to choose whether the constraint
 * targets the return type of the executable or its array of parameters.
 *
 * A constraint is both generic and cross-parameter if
 * &lt;ul&gt;
 *     &lt;li&gt;two kinds of {@code ConstraintValidator}s are attached to the
 *     constraint, one targeting {@link ValidationTarget#ANNOTATED_ELEMENT}
 *     and one targeting {@link ValidationTarget#PARAMETERS},&lt;/li&gt;
 *     &lt;li&gt;or if a {@code ConstraintValidator} targets both
 *     {@code ANNOTATED_ELEMENT} and {@code PARAMETERS}.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * Such dual constraints are rare. See {@link SupportedValidationTarget} for more info.
 * &lt;p/&gt;
 * Here is an example of constraint definition:
 * &lt;pre&gt;
 * &amp;#64;Documented
 * &amp;#64;Constraint(validatedBy = OrderNumberValidator.class)
 * &amp;#64;Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
 * &amp;#64;Retention(RUNTIME)
 * public &amp;#64;interface OrderNumber {
 *     String message() default "{com.acme.constraint.OrderNumber.message}";
 *     Class&lt;?&gt;[] groups() default {};
 *     Class&lt;? extends Payload&gt;[] payload() default {};
 * }
 * &lt;/pre&gt;
 *
 * @author Emmanuel Bernard
 * @author Gavin King
 * @author Hardy Ferentschik
 */
@Documented
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface Constraint {

    /**
     * {@link ConstraintValidator} classes must reference distinct target types
     * for a given {@link ValidationTarget}
     * If two {@code ConstraintValidator}s refer to the same type,
     * an exception will occur.
     * &lt;p/&gt;
     * At most one {@code ConstraintValidator} targeting the array of parameters of
     * methods or constructors (aka cross-parameter) is accepted. If two or more
     * are present, an exception will occur.
     *
     * @return array of (@code ConstraintValidator} classes implementing the constraint
     */
    Class&lt;? extends ConstraintValidator&lt;?, ?&gt;&gt;[] validatedBy();
}</pre><p>A constraint is said to be generic if it has at least one constraint
    validator targeting the element annotated i.e. targeting the (returned)
    element annotated by the constraint (a bean, a field, a getter, a
    method/constructor return value or a method/constructor parameter). A
    constraint is said to be cross-parameter if it has one constraint
    validator targeting the array of parameters of a method or constructor (to
    validate the consistency of several method/constructor parameters). A Bean
    Validation constraint is most of the time either a generic constraint or a
    cross-parameter constraint. In rare situations, a constraint can be
    both.</p><p class="tck-not-testable">Generic constraint annotations can target
    any of the following <tt class="classname">ElementType</tt>s:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">FIELD</tt> for constrained attributes</p></li><li><p><tt class="literal">METHOD</tt> for constrained getters and
          constrained method return values</p></li><li><p><tt class="classname">CONSTRUCTOR</tt> for constrained constructor
          return values</p></li><li><p><tt class="classname">PARAMETER</tt> for constrained method and
          constructor parameters</p></li><li><p><tt class="literal">TYPE</tt> for constrained beans</p></li><li><p><tt class="literal">ANNOTATION_TYPE</tt> for constraints composing
          other constraints</p></li></ul></div><p class="tck-not-testable">Cross-parameter constraint annotations can
    target any of the following <tt class="classname">ElementType</tt>s:
    </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">METHOD</tt></p></li><li><p><tt class="literal">CONSTRUCTOR</tt></p></li><li><p><tt class="literal">ANNOTATION_TYPE</tt> for cross-parameter
          constraints composing other cross-parameter constraints</p></li></ul></div><p class="tck-not-testable">A constraint annotation that is both can
    target the union of the generic and cross-parameter constraint annotations
    targets.</p><p>While other <tt class="classname">ElementType</tt>s are not forbidden,
    the provider does not have to recognize and process constraints placed on
    such types.</p><p>Since a given constraint definition applies to one or more specific
    Java types, the JavaDoc for the constraint annotation should clearly state
    which types are supported. <span class="tck-testable">Applying a
    constraint annotation to an incompatible type will raise an
    <tt class="classname">UnexpectedTypeException</tt>.</span> Care should be
    taken on defining the list of <tt class="classname">ConstraintValidator</tt>s.
    The type resolution algorithm (see <a href="#typevalidatorresolution" title="4.6.4.&nbsp;ConstraintValidator resolution algorithm">Section&nbsp;4.6.4, &#8220;ConstraintValidator resolution algorithm&#8221;</a>) could lead to exceptions if the
    <tt class="classname">ConstraintValidator</tt> list leads to
    ambiguities.</p><p><span class="tck-testable">At most one
    <tt class="classname">ConstraintValidator</tt> supporting cross-parameter
    validation must be present for a given constraint. A
    <tt class="classname">ConstraintDefinitionException</tt> is raised
    otherwise.</span> The JavaDoc should clearly state if the constraint is
    a generic and / or a cross-parameter constraint.</p><p><span class="tck-testable">If a constraint definition is not valid,
    a <tt class="classname">ConstraintDefinitionException</tt> is raised either at
    validation time or when the metadata is requested.</span> Invalid
    constraint definitions causes are multiple but include missing or illegal
    <tt class="methodname">message</tt> or <tt class="methodname">groups</tt>
    elements (see <a href="#constraintsdefinitionimplementation-constraintdefinition-properties" title="3.1.1.&nbsp;Constraint definition properties">Section&nbsp;3.1.1, &#8220;Constraint definition properties&#8221;</a>).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Bean Validation defines rules for applying constraint annotations
      in inheritance hierarchies, described in <a href="#constraintdeclarationvalidationprocess-inheritance" title="4.3.&nbsp;Inheritance (interface and superclass)">Section&nbsp;4.3, &#8220;Inheritance (interface and superclass)&#8221;</a> and <a href="#constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance" title="4.5.5.&nbsp;Method constraints in inheritance hierarchies">Section&nbsp;4.5.5, &#8220;Method constraints in inheritance hierarchies&#8221;</a>.
      It is therefore not recommended to specify the meta annotation
      <tt class="classname">java.lang.annotation.Inherited</tt> at constraint
      annotation types, as it is not relevant in the context of Bean
      Validation and would conflict with the proposed rules.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintsdefinitionimplementation-constraintdefinition-properties"></a>3.1.1.&nbsp;Constraint definition properties</h3></div></div><div></div></div><p><span class="tck-testable">A constraint definition may have
      attributes that are specified at the time the constraint is applied to a
      JavaBean.</span> The properties are mapped as annotation elements. The
      annotation element names <tt class="literal">message</tt>,
      <tt class="literal">groups</tt>, <tt class="literal">validationAppliesTo</tt> and
      <tt class="literal">payload</tt> are considered reserved names; <span class="tck-testable">annotation elements starting with
      <tt class="literal">valid</tt> are not allowed</span>; a constraint may use
      any other element name for its attributes.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="constraintsdefinitionimplementation-constraintdefinition-parameters-message"></a>3.1.1.1.&nbsp;message</h4></div></div><div></div></div><p class="tck-testable">Every constraint annotation must define a
        <tt class="literal">message</tt> element of type
        <tt class="literal">String</tt>.</p><pre class="programlisting">String message() default "{com.acme.constraint.MyConstraint.message}";</pre><p>The <tt class="methodname">message</tt> element value is used to
        create the error message. See <a href="#validationapi-message" title="5.3.&nbsp;Message interpolation">Section&nbsp;5.3, &#8220;Message interpolation&#8221;</a>
        for a detailed explanation. It is recommended to default
        <tt class="literal">message</tt> values to resource bundle keys to enable
        internationalization. It is also recommended to use the following
        convention: the resource bundle key should be the fully qualified
        class name of the constraint annotation concatenated to
        <tt class="literal">.message</tt> as shown in the previous program
        listing.</p><p>Built-in Bean Validation constraints follow this
        convention.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="constraintsdefinitionimplementation-constraintdefinition-groups"></a>3.1.1.2.&nbsp;groups</h4></div></div><div></div></div><p><span class="tck-testable">Every constraint annotation must
        define a <tt class="literal">groups</tt> element that specifies the
        processing groups with which the constraint declaration is associated.
        </span><span class="tck-testable">The type of the
        <tt class="literal">groups</tt> parameter is
        <tt class="classname">Class&lt;?&gt;[]</tt>.</span></p><pre class="programlisting">Class&lt;?&gt;[] groups() default {};</pre><p class="tck-testable">The default value must be an empty
        array.</p><p class="tck-testable">If no group is specified when declaring the
        constraint on an element, the <tt class="literal">Default</tt> group is
        considered declared.</p><p>See <a href="#validationapi-validatorapi-groups" title="5.1.3.&nbsp;groups">Section&nbsp;5.1.3, &#8220;groups&#8221;</a> for more
        information.</p><p>Groups are typically used to control the order in which
        constraints are evaluated, or to perform validation of the partial
        state of a JavaBean.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="constraintsdefinitionimplementation-constraintdefinition-payload"></a>3.1.1.3.&nbsp;payload</h4></div></div><div></div></div><p class="tck-testable">Constraint annotations must define a
        <tt class="literal">payload</tt> element that specifies the payload with
        which the constraint declaration is associated. The type of the
        <tt class="literal">payload</tt> parameter is
        <tt class="classname">Payload[]</tt>.</p><pre class="programlisting">Class&lt;? extends Payload&gt;[] payload() default {};</pre><p class="tck-testable">The default value must be an empty
        array.</p><p class="tck-testable">Each attachable payload extends
        <tt class="classname">Payload</tt>.</p><pre class="programlisting">/**
 * Payload type that can be attached to a given
 * constraint declaration.
 * &lt;p/&gt;
 * Payloads are typically used to carry on metadata information
 * consumed by a validation client.
 * &lt;/p&gt;
 * Use of payloads is not considered portable.
 *
 * @author Emmanuel Bernard
 * @author Gerhard Petracek
 */
public interface Payload {
}</pre><p>Payloads are typically used by validation clients to associate
        some metadata information with a given constraint declaration.
        Payloads are typically non-portable. Describing payloads as interface
        extensions as opposed to a string-based approach allows an easier and
        more type-safe approach.</p><p>One use case for payload shown in <a href="#example-payload" title="Example&nbsp;3.1.&nbsp;Use of payload to associate severity to a constraint">Example&nbsp;3.1, &#8220;Use of payload to associate severity to a constraint&#8221;</a> is to associate a severity to a
        constraint. This severity can be exploited by a presentation framework
        to adjust how a constraint failure is displayed.</p><div class="example"><a name="example-payload"></a><p class="title"><b>Example&nbsp;3.1.&nbsp;Use of payload to associate severity to a constraint</b></p><pre class="programlisting">package com.acme.severity;

public class Severity {
    public static class Info implements Payload {};
    public static class Error implements Payload {};
}

public class Address {
    @NotNull(message="would be nice if we had one", payload=Severity.Info.class)
    public String getZipCode() { [...] }

    @NotNull(message="the city is mandatory", payload=Severity.Error.class) 
    String getCity() { [...] }
}</pre></div><p>The <tt class="literal">payload</tt> information can be retrieved from
        error reports via the <tt class="classname">ConstraintDescriptor</tt>
        either accessed through the <tt class="classname">ConstraintViolation</tt>
        objects (see <a href="#validationapi-constraintviolation" title="5.2.&nbsp;ConstraintViolation">Section&nbsp;5.2, &#8220;ConstraintViolation&#8221;</a>) or
        through the metadata API (see <a href="#constraintmetadata-constraintdescriptor" title="6.11.&nbsp;ConstraintDescriptor">Section&nbsp;6.11, &#8220;ConstraintDescriptor&#8221;</a>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="constraintsdefinitionimplementation-constraintdefinition-validationappliesto"></a>3.1.1.4.&nbsp;validationAppliesTo</h4></div></div><div></div></div><p><tt class="literal">validationAppliesTo</tt> is used at constraint
        declaration time to clarify what the constraint targets (i.e. the
        annotated element, the method return value or the method
        parameters).</p><p class="tck-testable">The element
        <tt class="literal">validationAppliesTo</tt> must only be present for
        constraints that are both generic and cross-parameter, it is mandatory
        in this situation. A
        <tt class="classname">ConstraintDefinitionException</tt> is raised if
        these rules are violated.</p><p class="tck-testable">The type of the
        <tt class="literal">validationAppliesTo</tt> parameter is
        <tt class="classname">ConstraintTarget</tt>. The default value must be
        <tt class="classname">ConstraintTarget.IMPLICIT</tt>.</p><div class="example"><a name="d0e612"></a><p class="title"><b>Example&nbsp;3.2.&nbsp;validationAppliesTo and ConstraintTarget</b></p><pre class="programlisting">ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;</pre><pre class="programlisting">/**
 * Defines the constraint target.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
public enum ConstraintTarget {

    /**
     * Discover the type when no ambiguity is present
     * &lt;ul&gt;
     *     &lt;li&gt;if neither on a method nor a constructor, it implies the annotated element
     *     (type, field etc),&lt;/li&gt;
     *     &lt;li&gt;if on a method or constructor with no parameter, it implies
     *     {@code RETURN_VALUE},&lt;/li&gt;
     *     &lt;li&gt;if on a method with no return value ({@code void}), it implies
     *     {@code PARAMETERS}.&lt;/li&gt;
     * &lt;/ul&gt;
     * Otherwise, {@code IMPLICIT} is not accepted and either {@code RETURN_VALUE} or
     * {@code PARAMETERS} is required. This is the case for constructors with parameters
     * and methods with parameters and return value.
     */
    IMPLICIT,

    /**
     * Constraint applies to the return value of a method or a constructor.
     */
    RETURN_VALUE,

    /**
     * Constraint applies to the parameters of a method or a constructor
     */
    PARAMETERS
}</pre></div><p><span class="tck-testable">If a
        <tt class="classname">ConstraintTarget</tt> is used in an illegal
        situation, a <tt class="classname">ConstraintDeclarationException</tt> is
        raised either at validation time or when the metadata is
        requested.</span> Examples of illegal situations are:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable">using <tt class="literal">IMPLICIT</tt> in a
            situation that cannot be inferred (see the JavaDoc for the
            detailed rules),</p></li><li><p class="tck-testable">using <tt class="literal">PARAMETERS</tt> on a
            constructor or method that has no parameter,</p></li><li><p class="tck-testable">using <tt class="literal">RETURN_VALUE</tt> on
            a method with no return value,</p></li><li><p class="tck-testable">using <tt class="literal">PARAMETERS</tt> or
            <tt class="literal">RETURN_VALUE</tt> on a type - class or interface -
            or on a field.</p></li></ul></div><p>Constraint users are encouraged to explicitly set the
        <tt class="classname">ConstraintTarget</tt> target when using a constraint
        supporting both on a method or constructor as it improves
        readability.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e662"></a>3.1.1.5.&nbsp;Constraint specific parameter</h4></div></div><div></div></div><p>The constraint annotation definitions may define additional
        elements to parameterize the constraint. For example, a constraint
        that validates the length of a string can use an annotation element
        named <tt class="literal">length</tt> to specify the maximum length at the
        time the constraint is declared.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e670"></a>3.1.2.&nbsp;Examples</h3></div></div><div></div></div><div class="example"><a name="example-definition-notnull"></a><p class="title"><b>Example&nbsp;3.3.&nbsp;Simple constraint definition</b></p><pre class="programlisting">//assuming OrderNumberValidator is a generic constraint validator

package com.acme.constraint;

/**
 * Mark a String as representing a well formed order number
 */
@Documented
@Constraint(validatedBy = OrderNumberValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface OrderNumber {
    String message() default "{com.acme.constraint.OrderNumber.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</pre></div><p><a href="#example-definition-notnull" title="Example&nbsp;3.3.&nbsp;Simple constraint definition">Example&nbsp;3.3, &#8220;Simple constraint definition&#8221;</a> marks a
      <tt class="classname">String</tt> as a well-formed order number. The
      constraint validator is implemented by
      <tt class="classname">OrderNumberValidator</tt>.</p><div class="example"><a name="example-definition-crossparameter"></a><p class="title"><b>Example&nbsp;3.4.&nbsp;Simple cross-parameter constraint definition</b></p><pre class="programlisting">//assuming DateParametersConsistentValidator is a cross-parameter
//constraint validator

package com.acme.constraint;

/**
 * Cross-parameter constraint ensuring that two date parameters
 * of a method are in the correct order.
 */
@Documented
@Constraint(validatedBy = DateParametersConsistentValidator.class)
@Target({ METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface DateParametersConsistent {
    String message() default "{com.acme.constraint.DateParametersConsistent.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</pre></div><p><a href="#example-definition-crossparameter" title="Example&nbsp;3.4.&nbsp;Simple cross-parameter constraint definition">Example&nbsp;3.4, &#8220;Simple cross-parameter constraint definition&#8221;</a> shows a
      cross-parameter constraint which ensures that two date parameters of a
      method are in the correct order. The constraint validator is implemented
      by <tt class="classname">DateParametersConsistentValidator</tt>.</p><div class="example"><a name="example-definition-genericandcrossparameter"></a><p class="title"><b>Example&nbsp;3.5.&nbsp;Constraint that is both generic and cross parameter</b></p><pre class="programlisting">//assuming ELAssertValidator is both a generic and cross-parameter
//constraint validator

package com.acme.constraint;

/**
 * EL expression to be validated.
 * This constraint accepts any type and can validate both the
 * annotated type or apply restrictions across parameters.
 */
@Documented
@Constraint(validatedBy=ELAssertValidator.class)
@Target({ METHOD, FIELD, TYPE, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface ELAssert {
    String message() default "{com.acme.constraint.DateParametersConsistent.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
    ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;

    String expression();
}</pre><pre class="programlisting">@ELAssert(
    message="Please check that your passwords match and try again.",
    expression="param[1]==param[2]", 
    validationAppliesTo=ConstraintType.PARAMETERS
)
public User createUser(String email, String password, String repeatPassword) { [...] }</pre></div><p><a href="#example-definition-genericandcrossparameter" title="Example&nbsp;3.5.&nbsp;Constraint that is both generic and cross parameter">Example&nbsp;3.5, &#8220;Constraint that is both generic and cross parameter&#8221;</a>
      shows a constraint that can be applied both on the annotated element and
      across parameters of a method or a constructor. Note in this case the
      presence of <tt class="methodname">validationAppliesTo</tt>.</p><div class="example"><a name="example-definition-length"></a><p class="title"><b>Example&nbsp;3.6.&nbsp;Constraint definition with default parameter</b></p><pre class="programlisting">package com.acme.constraint;

/**
 * A frequency in Hz as audible to human ear.
 * Adjustable to the age of the person.
 * Accept Numbers.
 */
@Documented
@Constraint(validatedBy = AudibleValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface Audible {
    Age age() default Age.YOUNG;
    String message() default "{com.acme.constraint.Audible.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    public enum Age {
        YOUNG,
        WONDERING
        OLD
    }
}</pre></div><p><a href="#example-definition-length" title="Example&nbsp;3.6.&nbsp;Constraint definition with default parameter">Example&nbsp;3.6, &#8220;Constraint definition with default parameter&#8221;</a> ensures that a given
      frequency is within the scope of human ears. The constraint definition
      includes an optional parameter that may be specified when the constraint
      is applied.</p><div class="example"><a name="example-definition-mandatory"></a><p class="title"><b>Example&nbsp;3.7.&nbsp;Constraint definition with mandatory parameter</b></p><pre class="programlisting">package com.acme.constraint;

/**
 * Defines the list of values accepted
 * Accepts int or Integer objects
 */
@Documented
@Constraint(validatedBy = DiscreteListOfIntegerValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface Acceptable {
    int[] value();
    String message() default "{com.acme.constraint.Acceptable.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</pre></div><p><a href="#example-definition-mandatory" title="Example&nbsp;3.7.&nbsp;Constraint definition with mandatory parameter">Example&nbsp;3.7, &#8220;Constraint definition with mandatory parameter&#8221;</a> defines a list of
      acceptable values expressed as an array: the
      <tt class="methodname">value</tt> property must be specified when the
      constraint is applied.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintsdefinitionimplementation-multipleconstraints"></a>3.2.&nbsp;Applying multiple constraints of the same type</h2></div></div><div></div></div><p>It is often useful to declare the same constraint more than once to
    the same target, with different properties. A common example is the
    <tt class="literal">@Pattern</tt> constraint, which validates that its target
    matches a specified regular expression. Other constraints have this
    requirement as well. The same constraint type can belong to different
    groups and have specific error messages depending on the targeted
    group.</p><p>To support this requirement, <span class="tck-testable">the bean
    validation provider treats regular annotations (annotations not annotated
    by <tt class="classname">@Constraint</tt>) whose <tt class="literal">value</tt>
    element has a return type of an array of constraint annotations in a
    special way. Each element in the <tt class="literal">value</tt> array are
    processed by the Bean Validation implementation as regular constraint
    annotations.</span> This means that each constraint specified in the
    <tt class="literal">value</tt> element is applied to the target. The annotation
    must have retention <tt class="literal">RUNTIME</tt> and can be applied on a
    type, field, property, executable parameter, executable return value,
    executable cross-parameter or another annotation. It is recommended to use
    the same set of targets as the initial constraint.</p><p>Note to constraint designers: each constraint annotation should be
    coupled with its corresponding multi-valued annotation. The specification
    recommends, though does not mandate, the definition of an inner annotation
    named <tt class="classname">List</tt>.</p><div class="example"><a name="d0e763"></a><p class="title"><b>Example&nbsp;3.8.&nbsp;Multi-valued constraint definition</b></p><pre class="programlisting">/**
 * Validate a zipcode for a given country 
 * The only supported type is String
 */
@Documented
@Constraint(validatedBy = ZipCodeValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface ZipCode {

    String countryCode();

    String message() default "{com.acme.constraint.ZipCode.message}";

    Class&lt;?&gt;[] groups() default {};

    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * Defines several @ZipCode annotations on the same element
     * @see (@link ZipCode}
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        ZipCode[] value();
    }    
}</pre></div><div class="example"><a name="d0e768"></a><p class="title"><b>Example&nbsp;3.9.&nbsp;Multi-valued constraint declaration</b></p><pre class="programlisting">public class Address {
    @ZipCode.List( {
            @ZipCode(countryCode="fr", groups=Default.class
                     message = "zip code is not valid"),
            @ZipCode(countryCode="fr", groups=SuperUser.class
                     message = "zip code invalid. Requires overriding before saving.")
            } )
    private String zipcode;
}</pre></div><p>In this example, both constraints apply to the
    <tt class="methodname">zipcode</tt> field but with different groups and with
    different error messages.</p><p>Using two different multi-constraint annotations for the same
    underlying constraint type on the same target (i.e. class or property) is
    not considered portable and is discouraged.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintsdefinitionimplementation-constraintcomposition"></a>3.3.&nbsp;Constraint composition</h2></div></div><div></div></div><p>This specification allows you to compose constraints to create
    higher level constraints.</p><p>Constraint composition is useful in several ways:</p><div class="itemizedlist"><ul type="disc"><li><p>Avoid duplication and facilitate reuse of more primitive
        constraints.</p></li><li><p>Expose primitive constraints as part of a composed constraint in
        the metadata API and enhance tool awareness.</p></li></ul></div><p>Composition is done by annotating a constraint annotation with the
    composing constraint annotations.</p><div class="example"><a name="d0e796"></a><p class="title"><b>Example&nbsp;3.10.&nbsp;Composition is done by annotating the composed constraint</b></p><pre class="programlisting">@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</pre></div><p>Annotating an element with <tt class="classname">@FrenchZipcode</tt>
    (the composed annotation) is equivalent to annotating it with
    <tt class="classname">@Pattern(regexp="[0-9]*")</tt>, <tt class="classname">@Size(min=5,
    max=5)</tt> (the composing annotations) and
    <tt class="classname">@FrenchZipcode</tt>. <span class="tck-testable">More
    formally, each constraint annotation hosted on a constraint annotation is
    applied to the target element and this is done recursively.</span>
    <span class="tck-testable">Note that the main annotation and its
    constraint validation implementation is also applied.</span> <span class="tck-testable">By default, each failing constraint generates an error
    report.</span> <span class="tck-testable">Groups from the main
    constraint annotation are inherited by the composing annotations.</span>
    <span class="tck-testable">Any <tt class="methodname">groups</tt> definition
    on a composing annotation is ignored. </span><span class="tck-testable">Payload from the main constraint annotation is
    inherited by the composing annotations.</span> <span class="tck-testable">Any <tt class="methodname">payload</tt> definition on a
    composing annotation is ignored. </span><span class="tck-testable">The
    constraint target from the main constraint annotation is inherited by the
    composing annotations.</span><span class="tck-testable"> Any
    <tt class="methodname">validationAppliesTo</tt> definition on a composing
    annotation is ignored.</span></p><p><span class="tck-testable">The type upon which composed constraint
    is placed must be compatible with all constraints (composing and
    composed).</span> A constraint designer should ensure that such a type
    exists and lists in the JavaDoc all the compatible types.</p><p><span class="tck-testable">All composed and composing constraints
    must have a constraint type in common.</span> In particular, it is not
    legal to mix a pure generic constraint and a pure cross-parameter
    constraint.</p><p>It is possible to ensure that composing annotations do not raise
    individual error reports. In this scenario, if one or more composing
    annotations are invalid, the main constraint is automatically considered
    invalid and the corresponding error report is generated. To mark a
    constraint as raising a single constraint error report if either the
    composed or one of the composing constraints fail, use the
    <tt class="classname">@ReportAsSingleViolation</tt> annotation.</p><div class="example"><a name="d0e860"></a><p class="title"><b>Example&nbsp;3.11.&nbsp;If any of the composing constraints fail, the error report
      corresponding to @FrenchZipcode is raised and none other.</b></p><pre class="programlisting">@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@ReportAsSingleViolation
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</pre></div><p>The definition of <tt class="classname">@ReportAsSingleViolation</tt> is
    as follows.</p><pre class="programlisting">/**
 * A constraint annotation hosting this annotation will return the
 * composed annotation error report if any of the composing annotations fail.
 * The error reports of each individual composing constraint are ignored.
 * &lt;p/&gt;
 * Note: Evaluation of composed constraints stops on the first validation
 * error in case the composing constraint is annotated with
 * {@code @ReportAsSingleViolation}.
 *
 * @author Emmanuel Bernard
 */
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface ReportAsSingleViolation {
}</pre><p class="tck-testable">More specifically, if a composed constraint is
    marked as <tt class="classname">@ReportAsSingleViolation</tt>, the evaluation
    of the composing constraints stops at the first failing constraint and the
    error report corresponding to the composed constraint is generated and
    returned.</p><p class="tck-testable">Composing annotations can define the value of
    <tt class="literal">message</tt> and custom attributes (excluding
    <tt class="methodname">groups</tt>, <tt class="methodname">payload</tt> and
    <tt class="methodname">validationAppliesTo</tt>) but these are fixed in the
    composed constraint definition.</p><div class="example"><a name="d0e891"></a><p class="title"><b>Example&nbsp;3.12.&nbsp;Composing annotations can use attributes. They are fixed for a
      given main annotation. All @FrenchZipcode constraints have a @Size
      restricted to 5.</b></p><pre class="programlisting">@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</pre></div><p class="tck-testable">It is possible to override attributes and
    messages defined on a composing annotation. An attribute from the main
    annotation is used to override one or more attributes of the composing
    annotations. Such an attribute is annotated with the
    <tt class="classname">@OverridesAttribute</tt> annotation or its multivalued
    equivalent <tt class="classname">@OverridesAttribute.List</tt>.</p><div class="example"><a name="example-composing-overridden"></a><p class="title"><b>Example&nbsp;3.13.&nbsp;Attributes from composing annotations can be overridden by
      attributes from the composed annotation.</b></p><pre class="programlisting">@Pattern(regexp="[0-9]*")
@Size
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @OverridesAttribute.List( {
        @OverridesAttribute(constraint=Size.class, name="min"),
        @OverridesAttribute(constraint=Size.class, name="max") } )
    int size() default 5;

    @OverridesAttribute(constraint=Size.class, name="message")
    String sizeMessage() default "{com.acme.constraint.FrenchZipcode.zipcode.size}";

    @OverridesAttribute(constraint=Pattern.class, name="message")
    String numberMessage() default "{com.acme.constraint.FrenchZipcode.number.size}";

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</pre></div><p>The value of the composed constraint attribute annotated with
    <tt class="classname">@OverridesAttribute</tt>
    (<tt class="methodname">@FrenchZipcode.sizeMessage</tt>) is applied to the
    composing constraint attribute named after
    <tt class="methodname">OverridesAttribute.name</tt> and hosted on the
    composing constraint of type
    <tt class="methodname">OverridesAttribute.constraint</tt>
    (<tt class="methodname">@Size.message</tt>). Similarly,
    <tt class="classname">@FrenchZipcode.numberMessage</tt> value is mapped to
    <tt class="classname">@Pattern.message</tt>.</p><p>If left undefined, the default value for
    <tt class="methodname">@OverridesAttribute.name</tt> is the name of the
    composed constraint attribute hosting the
    <tt class="classname">@OverridesAttribute</tt> annotation.</p><p class="tck-testable">The types of the overridden and overriding
    attributes must be identical.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><span class="tck-testable">A composing constraint can itself be a
      composed constraint. In this case, attribute values are overridden
      recursively according to the described rules.</span> Note however,
      that a forwarding rule (as defined by
      <tt class="classname">@OverridesAttribute</tt>) is only applied to the
      direct composing constraints.</p></div><p>Using <a href="#example-composing-overridden" title="Example&nbsp;3.13.&nbsp;Attributes from composing annotations can be overridden by&#xA;      attributes from the composed annotation.">Example&nbsp;3.13, &#8220;Attributes from composing annotations can be overridden by
      attributes from the composed annotation.&#8221;</a>,</p><pre class="programlisting">@FrenchZipcode(size=9, sizeMessage="Zipcode should be of size {max}")</pre><p>is equivalent to</p><pre class="programlisting">@FrenchZipcode</pre><p>if <tt class="classname">@FrenchZipcode</tt> is defined as</p><pre class="programlisting">@Pattern(regexp="[0-9]*")
@Size(min=9, max=9, message="Zipcode should be of size {max}")
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</pre><p><span class="tck-testable">If a constraint is used more than once
    as a composing constraint, the multi value constraints model as described
    in <a href="#constraintsdefinitionimplementation-multipleconstraints" title="3.2.&nbsp;Applying multiple constraints of the same type">Section&nbsp;3.2, &#8220;Applying multiple constraints of the same type&#8221;</a> is
    used.</span> <span class="tck-testable">To select a specific composing
    constraint, <tt class="methodname">OverridesAttribute.constraintIndex</tt> is
    used. It represents the constraint index in the
    <tt class="methodname">value</tt> array.</span> <span class="tck-testable">If <tt class="literal">index</tt> is undefined, the single
    constraint declaration is targeted.</span></p><div class="example"><a name="d0e987"></a><p class="title"><b>Example&nbsp;3.14.&nbsp;Use of constraintIndex in @OverridesAttribute</b></p><pre class="programlisting">@Pattern.List( {
    @Pattern(regexp="[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}"), //email
    @Pattern(regexp=".*?emmanuel.*?") //emmanuel
} )
@Constraint(validatedBy={})
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface EmmanuelsEmail {
    String message() default "Not emmanuel's email";

    @OverridesAttribute(constraint=Pattern.class, name="message", constraintIndex=0)
    String emailMessage() default "Not an email";

    @OverridesAttribute(constraint=Pattern.class, name="message", constraintIndex=1)
    String emmanuelMessage() default "Not Emmanuel";

    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        EmmanuelsEmail[] value();
    }
}</pre></div><p><tt class="classname">@OverridesAttribute</tt> definition is as
    follows:</p><pre class="programlisting">/**
 * Marks an attribute as overriding the attribute of a composing constraint.
 * Both attributes must share the same type.
 *
 * @author Emmanuel Bernard
 */
@Retention(RUNTIME)
@Target({ METHOD })
public @interface OverridesAttribute {

    /**
     * @return constraint type the attribute is overriding
     */
    Class&lt;? extends Annotation&gt; constraint();

    /**
     * Name of the Constraint attribute overridden.
     * Defaults to the name of the attribute hosting {@code @OverridesAttribute}.
     *
     * @return name of constraint attribute overridden
     */
    String name();

    /**
     * The index of the targeted constraint declaration when using
     * multiple constraints of the same type.
     * &lt;p/&gt;
     * The index represents the index of the constraint in the
     * {@code value()} array.
     * &lt;p/&gt;
     * By default, no index is defined and the single constraint declaration
     * is targeted.
     *
     * @return constraint declaration index if multivalued annotation is used
     */
    int constraintIndex() default -1;

    /**
     * Defines several {@link OverridesAttribute} annotations on the same element
     *
     * @see javax.validation.OverridesAttribute
     */
    @Documented
    @Target({ METHOD })
    @Retention(RUNTIME)
    public @interface List {

        OverridesAttribute[] value();
    }
}</pre><p>The following elements uniquely identify an overridden constraint
    attribute:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">OverridesAttribute.constraint</tt></p></li><li><p><tt class="methodname">OverridesAttribute.name</tt></p></li><li><p><tt class="methodname">OverridesAttribute.constraintIndex</tt></p></li></ul></div><p class="tck-testable">If the composition is invalid, e.g.
    </p><div class="itemizedlist"><ul type="disc"><li><p>infinitely recursive composition</p></li><li><p>wrong attribute overriding</p></li><li><p>a single attribute mapped to more than one source
          attribute</p></li><li><p>a composing and composed constraint marked as different
          constraint types (i.e., generic and cross-parameter)</p></li><li><p>etc.</p></li></ul></div><p class="tck-testable">a <tt class="classname">ConstraintDefinitionException</tt> is
    raised either at validation time or when the metadata is requested.</p><p>Constraint designers are encouraged to make use of composition
    (recursively or not) based on the built-in constraints defined by the
    specification. The composing constraints are exposed through the Bean
    Validation metadata API (<a href="#constraintmetadata-constraintdescriptor" title="6.11.&nbsp;ConstraintDescriptor">Section&nbsp;6.11, &#8220;ConstraintDescriptor&#8221;</a>). This metadata is
    particularly useful for third-party metadata consumers like persistence
    frameworks generating database schemas (such as Java Persistence) or
    presentation frameworks.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintsdefinitionimplementation-validationimplementation"></a>3.4.&nbsp;Constraint validation implementation</h2></div></div><div></div></div><p><span class="tck-testable">A constraint validation implementation
    performs the validation of a given constraint annotation for a given
    type.</span> <span class="tck-testable">The implementation classes are
    specified by the <tt class="literal">validatedBy</tt> element of the
    <tt class="classname">@Constraint</tt> annotation that decorates the
    constraint definition.</span> <span class="tck-not-testable">The
    constraint validation implementation implements the
    <tt class="classname">ConstraintValidator</tt> interface.</span></p><pre class="programlisting">/**
 * Defines the logic to validate a given constraint {@code A}
 * for a given object type {@code T}.
 * &lt;p/&gt;
 * Implementations must comply to the following restriction:
 * &lt;ul&gt;
 *     &lt;li&gt;{@code T} must resolve to a non parameterized type&lt;/li&gt;
 *     &lt;li&gt;or generic parameters of {@code T} must be unbounded
 *     wildcard types&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * The annotation {@link SupportedValidationTarget} can be put on a
 * {@code ConstraintValidator} implementation to mark it as supporting
 * cross-parameter constraints. Check out {@link SupportedValidationTarget}
 * and {@link Constraint} for more information.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintValidator&lt;A extends Annotation, T&gt; {

    /**
     * Initializes the validator in preparation for
     * {@link #isValid(Object, ConstraintValidatorContext)} calls.
     * The constraint annotation for a given constraint declaration
     * is passed.
     * &lt;p/&gt;
     * This method is guaranteed to be called before any use of this instance for
     * validation.
     *
     * @param constraintAnnotation annotation instance for a given constraint declaration
     */
    void initialize(A constraintAnnotation);

    /**
     * Implements the validation logic.
     * The state of {@code value} must not be altered.
     * &lt;p/&gt;
     * This method can be accessed concurrently, thread-safety must be ensured
     * by the implementation.
     *
     * @param value object to validate
     * @param context context in which the constraint is evaluated
     *
     * @return {@code false} if {@code value} does not pass the constraint
     */
    boolean isValid(T value, ConstraintValidatorContext context);
}</pre><p class="tck-not-testable">Some restrictions apply on the generic type
    <tt class="classname">T</tt> (used in the <tt class="methodname">isValid()</tt>
    method). <tt class="classname">T</tt> must </p><div class="itemizedlist"><ul type="disc"><li><p>resolve to a non parameterized type (i.e. because the type is
          not using generics or because the raw type is used instead of the
          generic version)</p></li><li><p>or generic parameters of <tt class="classname">T</tt> must be
          unbounded wildcard types (i.e. <tt class="literal">&lt;?&gt;</tt>).</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This restriction is not a theoretical limitation and a future
      version of the specification might allow it.</p></div><p class="tck-testable">By default, a
    <tt class="classname">ConstraintValidator</tt> targets the (returned) element
    annotated by the constraint. You can make a
    <tt class="classname">ConstraintValidator</tt> target the array of parameters
    of a method or constructor (aka cross-parameter) by annotating the
    validator implementation with
    <tt class="classname">@SupportedValidationTarget</tt>.</p><div class="example"><a name="d0e1100"></a><p class="title"><b>Example&nbsp;3.15.&nbsp;@SupportedValidationTarget annotation and ValidationTarget
      enum</b></p><pre class="programlisting">package javax.validation.constraintvalidation;

/**
 * Defines the target(s) a {@link ConstraintValidator} can validate.
 * &lt;p/&gt;
 * A {@code ConstraintValidator} can target the (returned) element
 * annotated by the constraint, the array of parameters of a method
 * or constructor (aka cross-parameter) or both.
 * &lt;p/&gt;
 * If {@code @SupportedValidationTarget} is not present, the
 * {@code ConstraintValidator} targets the (returned) element annotated
 * by the constraint.
 * &lt;p/&gt;
 * A {@code ConstraintValidator} targeting cross-parameter must accept
 * {@code Object[]} (or {@code Object}) as the type of object it validates.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
@Documented
@Target({ TYPE })
@Retention(RUNTIME)
public @interface SupportedValidationTarget {

    ValidationTarget[] value();
}</pre><pre class="programlisting">package javax.validation.constraintvalidation;

/**
 * List of possible targets for a {@link ConstraintValidator}.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
public enum ValidationTarget {

    /**
     * (Returned) element annotated by the constraint.
     */
    ANNOTATED_ELEMENT,

    /**
     * Array of parameters of the annotated method or constructor (aka cross-parameter).
     */
    PARAMETERS
}</pre></div><p class="tck-testable">A <tt class="classname">ConstraintValidator</tt>
    implementation can target both annotated elements and array of
    parameters.</p><p class="tck-testable">If a <tt class="classname">ConstraintValidator</tt>
    targets array of parameters (cross-parameter), <tt class="classname">T</tt>
    must resolve to <tt class="classname">Object[]</tt> (or
    <tt class="classname">Object</tt>) in order to have the array of parameter
    values passed to the <tt class="methodname">isValid()</tt> method. A
    <tt class="classname">ConstraintDefinitionException</tt> is raised
    otherwise.</p><div class="example"><a name="d0e1132"></a><p class="title"><b>Example&nbsp;3.16.&nbsp;Example of cross parameter ConstraintValidator</b></p><pre class="programlisting">@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class ScriptAssertValidator implements ConstraintValidator&lt;ScriptAssert,Object[]&gt; {
    @Override
    public void initialize(ScriptAssert constraintAnnotation) {
        [...]
    }

    @Override
    public boolean isValid(Object[] value, ConstraintValidatorContext context) {
        [...]
    }
}</pre></div><p><a href="#example-constraintsdefinitionimplementation-validationimplementation-validdef" title="Example&nbsp;3.17.&nbsp;Valid ConstraintValidator definitions">Example&nbsp;3.17, &#8220;Valid ConstraintValidator definitions&#8221;</a>
    shows some examples of valid definitions.</p><div class="example"><a name="example-constraintsdefinitionimplementation-validationimplementation-validdef"></a><p class="title"><b>Example&nbsp;3.17.&nbsp;Valid ConstraintValidator definitions</b></p><pre class="programlisting">//String is not making use of generics
public class SizeValidatorForString implements ConstraintValidator&lt;Size, String&gt; {
    [...]
}

//Collection uses generics but the raw type is used
public class SizeValidatorForCollection implements ConstraintValidator&lt;Size, Collection&gt; {
    [...]
}

//Collection uses generics and unbounded windcard type
public class SizeValidatorForCollection implements ConstraintValidator&lt;Size, Collection&lt;?&gt;&gt; {
    [...]
}

//Validator for cross-parameter constraint
@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class DateParametersConsistentValidator 
    implements ConstraintValidator&lt;DateParametersConsistent, Object[]&gt; {
    [...]
}

//Validator for both annotated elements and executable parameters
@SupportedValidationTarget({ValidationTarget.ANNOTATED_ELEMENT, ValidationTarget.PARAMETERS})
public class ELScriptValidator implements ConstraintValidator&lt;ELScript, Object&gt; {
    [...]
}</pre></div><p>And some invalid definitions in <a href="#example-constraintsdefinitionimplementation-validationimplementation-invaliddef" title="Example&nbsp;3.18.&nbsp;Invalid ConstraintValidator definitions">Example&nbsp;3.18, &#8220;Invalid ConstraintValidator definitions&#8221;</a>.</p><div class="example"><a name="example-constraintsdefinitionimplementation-validationimplementation-invaliddef"></a><p class="title"><b>Example&nbsp;3.18.&nbsp;Invalid ConstraintValidator definitions</b></p><pre class="programlisting">//parameterized type
public class SizeValidatorForString implements&lt;Size, Collection&lt;String&gt;&gt; {
    [...]
}

//parameterized type using bounded wildcard
public class SizeValidatorForCollection implements&lt;Size, Collection&lt;? extends Address&gt;&gt; {
    [...]
}

//cross-parameter validator accepting the wrong type
@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class NumberPositiveValidator implements ConstraintValidator&lt;NumberPositive, Number&gt; {
    [...]
}</pre></div><p>The life cycle of a constraint validation implementation instance is
    undefined. Bean Validation providers are allowed to cache
    <tt class="classname">ConstraintValidator</tt> instances retrieved from the
    <tt class="classname">ConstraintValidatorFactory</tt>.</p><p class="tck-testable">The <tt class="methodname">initialize()</tt> method
    is called by the Bean validation provider prior to any use of the
    constraint implementation.</p><p><span class="tck-testable">The <tt class="methodname">isValid()</tt>
    method is evaluated by the Bean Validation provider each time a given
    value is validated.</span> <span class="tck-not-testable">It returns
    <tt class="literal">false</tt> if the value is not valid,
    <tt class="literal">true</tt> otherwise.</span> <span class="tck-not-testable"><tt class="literal">isValid()</tt> implementations must
    be thread-safe.</span></p><p><span class="tck-testable">If the property is of an unanticipated
    type, an <tt class="literal">UnexpectedTypeException</tt> is raised.</span>
    <tt class="classname">ConstraintValidator</tt> implementations raise this
    exception themselves if they receive an unsupported type. However,
    constraint designers are encouraged to make use of specialized
    <tt class="classname">ConstraintValidator</tt> implementations and delegate
    the type resolution to the Bean Validation provider (see the type matching
    algorithm described in <a href="#typevalidatorresolution" title="4.6.4.&nbsp;ConstraintValidator resolution algorithm">Section&nbsp;4.6.4, &#8220;ConstraintValidator resolution algorithm&#8221;</a>).</p><p class="tck-testable">If an exception occurs either in the
    <tt class="methodname">initialize()</tt> or
    <tt class="methodname">isValid()</tt> method, the runtime exception is
    wrapped into a <tt class="classname">ValidationException</tt> by the Bean
    Validation engine.</p><p class="tck-not-testable">The constraint validation implementation is
    not allowed to change the state of the value passed to
    <tt class="methodname">isValid()</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>While not mandatory, it is considered a good practice to split the
      core constraint validation from the not null constraint validation (for
      example, an <tt class="classname">@Email</tt> constraint will return
      <tt class="literal">true</tt> on a null object, i.e. will not take care of the
      <tt class="classname">@NotNull</tt> validation).</p><p><tt class="code">null</tt> can have multiple meanings but is commonly used
      to express that a value does not make sense, is not available or is
      simply unknown. Those constraints on the value are orthogonal in most
      cases to other constraints. For example a String, if present, must be an
      email but can be null. Separating both concerns is a good
      practice.</p></div><p>The <tt class="classname">ConstraintValidatorContext</tt> object passed
    to the <tt class="methodname">isValid()</tt> method carries information and
    operations available in the context the constraint is validated to.</p><pre class="programlisting">/**
 * Provides contextual data and operation when applying a given constraint validator.
 *
 * At least one {@link ConstraintViolation} must be defined (either the default one,
 * of if the default {@code ConstraintViolation} is disabled, a custom one).
 *
 * @author Emmanuel Bernard
 */
public interface ConstraintValidatorContext {

    /**
     * Disables the default {@link ConstraintViolation} object generation (which
     * is using the message template declared on the constraint).
     * &lt;p/&gt;
     * Useful to set a different violation message or generate a {@code ConstraintViolation}
     * based on a different property.
     */
    void disableDefaultConstraintViolation();

    /**
     * @return the current un-interpolated default message
     */
    String getDefaultConstraintMessageTemplate();

    /**
     * Returns a constraint violation builder building a violation report
     * allowing to optionally associate it to a sub path.
     * The violation message will be interpolated.
     * &lt;p/&gt;
     * To create the {@link ConstraintViolation}, one must call either one of
     * the {@code addConstraintViolation()} methods available in one of the
     * interfaces of the fluent API.
     * If another method is called after {@code addConstraintViolation()} on
     * {@code ConstraintViolationBuilder} or any of its associated nested interfaces
     * an {@code IllegalStateException} is raised.
     * &lt;p/&gt;
     * If {@link ConstraintValidator#isValid(Object, ConstraintValidatorContext)} returns
     * {@code false}, a {@code ConstraintViolation} object will be built per constraint
     * violation report including the default one (unless
     * {@link #disableDefaultConstraintViolation()} has been called).
     * &lt;p/&gt;
     * {@code ConstraintViolation} objects generated from such a call
     * contain the same contextual information (root bean, path and so on) unless
     * the path has been overridden.
     * &lt;p/&gt;
     * To create a different {@code ConstraintViolation}, a new constraint violation builder
     * has to be retrieved from {@code ConstraintValidatorContext}
     *
     * Here are a few usage examples:
     * &lt;pre&gt;
     * //assuming the following domain model
     * public class User {
     *     public Map&lt;String,Address&gt; getAddresses() { ... }
     * }
     *
     * public class Address {
     *     public String getStreet() { ... }
     *     public Country getCountry() { ... }
     * }
     *
     * public class Country {
     *     public String getName() { ... }
     * }
     *
     * //From a property-level constraint on User.addresses
     * //Build a constraint violation on the default path - i.e. the "addresses" property
     * context.buildConstraintViolationWithTemplate( "this detail is wrong" )
     *             .addConstraintViolation();
     *
     * //From a class level constraint on Address
     * //Build a constraint violation on the default path + "street"
     * //i.e. the street property of Address
     * context.buildConstraintViolationWithTemplate( "this detail is wrong" )
     *             .addPropertyNode( "street" )
     *             .addConstraintViolation();
     *
     * //From a property-level constraint on  User.addresses
     * //Build a constraint violation on the default path + the bean stored
     * //under the "home" key in the map
     * context.buildConstraintViolationWithTemplate( "Incorrect home address" )
     *             .addBeanNode()
     *                 .inIterable().atKey( "home" )
     *             .addConstraintViolation();
     *
     * //From a class level constraint on User
     * //Build a constraint violation on the default path + addresses["home"].country.name
     * //i.e. property "country.name" on the object stored under "home" in the map
     * context.buildConstraintViolationWithTemplate( "this detail is wrong" )
     *             .addPropertyNode( "addresses" )
     *             .addPropertyNode( "country" )
     *                 .inIterable().atKey( "home" )
     *             .addPropertyNode( "name" )
     *             .addConstraintViolation();
     * &lt;/pre&gt;
     * &lt;p/&gt;
     * Cross-parameter constraints on a method can create a node specific
     * to a particular parameter if required. Let's explore a few examples:
     * &lt;p/&gt;
     * &lt;pre&gt;
     * //Cross-parameter constraint on method createUser(String password, String passwordRepeat)
     * //Build a constraint violation on the default path + "passwordRepeat"
     * context.buildConstraintViolationWithTemplate("Passwords do not match")
     *             .addParameterNode(1)
     *             .addConstraintViolation();
     *
     * //Cross-parameter constraint on a method
     * //mergeAddresses(Map&lt;String,Address&gt; addresses, Map&lt;String,Address&gt; otherAddresses)
     * //Build a constraint violation on the default path + "otherAddresses["home"]
     * //i.e. the Address bean hosted in the "home" key of the "otherAddresses" map parameter
     * context.buildConstraintViolationWithTemplate(
     *         "Map entry home present in both and does not match")
     *             .addParameterNode(1)
     *             .addBeanNode()
     *                 .inIterable().atKey("home")
     *             .addConstraintViolation();
     *
     * //Cross-parameter constraint on a method
     * //mergeAddresses(Map&lt;String,Address&gt; addresses, Map&lt;String,Address&gt; otherAddresses)
     * //Build a constraint violation on the default path + "otherAddresses["home"].city
     * //i.e. on the "city" property of the Address bean hosted in
     * //the "home" key of the "otherAddresses" map
     * context.buildConstraintViolationWithTemplate(
     *         "Map entry home present in both but city does not match")
     *             .addParameterNode(1)
     *             .addPropertyNode("city")
     *                 .inIterable().atKey("home")
     *             .addConstraintViolation();
     * &lt;/pre&gt;
     *
     * @param messageTemplate new un-interpolated constraint message
     * @return returns a constraint violation builder
     */
    ConstraintViolationBuilder buildConstraintViolationWithTemplate(String messageTemplate);

    /**
     * Returns an instance of the specified type allowing access to
     * provider-specific APIs. If the Bean Validation provider
     * implementation does not support the specified class,
     * {@link ValidationException} is thrown.
     *
     * @param type the class of the object to be returned
     * @return an instance of the specified class
     * @throws ValidationException if the provider does not support the call
     *
     * @since 1.1
     */
    &lt;T&gt; T unwrap(Class&lt;T&gt; type);

    /**
     * {@link ConstraintViolation} builder allowing to optionally associate
     * the violation report to a sub path.
     * &lt;p/&gt;
     * To create the {@code ConstraintViolation}, one must call either one of
     * the {@code addConstraintViolation()} methods available in one of the
     * interfaces of the fluent API.
     * &lt;p/&gt;
     * If another method is called after {@code addConstraintViolation()} on
     * {@code ConstraintViolationBuilder} or any of its associated objects
     * an {@code IllegalStateException} is raised.
     */
    interface ConstraintViolationBuilder {

        /**
         * Adds a node to the path the {@link ConstraintViolation} will be associated to.
         * &lt;p/&gt;
         * {@code name} describes a single property. In particular,
         * dot (.) is not allowed.
         *
         * @param name property name
         * @return a builder representing node {@code name}
         * @deprecated since 1.1 - replaced by {@link #addPropertyNode(String)},
         *             {@link #addBeanNode()} and {@link #addParameterNode(int)}
         */
        NodeBuilderDefinedContext addNode(String name);

        /**
         * Adds a property node to the path the {@link ConstraintViolation}
         * will be associated to.
         * &lt;p/&gt;
         * {@code name} describes a single property. In particular,
         * dot (.) is not allowed.
         *
         * @param name property name
         * @return a builder representing node {@code name}
         * @throws IllegalArgumentException if the name is null
         *
         * @since 1.1
         */
        NodeBuilderCustomizableContext addPropertyNode(String name);

        /**
         * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
         * will be associated to.
         * Note that bean nodes are always leaf nodes.
         *
         * @return a builder representing the bean node
         *
         * @since 1.1
         */
        LeafNodeBuilderCustomizableContext addBeanNode();

        /**
         * Adds a method parameter node to the path the {@link ConstraintViolation}
         * will be associated to.
         * The parameter index must be valid (i.e. within the boundaries of the method
         * parameter indexes). May only be called from within cross-parameter validators.
         *
         * @param index the parameter index
         * @return a builder representing the index-th parameter node
         * @throws IllegalArgumentException if the index is not valid
         *
         * @since 1.1
         */
        NodeBuilderDefinedContext addParameterNode(int index);

        /**
         * Adds the new {@link ConstraintViolation} to be generated if the
         * constraint validator marks the value as invalid.
         * &lt;p/&gt;
         * Methods of this {@code ConstraintViolationBuilder} instance and its nested
         * objects throw {@code IllegalStateException} from now on.
         *
         * @return the {@code ConstraintValidatorContext} instance the
         *         {@code ConstraintViolationBuilder} comes from
         */
        ConstraintValidatorContext addConstraintViolation();

        /**
         * Represents a node whose context is known
         * (i.e. index, key and isInIterable)
         * and that is a leaf node (i.e. no subnode can be added).
         *
         * @since 1.1
         */
        interface LeafNodeBuilderDefinedContext {

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator marks the value as invalid.
             * &lt;p/&gt;
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *         {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents a node whose context is
         * configurable (i.e. index, key and isInIterable)
         * and that is a leaf node (i.e. no subnode can be added).
         *
         * @since 1.1
         */
        interface LeafNodeBuilderCustomizableContext {

            /**
             * Marks the node as being in an {@code Iterable} or a {@code Map}.
             * 
             * @return a builder representing iterable details
             */
            LeafNodeContextBuilder inIterable();

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * &lt;p/&gt;
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *         {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents refinement choices for a node which is
         * in an {@code Iterator} or {@code Map}.
         * &lt;p/&gt;
         * If the iterator is an indexed collection or a map,
         * the index or the key should be set.
         * &lt;p/&gt;
         * The node is a leaf node (i.e. no subnode can be added).
         *
         * @since 1.1
         */
        interface LeafNodeContextBuilder {

            /**
             * Defines the key the object is into the {@code Map}.
             *
             * @param key map key
             * @return a builder representing the current node
             */
            LeafNodeBuilderDefinedContext atKey(Object key);

            /**
             * Defines the index the object is into the {@code List} or array
             *
             * @param index index
             * @return a builder representing the current node
             */
            LeafNodeBuilderDefinedContext atIndex(Integer index);

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * &lt;p/&gt;
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents a node whose context is known
         * (i.e. index, key and isInIterable)
         * and that is not necessarily a leaf node (i.e. subnodes can
         * be added).
         */
        interface NodeBuilderDefinedContext {

            /**
             * Adds a node to the path the {@link ConstraintViolation} will be associated to.
             * &lt;p/&gt;
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @deprecated since 1.1 - replaced by {@link #addPropertyNode(String)}
             *             and {@link #addBeanNode()}
             */
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Adds a property node to the path the {@link ConstraintViolation}
             * will be associated to.
             * &lt;p/&gt;
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @throws IllegalArgumentException if the name is null
             *
             * @since 1.1
             */
            NodeBuilderCustomizableContext addPropertyNode(String name);

            /**
             * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
             * will be associated to.
             * Note that bean nodes are always leaf nodes.
             *
             * @return a builder representing the bean node
             *
             * @since 1.1
             */
            LeafNodeBuilderCustomizableContext addBeanNode();

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator marks the value as invalid.
             * &lt;p/&gt;
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents a node whose context is
         * configurable (i.e. index, key and isInIterable)
         * and that is not necessarily a leaf node (i.e. subnodes can
         * be added).
         */
        interface NodeBuilderCustomizableContext {

            /**
             * Marks the node as being in an {@code Iterable} or a {@code Map}.
             *
             * @return a builder representing iterable details
             */
            NodeContextBuilder inIterable();

            /**
             * Adds a node to the path the {@link ConstraintViolation} will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @deprecated since 1.1 - replaced by {@link #addPropertyNode(String)}
             *             and {@link #addBeanNode()}
             */
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Adds a property node to the path the {@link ConstraintViolation}
             * will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @throws IllegalArgumentException if the name is null
             *
             * @since 1.1
             */
            NodeBuilderCustomizableContext addPropertyNode(String name);

            /**
             * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
             * will be associated to.
             * Note that bean nodes are always leaf nodes.
             *
             * @return a builder representing the bean node
             *
             * @since 1.1
             */
            LeafNodeBuilderCustomizableContext addBeanNode();

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * &lt;p/&gt;
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents refinement choices for a node which is
         * in an {@code Iterator} or {@code Map}.
         * &lt;p/&gt;
         * If the iterator is an indexed collection or a map,
         * the index or the key should be set.
         * &lt;p/&gt;
         * The node is not necessarily a leaf node (i.e. subnodes can
          * be added).
         */
        interface NodeContextBuilder {
            
            /**
             * Defines the key the object is into the {@code Map}.
             *
             * @param key map key
             * @return a builder representing the current node
             */
            NodeBuilderDefinedContext atKey(Object key);

            /**
             * Defines the index the object is into the {@code List} or array.
             *
             * @param index index
             * @return a builder representing the current node
             */
            NodeBuilderDefinedContext atIndex(Integer index);

            /**
             * Adds a node to the path the {@code ConstraintViolation} will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @deprecated since 1.1 - replaced by {@link #addPropertyNode(String)}
             *             and {@link #addBeanNode()}
             */
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Adds a property node to the path the {@link ConstraintViolation}
             * will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @throws IllegalArgumentException if the name is null
             *
             * @since 1.1
             */
            NodeBuilderCustomizableContext addPropertyNode(String name);

            /**
             * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
             * will be associated to.
             * &lt;p/&gt;
             * Note that bean nodes are always leaf nodes.
             *
             * @return a builder representing the bean node
             *
             * @since 1.1
             */
            LeafNodeBuilderCustomizableContext addBeanNode();

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * &lt;p/&gt;
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *         {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }
    }
}</pre><p>The <tt class="classname">ConstraintValidatorContext</tt> interface
    allows redefinition of the default constraint message generated when a
    constraint is not valid. <span class="tck-testable">By default, each
    invalid constraint leads to the generation of one error object represented
    by a <tt class="classname">ConstraintViolation</tt> object. This object is
    built from the default constraint message template as defined by the
    constraint declaration and the context in which the constraint declaration
    is placed (bean, property, executable parameter, cross-parameter or
    executable return value).</span></p><p><span class="tck-testable">The
    <tt class="classname">ConstraintValidatorContext</tt> methods let the
    constraint implementation disable the default
    <tt class="classname">ConstraintViolation</tt> generation and create one or
    more custom ones.</span> <span class="tck-testable">The
    non-interpolated message passed as a parameter is used to build the
    <tt class="classname">ConstraintViolation</tt> message (the message
    interpolation operation is applied to it).</span></p><p><span class="tck-testable">By default, the
    <tt class="classname">Path</tt> exposed on the
    <tt class="classname">ConstraintViolation</tt> represents the path to the
    bean, property, parameter, cross-parameter or return value hosting the
    constraint (see <a href="#validationapi-constraintviolation" title="5.2.&nbsp;ConstraintViolation">Section&nbsp;5.2, &#8220;ConstraintViolation&#8221;</a> for
    more information).</span> <span class="tck-testable">You can point it
    to a subpath of this default path by using the constraint violation
    builder fluent API.</span></p><p><a href="#example-constraintsdefinitionimplementation-validationimplementation-errorbuilder" title="Example&nbsp;3.19.&nbsp;Using the fluent API to build custom constraint&#xA;      violations">Example&nbsp;3.19, &#8220;Using the fluent API to build custom constraint
      violations&#8221;</a>
    shows a few examples.</p><div class="example"><a name="example-constraintsdefinitionimplementation-validationimplementation-errorbuilder"></a><p class="title"><b>Example&nbsp;3.19.&nbsp;Using the fluent API to build custom constraint
      violations</b></p><pre class="programlisting">//assuming the following domain model
public class User {
    public Map&lt;String,Address&gt; getAddresses() { [...] }
}

public class Address {
    public String getStreet() { [...] }
    public Country getCountry() { [...] }
}

public class Country {
   public String getName() { [...] }
}

//From a property-level constraint on User.addresses
//Build a constraint violation on the default path - i.e. the "addresses" property
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addConstraintViolation();

//From a class level constraint on Address
//Build a constraint violation on the default path + "street"
//i.e. the street property of Address
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addPropertyNode( "street" )
            .addConstraintViolation();

//From a property-level constraint on  User.addresses
//Build a constraint violation on the default path + the bean stored
//under the "home" key in the map
context.buildConstraintViolationWithTemplate( "Incorrect home address" )
            .addBeanNode()
                .inIterable().atKey( "home" )
            .addConstraintViolation();

//From a class level constraint on User
//Build a constraint violation on the default path + addresses["home"].country.name
//i.e. property "country.name" on the object stored under "home" in the map
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addPropertyNode( "addresses" )
            .addPropertyNode( "country" )
                .inIterable().atKey( "home" )
            .addPropertyNode( "name" )
            .addConstraintViolation();

//To create a subnode representing a method parameter from a cross-parameter constraint violation

//Cross-parameter constraint on method createUser(String password, String passwordRepeat)
//Build a constraint violation on the default path + "passwordRepeat"
context.buildConstraintViolationWithTemplate("Passwords do not match")
            .addParameterNode(1)
            .addConstraintViolation();

//Cross-parameter constraint on a method
//mergeAddresses(Map&lt;String,Address&gt; addresses, Map&lt;String,Address&gt; otherAddresses)
//Build a constraint violation on the default path + "otherAddresses["home"]
//i.e. the Address bean hosted in the "home" key of the "otherAddresses" map parameter
context.buildConstraintViolationWithTemplate(
        "Map entry home present in both and does not match" )
            .addParameterNode( 1 )
            .addBeanNode()
                .inIterable().atKey( "home" )
            .addConstraintViolation();

//Cross-parameter constraint on a method
//mergeAddresses(Map&lt;String,Address&gt; addresses, Map&lt;String,Address&gt; otherAddresses)
//Build a constraint violation on the default path + "otherAddresses["home"].city
//i.e. on the "city" property of the Address bean hosted in
//the "home" key of the "otherAddresses" map
context.buildConstraintViolationWithTemplate(
        "Map entry home present in both but city does not match" )
            .addParameterNode( 1 )
            .addPropertyNode( "city" )
                .inIterable().atKey( "home" )
            .addConstraintViolation();</pre></div><p class="tck-testable">If
    <tt class="methodname">disableDefaultConstraintViolation()</tt> is called, no
    custom error is added (using the error builder) and if the constraint is
    not valid, a <tt class="classname">ValidationException</tt> is raised.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintsdefinitionimplementation-validationimplementation-example"></a>3.4.1.&nbsp;Examples</h3></div></div><div></div></div><div class="example"><a name="d0e1303"></a><p class="title"><b>Example&nbsp;3.20.&nbsp;ConstraintValidator implementation</b></p><pre class="programlisting">/**
 * Check that a text is within the authorized syntax
 */
public class SyntaxValidator implements ConstraintValidator&lt;Syntax, String&gt; {
    private Set&lt;Format&gt; allowedFormats;

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(Syntax constraint) {
        allowedFormats = new HashSet( Arrays.asList( constraint.value() ) );
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if ( value == null ) return true;

        return allowedFormats.size() == 0 
            || (! Collections.disjoint( guessFormat(value), allowedFormats ) );
    }

    Set&lt;Format&gt; guessFormats(String text) { [...] }
}</pre></div><p>This <tt class="classname">ConstraintValidator</tt> checks that a text
      is within the accepted syntax. It also demonstrates an interesting best
      practice: return <tt class="literal">true</tt> on a null parameter.</p><p>The following listing shows a validator implementing the
      validation logic for a cross-parameter constraint.</p><div class="example"><a name="d0e1318"></a><p class="title"><b>Example&nbsp;3.21.&nbsp;Cross-parameter validator implementation</b></p><pre class="programlisting">/**
 * Check that two date parameters of a method are in the expected order. Expects the
 * 2nd and 3rd parameter of the validated method to be of type java.util.Date.
 */
@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class DateParametersConsistentValidator implements&lt;DateParametersConsistent, Object[]&gt; {

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(DateParametersConsistent constraint) {
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(Object[] value, ConstraintValidatorContext context) {
        if ( value.length != 3 ) {
            throw new IllegalStateException( "Unexpected method signature" );
        }
        // one or both limits are unbounded =&gt; always consistent
        if ( value[1] == null || value[2] == null ) return true;
        return ( (Date) value[1] ).before( (Date) value[2] );
    }
}</pre></div><p>The following listing shows a validator implementing the
      validation logic for a constraint that is both generic and
      cross-parameter.</p><div class="example"><a name="d0e1325"></a><p class="title"><b>Example&nbsp;3.22.&nbsp;Generic and cross-parameter validator implementation</b></p><pre class="programlisting">/**
 * Checks that an object passes the Expression Language expression
 * provided by the constraint.
 */
@SupportedValidationTarget({ValidationTarget.ANNOTATED_ELEMENT, ValidationTarget.PARAMETERS})
public class ELScriptValidator implements&lt;ELScript, Object&gt; {

    public void initialize(ELScript constraint) {
        [...]
    }

    public boolean isValid(Object value, ConstraintValidatorContext context) {
        [...]
    }
}</pre></div><p>The next example shows how to use
      <tt class="classname">ConstraintValidatorContext</tt>.</p><div class="example"><a name="d0e1335"></a><p class="title"><b>Example&nbsp;3.23.&nbsp;Use of ConstraintValidatorContext</b></p><pre class="programlisting">/**
 * Check that a text is within the authorized syntax
 * Error messages are using either key:
 *  - com.acme.constraint.Syntax.unknown if no particular syntax is detected
 *  - com.acme.constraint.Syntax.unauthorized if the syntax is not allowed
 */
public class FineGrainedSyntaxValidator implements ConstraintValidator&lt;Syntax, String&gt; {
    private Set&lt;Format&gt; allowedFormats;

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(Syntax constraint) {
        allowedFormats = new HashSet( Arrays.asList( constraint.value() ) );
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if ( value == null ) return true;
        Set&lt;Format&gt; guessedFormats = guessFormats(value);

        context.disableDefaultConstraintViolation();
        if ( guessedFormats.size() == 0 ) {
            String unknown = "{com.acme.constraint.Syntax.unknown}";
            context.buildConstraintViolationWithTemplate(unknown)
                       .addConstraintViolation();
            return false;
        }
        if ( allowedFormats.size() != 0 
            &amp;&amp; Collections.disjoint( guessedFormats, allowedFormats ) ) {

            String unauthorized = "{com.acme.constraint.Syntax.unauthorized}";
            context.buildConstraintViolationWithTemplate(unauthorized)
                       .addConstraintViolation();
            return false;
        }
        return true;
    }

    Set&lt;Format&gt; guessFormats(String text) { [...] }
}</pre></div><p>The default error message is disabled and replaced by a specific
      error message depending on the type of constraint violation detected. In
      this case, only one error report is returned at a given time but a
      constraint validation implementation can return several error
      reports.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintsdefinitionimplementation-constraintfactory"></a>3.5.&nbsp;The ConstraintValidatorFactory</h2></div></div><div></div></div><p>Constraint validation implementation instances are created by a
    <tt class="classname">ConstraintValidatorFactory</tt>.</p><p>The life cycle of <tt class="classname">ConstraintValidator</tt>
    instances is fully dependent of the Bean Validation provider and piloted
    by the <tt class="classname">ConstraintValidatorFactory</tt> methods.
    Therefore, <tt class="classname">ConstraintValidatorFactory</tt>
    implementations (such as dependency injection frameworks) must consider
    these instances as belonging to a dependent scope. <span class="tck-not-testable">Bean Validation providers must release each
    instance retrieved. The <tt class="classname">ConstraintValidatorFactory</tt>
    instance that has created a <tt class="classname">ConstraintValidator</tt>
    instance must be the one that releases it. In other words, passing an
    instance of <tt class="classname">ConstraintValidator</tt> to a
    <tt class="classname">ConstraintValidatorFactory</tt> that has not created it
    is an error.</span></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><tt class="classname">ConstraintValidator</tt> instances created by
      the <tt class="classname">ValidatorFactory</tt>-level
      <tt class="classname">ConstraintValidatorFactory</tt> can be released when
      the <tt class="classname">ValidatorFactory</tt> is being closed.</p></div><div class="example"><a name="d0e1389"></a><p class="title"><b>Example&nbsp;3.24.&nbsp;ConstraintValidatorFactory interface</b></p><pre class="programlisting">/**
 * Instantiates a {@link ConstraintValidator} instance based off its class.
 * The {@code ConstraintValidatorFactory} is &lt;b&gt;not&lt;/b&gt; responsible
 * for calling {@link ConstraintValidator#initialize(java.lang.annotation.Annotation)}.
 *
 * @author Dhanji R. Prasanna
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintValidatorFactory {

    /**
     * @param key The class of the constraint validator to instantiate
     *
     * @return A new constraint validator instance of the specified class
     */
    &lt;T extends ConstraintValidator&lt;?, ?&gt;&gt; T getInstance(Class&lt;T&gt; key);

    /**
     * Signals {@code ConstraintValidatorFactory} that the instance is no longer
     * being used by the Bean Validation provider.
     *
     * @param instance validator being released
     *
     * @since 1.1
     */
    void releaseInstance(ConstraintValidator&lt;?, ?&gt; instance);
}</pre></div><p><span class="tck-testable">The default
    <tt class="classname">ConstraintValidatorFactory</tt> provided by the Bean
    Validation provider implementation uses the public no-arg constructor of
    the <tt class="classname">ConstraintValidator</tt> class.</span> A custom
    <tt class="classname">ConstraintValidatorFactory</tt> can be provided; for
    example it may benefit from dependency injection control in constraint
    implementations (see <a href="#bootstrapping-usageandcontainerexpectation" title="5.5.7.&nbsp;Bootstrapping considerations">Section&nbsp;5.5.7, &#8220;Bootstrapping considerations&#8221;</a>). Any constraint
    implementation relying on
    <tt class="classname">ConstraintValidatorFactory</tt> behaviors specific to an
    implementation (dependency injection, no no-arg constructor and so on) are
    not portable, hence great care should be given before walking that path.
    Make sure to configure the Bean Validation provider to honor any specific
    needs your <tt class="classname">ConstraintValidator</tt> has. As constraint
    designer and writer, make sure to document any specific non compliant
    requirements.</p><p><tt class="classname">ConstraintValidatorFactory</tt> should not cache
    instances as the state of each instance can be altered in the
    <tt class="methodname">initialize()</tt> method.</p><p><span class="tck-testable">If an exception occurs in the factory
    while retrieving the <tt class="classname">ConstraintValidator</tt> instance,
    the runtime exception is wrapped in a
    <tt class="classname">ValidationException</tt>.</span> <span class="tck-testable">If the instance returned by the factory is null, a
    <tt class="classname">ValidationException</tt> is raised.</span></p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="constraintdeclarationvalidationprocess"></a>Chapter&nbsp;4.&nbsp;Constraint declaration and validation process</h2></div></div><div></div></div><p>The Bean Validation specification defines a framework for declaring
  constraints on JavaBean classes, fields and properties. Constraints are
  declared on types and evaluated against instances or graphs of
  instances.</p><p>Bean Validation also offers a way to declare constructor and method
  constraints where parameters and return values are the constrained elements.
  We will discuss method constraints declaration in detail in <a href="#constraintdeclarationvalidationprocess-methodlevelconstraints" title="4.5.&nbsp;Method and constructor constraints">Section&nbsp;4.5, &#8220;Method and constructor constraints&#8221;</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintdeclarationvalidationprocess-requirements"></a>4.1.&nbsp;Requirements on classes to be validated</h2></div></div><div></div></div><p>Objects hosting constraints and expecting to be validated by Bean
    Validation providers must fulfill the following requirements:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable">Properties to be validated must follow the
        method signature conventions for JavaBeans read properties, as defined
        by the <a href="http://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/" target="_top">JavaBeans
        specification</a>. These properties are commonly referred as
        getters.</p></li><li><p class="tck-not-testable">Static fields and static methods are
        excluded from validation.</p></li><li><p class="tck-testable">Constraints can be applied to interfaces and
        superclasses.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">What is a getter?</h3><p>The JavaBeans specification specifies that a getter is a method
      whose</p><div class="itemizedlist"><ul type="disc"><li><p>name starts with <tt class="literal">get</tt> and has a return type
          but no parameter</p></li><li><p>name starts with <tt class="literal">is</tt>, has no parameter and
          is returning <tt class="classname">boolean</tt></p></li></ul></div></div><p class="tck-testable">The target of an annotation definition can be a
    field, property, type, constructor or method return value, constructor or
    method parameter or constructor or method cross-parameter provided that:
    </p><div class="itemizedlist"><ul type="disc"><li><p>the constraint definition supports the specified target
          (<tt class="classname">java.lang.annotation.Target</tt>)</p></li><li><p>one of the <tt class="classname">ConstraintValidator</tt>s
          declared on the constraint supports the declared type of the target
          or in the case of cross-parameter, one cross-parameter
          <tt class="classname">ConstraintValidator</tt> is present (see <a href="#typevalidatorresolution" title="4.6.4.&nbsp;ConstraintValidator resolution algorithm">Section&nbsp;4.6.4, &#8220;ConstraintValidator resolution algorithm&#8221;</a> to learn about
          <tt class="classname">ConstraintValidator</tt> resolution).</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-requirements-object"></a>4.1.1.&nbsp;Object validation</h3></div></div><div></div></div><p><span class="tck-testable">Constraint declarations can be applied
      to a class or an interface.</span> <span class="tck-testable">Applying a constraint to a class or interface
      expresses a validation over the state of the class or the class
      implementing the interface.</span></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-requirements-property"></a>4.1.2.&nbsp;Field and property validation</h3></div></div><div></div></div><p><span class="tck-testable">Constraint declarations can be applied
      on both fields and properties for the same object type.</span> <span class="tck-testable">The same constraint should however not be duplicated
      between a field and its associated property (the constraint validation
      would be applied twice).</span> It is recommended for objects holding
      constraint declarations to adhere to a single state access strategy
      (either annotated fields or properties).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Java Persistence and Bean Validation</h3><p>For maximum portability, persistent properties hosting Bean
        Validation constraints should use the same access strategy used in
        Java Persistence. In other words, place your Bean Validation
        constraint annotations on the same element (field or getter) as your
        Java Persistence annotations.</p></div><p class="tck-testable">When a field is annotated with a constraint
      declaration, field access strategy is used to access the state validated
      by such constraint.</p><p class="tck-testable">When a property is annotated with a constraint
      declaration, property access strategy is used to access the state
      validated by such constraint.</p><p>When using field access strategy, the bean validation provider
      accesses the instance variable directly. When using the property access
      strategy, the bean validation provider accesses the state via the
      property accessor method. It is required that the class follows the
      method signature conventions for JavaBeans read properties (as defined
      by the JavaBeans <tt class="classname">Introspector</tt> class) for
      constrained properties when constrained properties are used. In this
      case, for every constraint property of type <tt class="classname">T</tt>,
      there is a getter method named
      <tt class="methodname">get&lt;Property-name&gt;</tt>. The method must have
      no parameters. For <tt class="code">boolean</tt> properties,
      <tt class="methodname">is&lt;Property-name&gt;</tt> is an alternative name
      for the getter method. Specifically, if <tt class="methodname">getX</tt> is
      the name of the getter method, where <tt class="classname">X</tt> is a
      string, the name of the persistent property is defined by the result of
      <tt class="code">java.beans.Introspector.decapitalize(X)</tt>.</p><p><span class="tck-testable">The fields or methods visibility are
      not constrained.</span></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-requirements-graphvalidation"></a>4.1.3.&nbsp;Graph validation</h3></div></div><div></div></div><p>In addition to supporting instance validation, validation of
      graphs of object is also supported. The result of a graph validation is
      returned as a unified set of constraint violations.
      <tt class="classname">@Valid</tt> is used to express validation traversal of
      an association.</p><div class="example"><a name="d0e1572"></a><p class="title"><b>Example&nbsp;4.1.&nbsp;<tt class="classname">@Valid</tt> annotation</b></p><pre class="programlisting">/**
 * Marks a property, method parameter or method return type for validation cascading.
 * &lt;p/&gt;
 * Constraints defined on the object and its properties are be validated when the
 * property, method parameter or method return type is validated.
 * &lt;p/&gt;
 * This behavior is applied recursively.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
@Target({ METHOD, FIELD, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface Valid {
}</pre></div><p><span class="tck-testable">Consider the situation where bean
      <tt class="classname">X</tt> contains a field of type
      <tt class="classname">Y</tt>. By annotating field <tt class="classname">Y</tt>
      with the <tt class="classname">@Valid</tt> annotation, the Validator will
      validate <tt class="classname">Y</tt> (and its properties) when
      <tt class="classname">X</tt> is validated.</span> <span class="tck-testable">The exact type <tt class="classname">Z</tt> of the value
      contained in the field declared of type <tt class="classname">Y</tt>
      (subclass, implementation) is determined at runtime. The constraint
      definitions of <tt class="classname">Z</tt> are used.</span> This ensures
      proper polymorphic behavior for associations marked
      <tt class="classname">@Valid</tt>.</p><p>Collection-valued, array-valued and generally
      <tt class="classname">Iterable</tt> fields and properties may also be
      decorated with the <tt class="classname">@Valid</tt> annotation. This causes
      the contents of the iterator to be validated. <span class="tck-testable">Any object implementing
      <tt class="classname">java.lang.Iterable</tt> is supported.</span> This
      includes specifically:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable">arrays of objects</p></li><li><p class="tck-testable"><tt class="classname">java.util.Collection</tt></p></li><li><p class="tck-testable"><tt class="classname">java.util.Set</tt></p></li><li><p class="tck-testable"><tt class="classname">java.util.List</tt></p></li><li><p><span class="tck-testable"><tt class="classname">java.util.Map</tt></span>
          (special treatment see below)</p></li></ul></div><p><span class="tck-testable">Each object provided by the iterator
      is validated.</span> <span class="tck-testable">For
      <tt class="classname">Map</tt>, the value (retrieved by
      <tt class="methodname">getValue</tt>) of each
      <tt class="classname">Map.Entry</tt> is validated (the key is not
      validated).</span></p><p class="tck-testable">Like regular references, its type is
      determined at runtime and the constraint definitions for this particular
      type are used.</p><p><span class="tck-testable">The <tt class="classname">@Valid</tt>
      annotation is applied recursively.</span> A conforming implementation
      avoids infinite loops according to the rules described in <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1678"></a>4.2.&nbsp;Constraint declaration</h2></div></div><div></div></div><p>Constraint declarations are placed on classes or interfaces
    primarily through annotations. A constraint annotation (see <a href="#constraintsdefinitionimplementation-constraintdefinition" title="3.1.&nbsp;Constraint annotation">Section&nbsp;3.1, &#8220;Constraint annotation&#8221;</a>), can
    be applied to a type, on any of the type's fields or on any of the
    JavaBeans-compliant properties.</p><p class="tck-testable">When a constraint is defined on a class, the
    class instance being validated is passed to the
    <tt class="classname">ConstraintValidator</tt>. When a constraint is defined
    on a field, the value of the field is passed to the
    <tt class="classname">ConstraintValidator</tt>. When a constraint is defined
    on a getter, the result of the getter invocation is passed to the
    <tt class="classname">ConstraintValidator</tt>.</p><p><a href="#constraintdeclarationvalidationprocess-methodlevelconstraints" title="4.5.&nbsp;Method and constructor constraints">Section&nbsp;4.5, &#8220;Method and constructor constraints&#8221;</a>
    discusses in detail constraints on methods and constructors.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintdeclarationvalidationprocess-inheritance"></a>4.3.&nbsp;Inheritance (interface and superclass)</h2></div></div><div></div></div><p><span class="tck-testable">A constraint declaration can be placed
    on an interface.</span> <span class="tck-testable">For a given class,
    constraint declarations held on superclasses as well as interfaces are
    evaluated by the Bean Validation provider.</span> Rules are formally
    described in <a href="#constraintdeclarationvalidationprocess-groupsequence-formaldefinition" title="4.4.6.&nbsp;Formal group definitions">Section&nbsp;4.4.6, &#8220;Formal group definitions&#8221;</a>.</p><p class="tck-testable">The effect of constraint declarations is
    cumulative. Constraints declared on a superclass getter will be validated
    along with any constraints defined on an overridden version of the getter
    according to the Java Language Specification visibility rules.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintdeclarationvalidationprocess-groupsequence"></a>4.4.&nbsp;Group and group sequence</h2></div></div><div></div></div><p>A group defines a subset of constraints. Instead of validating all
    constraints for a given object graph, only a subset is validated. This
    subset is defined by the group or groups targeted. Each constraint
    declaration defines the list of groups it belongs to. <span class="tck-testable">If no group is explicitly declared, a constraint
    belongs to the <tt class="classname">Default</tt> group.</span></p><p class="tck-testable">Groups are represented by interfaces.</p><div class="example"><a name="d0e1725"></a><p class="title"><b>Example&nbsp;4.2.&nbsp;Definition of groups</b></p><pre class="programlisting">/**
 * Validation group verifing that a user is billable
 */
public interface Billable {}

/**
 * Customer can buy without any harrassing checking process
 */
public interface BuyInOneClick {
}</pre></div><p class="tck-testable">A constraint can belong to one or more
    groups.</p><div class="example"><a name="example-assigngrouptoconstraints"></a><p class="title"><b>Example&nbsp;4.3.&nbsp;Assign groups to constraints</b></p><pre class="programlisting">/**
 * User representation
 */
public class User {
    @NotNull
    private String firstname;

    @NotNull(groups = Default.class)
    private String lastname;

    @NotNull(groups = {Billable.class, BuyInOneClick.class})
    private CreditCard defaultCreditCard;
}</pre></div><p><span class="tck-testable">During the validation call, one or more
    groups are validated. All the constraints belonging to this set of group
    is evaluated on the object graph.</span> In <a href="#example-assigngrouptoconstraints" title="Example&nbsp;4.3.&nbsp;Assign groups to constraints">Example&nbsp;4.3, &#8220;Assign groups to constraints&#8221;</a>,
    <tt class="classname">@NotNull</tt> is checked on
    <tt class="literal">defaultCreditCard</tt> when either the
    <tt class="classname">Billable</tt> or <tt class="classname">BuyInOneClick</tt>
    group is validated. <tt class="classname">@NotNull</tt> on
    <tt class="literal">firstname</tt> and <tt class="literal">lastname</tt> are validated
    when the <tt class="classname">Default</tt> group is validated. Reminder:
    constraints held on superclasses and interfaces are considered.</p><p><tt class="classname">Default</tt> is a group predefined by the
    specification</p><pre class="programlisting">package javax.validation.groups;

/**
 * Default Bean Validation group.
 * &lt;p/&gt;
 * Unless a list of groups is explicitly defined:
 * &lt;ul&gt;
 *     &lt;li&gt;constraints belong to the {@code Default} group&lt;/li&gt;
 *     &lt;li&gt;validation applies to the {@code Default} group&lt;/li&gt;
 * &lt;/ul&gt;
 * Most structural constraints should belong to the default group.
 *
 * @author Emmanuel Bernard
 */
public interface Default {
}</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-groupsequence-groupinheritance"></a>4.4.1.&nbsp;Group inheritance</h3></div></div><div></div></div><p>In some situations, a group is a superset of one or more groups.
      This can be described by Bean Validation. <span class="tck-testable">A
      group may inherit one or more groups by using interface
      inheritance.</span></p><div class="example"><a name="d0e1780"></a><p class="title"><b>Example&nbsp;4.4.&nbsp;Groups can inherit other groups</b></p><pre class="programlisting">/**
 * Customer can buy without harrassing checking process
 */
public interface BuyInOneClick extends Default, Billable {}</pre></div><p class="tck-testable">For a given interface
      <tt class="classname">Z</tt>, constraints marked as belonging to the group
      <tt class="classname">Z</tt> (i.e. where the annotation element
      <tt class="methodname">groups</tt> contains the interface
      <tt class="classname">Z</tt>) or any of the super interfaces of
      <tt class="classname">Z</tt> (inherited groups) are considered part of the
      group <tt class="classname">Z</tt>.</p><p>In the following example:</p><div class="example"><a name="d0e1807"></a><p class="title"><b>Example&nbsp;4.5.&nbsp;Use of a inherited group</b></p><pre class="programlisting">/**
 * User representation
 */
public class User {
    @NotNull
    private String firstname;

    @NotNull(groups = Default.class)
    private String lastname;

    @NotNull(groups = Billable.class)
    private CreditCard defaultCreditCard;
}</pre></div><p>validating the group <tt class="classname">BuyInOneClick</tt> will
      lead to the following constraints checking:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">@NotNull</tt> on
          <tt class="literal">firstname</tt> and <tt class="literal">lastname</tt></p></li><li><p><tt class="classname">@NotNull</tt> on
          <tt class="literal">defaultCreditCard</tt></p></li></ul></div><p>because <tt class="classname">Default</tt> and
      <tt class="classname">Billable</tt> are superinterfaces of
      <tt class="classname">BuyInOneClick</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-groupsequence-groupsequence"></a>4.4.2.&nbsp;Group sequence</h3></div></div><div></div></div><p><span class="tck-not-testable">By default, constraints are
      evaluated in no particular order regardless of which groups they belong
      to.</span> It is however useful in some situations to control the
      order of constraints evaluation. There are often scenarios where a
      preliminary set of constraints should be evaluated prior to other
      constraints. Here are two examples:</p><div class="itemizedlist"><ul type="disc"><li><p>The second group depends on a stable state to run properly.
          This stable state is verified by the first group.</p></li><li><p>The second group is a heavy consumer of time, CPU or memory
          and its evaluation should be avoided if possible.</p></li></ul></div><p>To implement such ordering, a group can be defined as a sequence
      of other groups. <span class="tck-testable">Each group in a group
      sequence must be processed sequentially in the order defined by
      <tt class="methodname">@GroupSequence.value</tt> when the group defined as
      a sequence is requested.</span> <span class="tck-testable">Note that
      a group member of a sequence can itself be composed of several groups
      via inheritance or sequence definition. In this case, each composed
      group must respect the sequence order as well.</span></p><p>Processing a group is defined in <a href="#constraintdeclarationvalidationprocess-validationroutine" title="4.6.&nbsp;Validation routine">Section&nbsp;4.6, &#8220;Validation routine&#8221;</a> ;
      <span class="tck-testable">if one of the groups processed in the
      sequence generates one or more constraint violations, the groups
      following in the sequence must not be processed.</span> This ensures
      that a set of constraint is evaluated only if another set of constraint
      is valid.</p><p class="tck-testable">Groups defining a sequence and groups
      composing a sequence must not be involved in a cyclic dependency:
      </p><div class="itemizedlist"><ul type="disc"><li><p>either directly or indirectly</p></li><li><p>either through cascaded sequence definitions or group
            inheritance</p></li></ul></div><p class="tck-testable">If a group containing such a circularity is
      evaluated, a <tt class="classname">GroupDefinitionException</tt> is
      raised.</p><p class="tck-not-testable">Groups defining a sequence should not
      directly inherit other groups. In other words, the interface hosting the
      group sequence should not have any super interface.</p><p><span class="tck-not-testable">Groups defining a sequence should
      not be used directly in constraint declarations.</span> In other
      words, the interface hosting the group sequence should not be used in a
      constraint declaration.</p><p class="tck-testable">To define a group as a sequence, the interface
      must be annotated with the <tt class="classname">@GroupSequence</tt>
      annotation.</p><pre class="programlisting">/**
 * Defines group sequence.
 * &lt;p/&gt;
 * The interface hosting {@code @GroupSequence} is representing
 * the group sequence.
 * When hosted on a class, represents the {@link Default} group
 * for that class.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
@Target({ TYPE })
@Retention(RUNTIME)
public @interface GroupSequence {

    Class&lt;?&gt;[] value();
}</pre><p>Here is a usage example:</p><div class="example"><a name="example-groupsequence"></a><p class="title"><b>Example&nbsp;4.6.&nbsp;Make use of group sequence</b></p><pre class="programlisting">@ZipCodeCoherenceChecker(groups = Address.HighLevelCoherence.class)
public class Address {
    @NotNull @Size(max = 50)
    private String street1;

    @NotNull @ZipCode
    private String zipcode;

    @NotNull @Size(max = 30)
    private String city;

    /**
     * check coherence on the overall object
     * Needs basic checking to be green first
     */
    public interface HighLevelCoherence {}

    /**
     * check both basic constraints and high level ones.
     * high level constraints are not checked if basic constraints fail
     */
    @GroupSequence({Default.class, HighLevelCoherence.class})
    public interface Complete {}
}</pre></div><p>In <a href="#example-groupsequence" title="Example&nbsp;4.6.&nbsp;Make use of group sequence">Example&nbsp;4.6, &#8220;Make use of group sequence&#8221;</a>, when the
      <tt class="classname">Address.Complete</tt> group is validated, all
      constraints belonging to the <tt class="classname">Default</tt> group are
      validated. If any of them fail, the validation skips the
      <tt class="classname">HighLevelCoherence</tt> group. If all
      <tt class="classname">Default</tt> constraints pass,
      <tt class="classname">HighLevelCoherence</tt> constraints are
      evaluated.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><span class="tck-testable">A given constraint can belong to two
        or more groups ordered by a sequence. In this case, the constraint is
        evaluated as part of the first group and ignored in the subsequent
        group(s).</span> See <a href="#constraintdeclarationvalidationprocess-validationroutine" title="4.6.&nbsp;Validation routine">Section&nbsp;4.6, &#8220;Validation routine&#8221;</a>
        for more information.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup"></a>4.4.3.&nbsp;Redefining the Default group for a class</h3></div></div><div></div></div><p>In <a href="#example-groupsequence" title="Example&nbsp;4.6.&nbsp;Make use of group sequence">Example&nbsp;4.6, &#8220;Make use of group sequence&#8221;</a>, validating the
      <tt class="classname">Default</tt> group does not validate
      <tt class="classname">HighLevelCoherence</tt> constraints. To ensure a
      complete validation, a user must use the <tt class="classname">Complete</tt>
      group. This breaks some of the encapsulation you could expect. You can
      work around this by redefining what the <tt class="classname">Default</tt>
      group means for a given class. <span class="tck-testable">To redefine
      <tt class="classname">Default</tt> for a class, place a
      <tt class="classname">@GroupSequence</tt> annotation on the class; this
      sequence expresses the sequence of groups that does substitute
      <tt class="classname">Default</tt> for this class.</span></p><div class="example"><a name="example-overridedefaultgroup"></a><p class="title"><b>Example&nbsp;4.7.&nbsp;Redefining Default group for Address</b></p><pre class="programlisting">@GroupSequence({Address.class, HighLevelCoherence.class})
@ZipCodeCoherenceChecker(groups = Address.HighLevelCoherence.class)
public class Address {
    @NotNull @Size(max = 50)
    private String street1;

    @NotNull @ZipCode
    private String zipcode;

    @NotNull @Size(max = 30)
    private String city;

    /**
     * check coherence on the overall object
     * Needs basic checking to be green first
     */
    public interface HighLevelCoherence {}
}</pre></div><p>In <a href="#example-overridedefaultgroup" title="Example&nbsp;4.7.&nbsp;Redefining Default group for Address">Example&nbsp;4.7, &#8220;Redefining Default group for Address&#8221;</a>, when an address
      object is validated for the group <tt class="classname">Default</tt>, all
      constraints belonging to the group <tt class="classname">Default</tt> and
      hosted on <tt class="classname">Address</tt> are evaluated. If none fails,
      all <tt class="classname">HighLevelCoherence</tt> constraints present on
      <tt class="classname">Address</tt> are evaluated. In other words, when
      validating the <tt class="classname">Default</tt> group for
      <tt class="classname">Address</tt>, the group sequence defined on the
      <tt class="classname">Address</tt> class is used.</p><p>Since sequences cannot have circular dependencies, using
      <tt class="classname">Default</tt> in the declaration of a sequence is not
      an option. <span class="tck-not-testable">Constraints hosted on a class
      <tt class="classname">A</tt> and belonging to the
      <tt class="classname">Default</tt> group (by default or explicitly)
      implicitly belong to the group <tt class="classname">A</tt>.</span></p><p><span class="tck-testable">A sequence defined on a class
      <tt class="classname">A</tt> (i.e. redefining the
      <tt class="classname">Default</tt> groups for the class) must contain the
      group <tt class="classname">A</tt>.</span> In other words, the default
      constraints hosted on a class must be part of the sequence definition.
      <span class="tck-testable">If a <tt class="classname">@GroupSequence</tt>
      redefining the <tt class="classname">Default</tt> group for a class
      <tt class="classname">A</tt> does not contain the group
      <tt class="classname">A</tt>, a
      <tt class="classname">GroupDefinitionException</tt> is raised when the class
      is validated or when its metadata is requested.</span></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-groupsequence-implicitgrouping"></a>4.4.4.&nbsp;Implicit grouping</h3></div></div><div></div></div><p>It is possible to implicitly group several constraints in the same
      group without explicitly listing such a group in the constraint
      declaration. <span class="tck-testable">Every constraint hosted on an
      interface <tt class="classname">Z</tt> and part of the
      <tt class="classname">Default</tt> group (implicitly or explicitly) belongs
      to the group <tt class="classname">Z</tt>.</span> This is useful to
      validate the partial state of an object based on a role represented by
      an interface.</p><div class="example"><a name="d0e2065"></a><p class="title"><b>Example&nbsp;4.8.&nbsp;Example of interface / group hosting constraints</b></p><pre class="programlisting">/**
 * Auditable object contract
 */
public interface Auditable {
    @NotNull String getCreationDate();
    @NotNull String getLastUpdate();
    @NotNull String getLastModifier();
    @NotNull String getLastReader();
}

/**
 * Represents an order in the system
 */
public class Order implements Auditable {
    private String creationDate;
    private String lastUpdate;
    private String lastModifier;
    private String lastReader;

    private String orderNumber;

    public String getCreationDate() {
        return this.creationDate;
    }

    public String getLastUpdate() {
        return this.lastUpdate;
    }

    public String getLastModifier() {
        return this.lastModifier;
    }

    public String getLastReader() {
        return this.lastReader;
    }

    @NotNull @Size(min=10, max=10)
    public String getOrderNumber() {
        return this.orderNumber;
    }
}</pre></div><p>When an <tt class="classname">Order</tt> object is validated on the
      <tt class="classname">Default</tt> group, the following constraints are
      validated: <tt class="classname">@NotNull</tt> on
      <tt class="methodname">getCreationDate</tt>,
      <tt class="methodname">getLastUpdate</tt>,
      <tt class="methodname">getLastModifier</tt>,
      <tt class="methodname">getLastReader</tt>,
      <tt class="methodname">getOrderNumber</tt> and <tt class="classname">@Size</tt>
      on <tt class="methodname">getOrderNumber</tt> as all belong to the
      <tt class="classname">Default</tt> group.</p><p>When an <tt class="classname">Order</tt> object is validated on the
      <tt class="classname">Auditable</tt> group, the following constraints are
      validated: <tt class="classname">@NotNull</tt> on
      <tt class="methodname">getCreationDate</tt>,
      <tt class="methodname">getLastUpdate</tt>,
      <tt class="methodname">getLastModifier</tt>,
      <tt class="methodname">getLastReader</tt>. Only the constraints present on
      <tt class="classname">Auditable</tt> (and any of its super interfaces) and
      belonging to the <tt class="classname">Default</tt> group are validated when
      the group <tt class="classname">Auditable</tt> is requested. It allows the
      caller to validate that a given object can be safely audited even if the
      object state itself is not valid.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-groupsequence-groupconversion"></a>4.4.5.&nbsp;Group conversion</h3></div></div><div></div></div><p>When performing cascading validation, it is possible to use a
      different group than the one originally requested using the group
      conversion feature. Group conversions are declared by using the
      <tt class="classname">@ConvertGroup</tt> annotation.</p><div class="example"><a name="d0e2145"></a><p class="title"><b>Example&nbsp;4.9.&nbsp;@ConvertGroup annotation</b></p><pre class="programlisting">package javax.validation.groups;

/**
 * Converts group {@code from} to group {@code to} during cascading.
 * &lt;p/&gt;
 * Can be used everywhere {@link Valid} is used and must be on an element
 * annotated with {@code Valid}.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
@Target({ TYPE, METHOD, FIELD, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
public @interface ConvertGroup {

    Class&lt;?&gt; from();

    Class&lt;?&gt; to();

    /**
     * Defines several {@link ConvertGroup} annotations
     * on the same element.
     */
    @Target({ TYPE, METHOD, FIELD, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    public @interface List {

        ConvertGroup[] value();
    }
}</pre></div><p class="tck-testable"><tt class="classname">@ConvertGroup</tt> and
      <tt class="classname">@ConvertGroup.List</tt> can be used everywhere
      <tt class="classname">@Valid</tt> can be used (associations,
      method/constructor parameters and return value). If these annotations
      are used without <tt class="classname">@Valid</tt>, a
      <tt class="classname">ConstraintDeclarationException</tt> is raised.</p><p>When an element is annotated with <tt class="classname">@Valid</tt>,
      validation is propagated. <span class="tck-testable">Groups are passed
      as is to the nested elements unless the
      <tt class="classname">@ConvertGroup</tt> annotation is used.</span></p><p class="tck-testable">If the group expected to be passed to the
      nested element validation is defined as the <tt class="literal">from</tt>
      attribute of a <tt class="classname">@ConvertGroup</tt> annotation, the
      group used to effectively validate the nested element is the
      corresponding group defined in the <tt class="literal">to</tt>
      attribute.</p><p><span class="tck-testable">Rules are not executed
      recursively.</span> If a rule is found matching, subsequent rules are
      no longer evaluated. In particular, if a set of
      <tt class="classname">@ConvertGroup</tt> declaration chains group
      <tt class="literal">A</tt> to <tt class="literal">B</tt> and <tt class="literal">B</tt> to
      <tt class="literal">C</tt>, the group <tt class="literal">A</tt> will be converted
      to <tt class="literal">B</tt> and not to <tt class="literal">C</tt>. This both makes
      rules clearer and let you switch two groups.</p><p class="tck-testable">It is not legal to have more than one
      conversion rule containing the same <tt class="literal">from</tt> value. In
      this case, a <tt class="classname">ConstraintDeclarationException</tt> is
      raised.</p><p><span class="tck-testable">Like regular constraint declarations,
      the <tt class="literal">from</tt> attribute cannot refer to a group sequence.
      A <tt class="classname">ConstraintDeclarationException</tt> is raised in
      this situation.</span> <span class="tck-testable">The
      <tt class="literal">to</tt> attribute can. The group sequence will then be
      expanded before validating the associated object.</span></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>When validation is done, group sequences are expanded before
        validating the object and its cascaded objects with the expected
        groups. Group conversion on an associated object happens on the
        already expanded groups.</p><p>The group referred to in
        <tt class="methodname">@ConvertGroup.from</tt> works on expanded groups
        (i.e., after the group sequence has been expanded), not necessarily
        groups passed to the various <tt class="methodname">validate</tt>
        methods.</p><p>The group referred to in
        <tt class="methodname">@ConvertGroup.to</tt> will be expanded before
        validating the cascaded object just like a call to the various
        <tt class="methodname">validate</tt> method would have done.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Like most Bean Validation error cases, an illegal set of rules
        can be discovered statically (at compile time). For example, an
        annotation processor could detect such errors.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Group circularity in a group conversion are not problematic
        because:</p><div class="itemizedlist"><ul type="disc"><li><p>only one rule is applied for a given cascade (rules are not
            applied recursively)</p></li><li><p>validation cascading is stopped when the same instance /
            property is validated with the same group in a given path
            (existing rule)</p></li></ul></div></div><p><span class="tck-testable"><tt class="classname">@ConvertGroup</tt>
      and <tt class="classname">@ConvertGroup.List</tt> can only be placed where
      <tt class="classname">@Valid</tt> is present to ensure proper respect of the
      Liskov substitution principle:</span> if rules were to be defined on
      an overriding method of a method marked as cascading validation, the
      rules could end up altering the list of constraints validated by the
      super type and thus violating the Liskov substitution principle.</p><p><span class="tck-testable">Likewise, if a sub type
      overrides/implements a method originally defined in several parallel
      types of the hierarchy (e.g. two interfaces not extending each other, or
      a class and an interface not implemented by said class) and if that
      method's return value has been marked for cascading validation in one of
      the parallel types, no group conversion rule may be declared for that
      method's return value in the parallel types of the hierarchy.</span>
      This again is to avoid an unexpected altering of the post conditions to
      be guaranteed to the caller.</p><p class="tck-testable">If any of these rules is violated, a
      <tt class="classname">ConstraintDeclarationException</tt> is raised by
      default as defined in <a href="#constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance" title="4.5.5.&nbsp;Method constraints in inheritance hierarchies">Section&nbsp;4.5.5, &#8220;Method constraints in inheritance hierarchies&#8221;</a>.</p><p>Group conversion is quite useful to facilitate object graph reuse
      without spreading the validation group definitions across several
      layers. Let's look at an example.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2295"></a>4.4.5.1.&nbsp;Group conversion examples</h4></div></div><div></div></div><p>In this example we will reuse the <tt class="classname">Address</tt>
        group split and match it to the <tt class="classname">User</tt> group
        split.</p><div class="example"><a name="d0e2306"></a><p class="title"><b>Example&nbsp;4.10.&nbsp;Example of group conversion</b></p><pre class="programlisting">public interface Complete extends Default {}
public interface BasicPostal {}
public interface FullPostal extends BasicPostal {}

public class Address {
    @NotNull(groups=BasicPostal.class)
    String street1;

    String street2;

    @ZipCode(groups=BasicPostal.class)
    String zipCode;

    @CodeChecker(groups=FullPostal.class)
    String doorCode;
}

public class User {
    @Valid
    @ConvertGroup.List( {
        @ConvertGroup(from=Default.class, to=BasicPostal.class),
        @ConvertGroup(from=Complete.class, to=FullPostal.class)
    } )
    Set&lt;Address&gt; getAddresses() { [...] }
}</pre></div><p>When validating an instance of <tt class="classname">User</tt> with
        the <tt class="classname">Default</tt> group, the associated addresses are
        validated with the <tt class="classname">BasicPostal</tt> group. When
        validating an instance of <tt class="classname">User</tt> with the
        <tt class="classname">Complete</tt> group, the associated addresses are
        validated with the <tt class="classname">FullPostal</tt> group.</p><p>The following example shows an illegal declaration of a group
        conversion rule on a method's return value:</p><div class="example"><a name="d0e2334"></a><p class="title"><b>Example&nbsp;4.11.&nbsp;Example of an illegal group conversion</b></p><pre class="programlisting">public interface BasicPostal {}

public class Order { [...] }

public interface RetailOrderService {

    @Valid
    Order placeOrder(String itemNo, int quantity);
}

public interface B2BOrderService {

    @Valid
    @ConvertGroup(from=Default.class, to=BasicPostal.class)
    Order placeOrder(String itemNo, int quantity);
}

public class OrderService implements RetailOrderService, B2BOrderService {

    @Override
    public Order placeOrder(String itemNo, int quantity) {
        [...]
    }
}</pre></div><p>Here the class <tt class="classname">OrderService</tt>
        implements the two unrelated interfaces
        <tt class="classname">RetailOrderService</tt> and
        <tt class="classname">B2BOrderService</tt>, which both define a method
        <tt class="methodname">placeOrder()</tt>, marking the return value as
        cascaded.</p><p>The group conversion declared in
        <tt class="classname">B2BOrderService</tt> is illegal as per the rules
        defined in the previous section, since the set of applied validation
        groups might be altered unexpectedly for a client of the
        <tt class="classname">RetailOrderService</tt> interface.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-groupsequence-formaldefinition"></a>4.4.6.&nbsp;Formal group definitions</h3></div></div><div></div></div><p>The formal rules defining groups are as followed. <span class="emphasis"><em>Text
      in italic are comments about the rules.</em></span></p><p>For every class <tt class="classname">X</tt>:</p><div class="orderedlist"><ol type="A"><li><p>For each superclass <tt class="classname">Y</tt> of
          <tt class="classname">X</tt>, the group <tt class="classname">Y</tt>
          contains all constraints of the group <tt class="classname">Y</tt> of
          <tt class="classname">Y</tt></p><p><span class="emphasis"><em>this rule prepares formal concepts for recursive
          discovery</em></span></p></li><li><p>The group <tt class="classname">X</tt> contains the following
          constraints:</p><p class="tck-ignore"><span class="emphasis"><em>group <tt class="classname">X</tt> is
          a group used on sequences redefining the default group on a class
          (see <a href="#constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup" title="4.4.3.&nbsp;Redefining the Default group for a class">Section&nbsp;4.4.3, &#8220;Redefining the Default group for a class&#8221;</a>)</em></span></p><div class="orderedlist"><ol type="I"><li><p>every constraint declared by the class
              <tt class="classname">X</tt> which does not declare a group or does
              declare the group <tt class="classname">Default</tt>
              explicitly.</p><p class="tck-ignore"><span class="emphasis"><em>all
              <tt class="classname">Default</tt> constraints hosted on
              <tt class="classname">X</tt></em></span></p></li><li><p>every constraint declared by any interface implemented by
              <tt class="classname">X</tt> and not annotated
              <tt class="classname">@GroupSequence</tt> which does not explicitly
              declare a group or does declare the group
              <tt class="classname">Default</tt> explicitly.</p><p class="tck-ignore"><span class="emphasis"><em>all
              <tt class="classname">Default</tt> constraints hosted on interfaces
              of <tt class="classname">X</tt>: constraints are inherited by the
              class hierarchy. Interfaces marked as
              <tt class="classname">@GroupSequence</tt> are
              ignored.</em></span></p></li><li><p>if <tt class="classname">X</tt> has a direct superclass
              <tt class="classname">Y</tt>, every constraint in the group
              <tt class="classname">Y</tt></p><p class="tck-ignore"><span class="emphasis"><em>all
              <tt class="classname">Default</tt> constraints hosted on the
              superclasses of <tt class="classname">X</tt>: constraints are
              inherited by the class hierarchy</em></span></p></li></ol></div></li><li><p>If <tt class="classname">X</tt> has no
          <tt class="classname">@GroupSequence</tt> annotation, the group
          <tt class="classname">Default</tt> contains the following
          constraints:</p><p class="tck-ignore"><span class="emphasis"><em>this rule defines which
          constraints are evaluated when validating
          <tt class="classname">Default</tt> on
          <tt class="classname">X</tt>.</em></span></p><div class="orderedlist"><ol type="I"><li><p>every constraint in the group
              <tt class="classname">X</tt></p></li><li><p>if <tt class="classname">X</tt> has a direct superclass
              <tt class="classname">Y</tt>, every constraint in the group
              <tt class="classname">Default</tt> of
              <tt class="classname">Y</tt></p><p class="tck-ignore"><span class="emphasis"><em>this rule is necessary in case
              <tt class="classname">Y</tt> redefines the group
              <tt class="classname">Default</tt></em></span></p></li></ol></div></li><li><p class="tck-testable">If <tt class="classname">X</tt> does have a
          <tt class="classname">@GroupSequence</tt> annotation, the group
          <tt class="classname">Default</tt> contains every constraint belonging
          to every group declared by the <tt class="classname">@GroupSequence</tt>
          annotation.</p><p><span class="emphasis"><em>this rule describes how a class can redefine the
          group <tt class="classname">Default</tt> for itself (see <a href="#constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup" title="4.4.3.&nbsp;Redefining the Default group for a class">Section&nbsp;4.4.3, &#8220;Redefining the Default group for a class&#8221;</a>)</em></span></p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable">the
              <tt class="classname">@GroupSequence</tt> annotation must declare
              the group <tt class="classname">X</tt></p></li></ul></div></li><li><p>For every interface <tt class="classname">Z</tt>, the group
          <tt class="classname">Z</tt> contains the following constraints:</p><p class="tck-ignore"><span class="emphasis"><em>this rule defines how non
          <tt class="classname">Default</tt> groups are defined</em></span></p><div class="orderedlist"><ol type="I"><li><p>every constraint declared by the interface
              <tt class="classname">Z</tt> which does not explicitly declare a
              group or does declare the group <tt class="classname">Default</tt>
              explicitly.</p><p class="tck-ignore"><span class="emphasis"><em>all
              <tt class="classname">Default</tt> constraints hosted on
              <tt class="classname">Z</tt>: this rule formally defines implicit
              grouping per interface (see <a href="#constraintdeclarationvalidationprocess-groupsequence-implicitgrouping" title="4.4.4.&nbsp;Implicit grouping">Section&nbsp;4.4.4, &#8220;Implicit grouping&#8221;</a>)</em></span></p></li><li><p>every constraint (which does not explicitly declare a
              group) declared by any superinterface not annotated
              <tt class="classname">@GroupSequence</tt> of the interface
              <tt class="classname">Z</tt></p><p class="tck-ignore"><span class="emphasis"><em>all
              <tt class="classname">Default</tt> constraints hosted on interfaces
              of <tt class="classname">Z</tt>: groups can be inherited (see <a href="#constraintdeclarationvalidationprocess-groupsequence-groupinheritance" title="4.4.1.&nbsp;Group inheritance">Section&nbsp;4.4.1, &#8220;Group inheritance&#8221;</a>)</em></span></p></li><li><p>every constraint declared by the class
              <tt class="classname">X</tt> which explicitly declares the group
              <tt class="classname">Z</tt></p><p class="tck-ignore"><span class="emphasis"><em>every constraint hosted by
              <tt class="classname">X</tt> and marked as belonging to the group
              <tt class="classname">Z</tt></em></span></p></li><li><p>every constraint declared by any interface implemented by
              <tt class="classname">X</tt> and not annotated
              <tt class="classname">@GroupSequence</tt> which explicitly declares
              the group <tt class="classname">Z</tt></p><p class="tck-ignore"><span class="emphasis"><em>every constraint hosted by any
              interface of <tt class="classname">X</tt> and marked as belonging to
              the group <tt class="classname">Z</tt></em></span></p></li><li><p>if <tt class="classname">X</tt> has a direct superclass
              <tt class="classname">Y</tt>, every constraint in the group
              <tt class="classname">Z</tt> of <tt class="classname">Y</tt></p><p class="tck-ignore"><span class="emphasis"><em>every constraint hosted by any
              superclass of <tt class="classname">X</tt> and marked as belonging
              to the group <tt class="classname">Z</tt></em></span></p></li></ol></div></li><li><p class="tck-testable">For every interface
          <tt class="classname">Z</tt> annotated
          <tt class="classname">@GroupSequence</tt>, the group
          <tt class="classname">Z</tt> contains every constraint belonging to
          every group declared by the <tt class="classname">@GroupSequence</tt>
          annotation.</p><p><span class="emphasis"><em>defines the composition side of group sequence but
          does not define the ordering behavior of sequence (see <a href="#constraintdeclarationvalidationprocess-groupsequence-groupsequence" title="4.4.2.&nbsp;Group sequence">Section&nbsp;4.4.2, &#8220;Group sequence&#8221;</a>)</em></span></p></li></ol></div><p class="tck-testable">When a given group <tt class="classname">G</tt>
      (represented by an interface <tt class="classname">G</tt>) is requested for
      the validation of a class <tt class="classname">X</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>constraints belonging to the group <tt class="classname">G</tt>
            are evaluated</p></li><li><p>if the interface <tt class="classname">G</tt> is not annotated
            <tt class="classname">@GroupSequence</tt>, every group represented by
            the super interface of <tt class="classname">G</tt> are requested for
            validation</p></li><li><p>if the interface <tt class="classname">G</tt> is annotated with
            <tt class="classname">@GroupSequence</tt>, every group represented by
            the interfaces declared by the
            <tt class="classname">@GroupSequence</tt> annotation are requested for
            validation</p><div class="itemizedlist"><ul type="circle"><li><p>the validation of groups declared to the
                <tt class="classname">@GroupSequence</tt> must happen in the
                sequencing order declared by
                <tt class="classname">@GroupSequence</tt>: the sequencing order is
                propagated to the groups composing the sequenced group (via
                inheritance or group sequence)</p></li><li><p>if a group validation triggers the failure of one or
                more constraints, groups following in the sequence must not be
                evaluated.</p></li></ul></div></li><li><p>if the group <tt class="classname">G</tt> represents the
            <tt class="classname">Default</tt> group of <tt class="classname">X</tt>
            overridden by <tt class="classname">@GroupSequence</tt>, operations
            are equivalent</p></li></ul></div><p class="tck-testable">When the <tt class="classname">Default</tt> group
      of a given class <tt class="classname">X</tt> is overridden via
      <tt class="classname">@GroupSequence</tt>, its validation is as
      followed:</p><div class="itemizedlist"><ul type="disc"><li><p>every group represented by the interfaces declared by the
            <tt class="classname">@GroupSequence</tt> annotation are requested for
            validation</p><div class="itemizedlist"><ul type="circle"><li><p>the validation of groups declared to the
                <tt class="classname">@GroupSequence</tt> must happen in the
                sequencing order declared by
                <tt class="classname">@GroupSequence</tt>: the sequencing order is
                propagated to the groups composing the sequenced group (via
                inheritance or group sequence)</p></li><li><p>if a group validation triggers the failure of one or
                more constraints, groups following in the sequence must not be
                evaluated.</p></li></ul></div></li></ul></div><p><span class="tck-not-testable">Unless defined by a
      <tt class="classname">@GroupSequence</tt>, evaluation ordering is not
      constrained. In particular, several groups can be validated in the same
      pass.</span> <span class="tck-testable">If a group definition leads
      to a circular sequencing order between groups, a
      <tt class="classname">GroupDefinitionException</tt> is
      raised.</span></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A group <tt class="classname">G</tt> sequenced (directly or
        indirectly) to be executed before itself is not considered a circular
        reference.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintdeclarationvalidationprocess-methodlevelconstraints"></a>4.5.&nbsp;Method and constructor constraints</h2></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In the following, the term "method constraint" refers to
      constraints declared on methods as well as constructors.</p></div><p>Method constraints are declared by adding constraint annotations
    directly to methods or constructors and/or their parameters. In the former
    case, all the parameters of an executable (cross-parameter constraint) or
    the return value is constrained, in the latter individual parameters are
    constrained. As with bean constraints, this can be done using either
    actual Java annotations or using an XML constraint mapping file (see <a href="#xml-mapping-constraintdeclarationinxml-methodleveloverriding" title="8.1.1.5.&nbsp;Method-level overriding">Section&nbsp;8.1.1.5, &#8220;Method-level overriding&#8221;</a>).
    Bean Validation providers are free to provide additional means of defining
    method constraints such as an API-based approach.</p><p>Getters are not considered constrained methods by default (see <a href="#integration-general-executable" title="10.1.2.&nbsp;Method and constructor validation">Section&nbsp;10.1.2, &#8220;Method and constructor validation&#8221;</a>).</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2815"></a>4.5.1.&nbsp;Requirements on methods to be validated</h3></div></div><div></div></div><p><span class="tck-not-testable">Static methods are ignored by
      validation. Putting constraints on a static method is not
      portable.</span> No other restrictions exist from the perspective of
      this specification, however it is possible that technologies integrating
      with method validation impose further restrictions to methods for which
      a validation shall be applied. For instance certain integration
      technologies might require that methods to be validated must have
      <tt class="methodname">public</tt> visibility and/or must not be
      final.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2825"></a>4.5.2.&nbsp;Declaring parameter constraints</h3></div></div><div></div></div><p class="tck-testable">Parameter constraints are declared by putting
      constraint annotations on method or constructor parameters.</p><div class="example"><a name="d0e2830"></a><p class="title"><b>Example&nbsp;4.12.&nbsp;Declaring parameter constraints</b></p><pre class="programlisting">public class OrderService {

    public OrderService(@NotNull CreditCardProcessor creditCardProcessor) {
        [...]
    }

    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity) {
        [...]
    }
}</pre></div><p>Using constraint annotations, several preconditions are defined
      here. These preconditions which must be satisfied in order to legally
      invoke the methods of <tt class="classname">OrderService</tt> are:</p><div class="itemizedlist"><ul type="disc"><li><p>The <tt class="classname">CreditCardProcessor</tt> passed to the
          constructor must not be null.</p></li><li><p>The customer code passed to the
          <tt class="methodname">placeOrder()</tt> method must not be null and
          must be between 3 and 20 characters long.</p></li><li><p>The <tt class="classname">Item</tt> passed to the
          <tt class="methodname">placeOrder()</tt> method must not be
          null.</p></li><li><p>The quantity value passed to the
          <tt class="methodname">placeOrder()</tt> method must be 1 at
          least.</p></li></ul></div><p>Note that declaring these constraints does not automatically cause
      their validation when the concerned methods are invoked. It's the
      responsibility of an integration layer to trigger the validation of the
      constraints using a method interceptor, dynamic proxy or similar. See
      section <a href="#validationapi-triggeringmethodvalidation" title="5.4.&nbsp;Triggering method validation">Section&nbsp;5.4, &#8220;Triggering method validation&#8221;</a> for
      more details.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>In order to use constraint annotations for method or constructor
        parameters, their element type must be
        <tt class="varname">ElementType.PARAMETER</tt>. In order to use constraint
        annotations for cross-parameter validation or on the return values of
        methods or constructors (see the following sections), their element
        type must be <tt class="varname">ElementType.METHOD</tt> respectively
        <tt class="varname">ElementType.CONSTRUCTOR</tt>. All built-in constraints
        support these element types and it is considered a best practice to do
        the same for custom constraints.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="constraintdeclarationvalidationprocess-crossparameterconstraints"></a>4.5.2.1.&nbsp;Cross-parameter constraints</h4></div></div><div></div></div><p>Cross-parameter constraints allow to express constraints based
        on the value of several method parameters, similar to class-level
        constraints which are based on several properties of a given class.
        <span class="tck-testable">Cross-parameter constraints are declared
        by putting cross-parameter constraint annotations on methods or
        constructors</span> as shown in the following example.</p><div class="example"><a name="d0e2892"></a><p class="title"><b>Example&nbsp;4.13.&nbsp;Declaring cross-parameter constraints</b></p><pre class="programlisting">public class CalendarService {

    @ConsistentDateParameters
    public void createEvent(
        String title,
        @NotNull Date startDate,
        @NotNull Date endDate) {
        [...]
    }
}</pre></div><p>The cross-parameter constraint annotation expresses here that
        the given start date must be before the passed end date in order to
        legally invoke the <tt class="methodname">createEvent()</tt> method. The
        example also shows that it is often useful to combine constraints
        directly placed on individual parameters (<tt class="classname">e.g.
        @NotNull</tt>) and cross-parameter constraints.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>Cross-parameter constraints as well as return value
            constraints are declared directly on a method or a constructor. To
            make it obvious for a reader that an annotation refers to the
            parameters of a method or constructor and not its return value, it
            is recommended to chose a name which clearly expresses this
            intention.</p></div><p class="tck-testable">It is not legal to declare a cross-parameter
        constraint on a method or constructor which has no parameters. A
        <tt class="classname">ConstraintDeclarationException</tt> is raised in
        this case.</p><p>Some constraints can target an executable's return value as well
        as its array of parameters. <span class="tck-testable">They are known
        to be both generic and cross-parameter constraints. When using such a
        constraint on an executable to target the parameters, one must set
        <tt class="methodname">validationAppliesTo</tt> if there is an
        ambiguity.</span> The set of ambiguities is described in <a href="#constraintsdefinitionimplementation-constraintdefinition-validationappliesto" title="3.1.1.4.&nbsp;validationAppliesTo">Section&nbsp;3.1.1.4, &#8220;validationAppliesTo&#8221;</a>.
        Even without ambiguity, it is recommended to explicitly set
        <tt class="methodname">validationAppliesTo</tt> to
        <tt class="literal">ConstraintTarget.PARAMETERS</tt> as it improves
        readability.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="constraintdeclarationvalidationprocess-methodlevelconstraints-definingparameterconstraints-namingparameters"></a>4.5.2.2.&nbsp;Naming parameters</h4></div></div><div></div></div><p>In case the validation of a parameter constraint fails, the
        concerned parameter needs to be identified in the resulting
        <tt class="classname">ConstraintViolation</tt> (see section <a href="#validationapi-constraintviolation" title="5.2.&nbsp;ConstraintViolation">Section&nbsp;5.2, &#8220;ConstraintViolation&#8221;</a>). As of version 7, Java
        doesn't provide a portable way to retrieve parameter names. Bean
        Validation therefore defines the
        <tt class="classname">javax.validation.ParameterNameProvider</tt> API to
        which the retrieval of parameter names is delegated:</p><pre class="programlisting">/**
 * Provides names for method and constructor parameters.
 * &lt;p/&gt;
 * Used by the Bean Validation runtime when creating constraint violation
 * objects for violated method constraints.
 * &lt;p/&gt;
 * Implementations must be thread-safe.
 *
 * @author Gunnar Morling
 * @since 1.1
 */
public interface ParameterNameProvider {

    /**
     * Returns the names of the parameters of the given constructor.
     *
     * @param constructor the constructor for which the parameter names shall be
     *        retrieved; never {@code null}
     * @return a list containing the names of the parameters of the given
     *         constructor; may be empty but never {@code null}
     */
    List&lt;String&gt; getParameterNames(Constructor&lt;?&gt; constructor);

    /**
     * Returns the names of the parameters of the given method.
     *
     * @param method the method for which the parameter names shall be retrieved;
     *        never {@code null}
     * @return a list containing the names of the parameters of the given method;
     *         may be empty but never {@code null}
     */
    List&lt;String&gt; getParameterNames(Method method);
}</pre><p class="tck-testable">A conforming Bean Validation implementation
        provides a default <tt class="classname">ParameterNameProvider</tt>
        implementation which returns parameter names in the form
        <tt class="varname">arg</tt><span class="emphasis"><em>PARAMETER_INDEX</em></span>, where
        <span class="emphasis"><em>PARAMETER_INDEX</em></span> starts at 0 for the first
        parameter, e.g. <tt class="varname">arg0</tt>, <tt class="varname">arg1</tt>
        etc.</p><p>Bean Validation providers and integrators are free to provide
        additional implementations (e.g. based on annotations specifying
        parameter names, debug symbols etc.). If a user wishes to use another
        parameter name provider than the default implementation, she may
        specify the provider to use with help of the bootstrap API (see <a href="#bootstrapping" title="5.5.&nbsp;Bootstrapping">Section&nbsp;5.5, &#8220;Bootstrapping&#8221;</a>) or the XML configuration (see <a href="#xml-config" title="5.5.6.&nbsp;XML configuration: META-INF/validation.xml">Section&nbsp;5.5.6, &#8220;XML configuration: META-INF/validation.xml&#8221;</a>).</p><p class="tck-testable">If an exception occurs during invocation of
        the <tt class="methodname">getParameterNames()</tt> methods, this
        exception is wrapped into a <tt class="classname">ValidationException</tt>
        by the Bean Validation engine.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2978"></a>4.5.3.&nbsp;Declaring return value constraints</h3></div></div><div></div></div><p class="tck-testable">Return value constraints are declared by
      putting constraint annotations directly on a method or
      constructor.</p><p>Some constraints can target both the return value and the array of
      parameters of an executable. <span class="tck-testable">They are known
      to be both generic and cross-parameter constraints. When using such
      constraint on an executable to target the return value, one must set
      <tt class="methodname">validationAppliesTo</tt> in case there is an
      ambiguity.</span> The set of ambiguities is described in <a href="#constraintsdefinitionimplementation-constraintdefinition-validationappliesto" title="3.1.1.4.&nbsp;validationAppliesTo">Section&nbsp;3.1.1.4, &#8220;validationAppliesTo&#8221;</a>.
      Even without ambiguity, it is recommended to explicitly set
      <tt class="methodname">validationAppliesTo</tt> to
      <tt class="literal">ConstraintTarget.RETURN_VALUE</tt> as it improves
      readability.</p><div class="example"><a name="d0e2999"></a><p class="title"><b>Example&nbsp;4.14.&nbsp;Declaring return value constraints</b></p><pre class="programlisting">public class OrderService {

    private CreditCardProcessor creditCardProcessor;

    @ValidOnlineOrderService
    public OrderService(OnlineCreditCardProcessor creditCardProcessor) {
        this.creditCardProcessor = creditCardProcessor;
    }

    @ValidBatchOrderService
    public OrderService(BatchCreditCardProcessor creditCardProcessor) {
        this.creditCardProcessor = creditCardProcessor;
    }

    @NotNull
    @Size(min=1)
    public Set&lt;CreditCardProcessor&gt; getCreditCardProcessors() { [...] }

    @NotNull
    @Future
    public Date getNextAvailableDeliveryDate() { [...] }
}</pre></div><p>Here the following postconditions are defined which are guaranteed
      to the caller of the methods and constructors of the
      <tt class="classname">OrderService</tt> class:</p><div class="itemizedlist"><ul type="disc"><li><p>The newly created <tt class="classname">OrderService</tt> object
          returned by the first constructor satisfies the conditions of the
          custom <tt class="classname">@ValidOnlineOrderService</tt>
          constraint.</p></li><li><p>The newly created <tt class="classname">OrderService</tt> object
          returned by the second constructor satisfies the conditions of the
          custom <tt class="classname">@ValidBatchOrderService</tt>
          constraint.</p></li><li><p>The set of <tt class="classname">CreditCardProcessor</tt> objects
          returned by <tt class="methodname">getCreditCardProcessors()</tt> will
          neither be null nor be empty.</p></li><li><p>The <tt class="classname">Date</tt> object returned by
          <tt class="methodname">getNextAvailableDeliveryDate()</tt> will not be
          null and will be in the future.</p></li></ul></div><p>Like parameter constraints, these return value constraints are not
      per-se validated upon method invocation, but instead an integration
      layer invoking the validation is required.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3048"></a>4.5.4.&nbsp;Marking parameters and return values for cascaded
      validation</h3></div></div><div></div></div><p><span class="tck-testable">The <tt class="classname">@Valid</tt>
      annotation is used to declare that a cascaded validation of the given
      method/constructor parameters or return values is performed by the Bean
      Validation provider. When marked, the parameter or return value is
      considered a bean object to validate.</span> The same rules as for
      standard object graph validation (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
      apply, in particular</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable">null arguments and null return values are
          ignored</p></li><li><p class="tck-testable">The validation is recursive; that is, if
          validated parameter or return value objects have references marked
          with <tt class="classname">@Valid</tt> themselves, these references will
          also be validated</p></li><li><p class="tck-not-testable">Bean Validation providers must
          guarantee the prevention of infinite loops during cascaded
          validation</p></li></ul></div><div class="example"><a name="d0e3073"></a><p class="title"><b>Example&nbsp;4.15.&nbsp;Marking parameters and return values for cascaded
        validation</b></p><pre class="programlisting">public class OrderService {

    @NotNull @Valid
    private CreditCardProcessor creditCardProcessor;

    @Valid
    public OrderService(@NotNull @Valid CreditCardProcessor creditCardProcessor) {
        this.creditCardProcessor = creditCardProcessor;
    }

    @NotNull @Valid
    public Order getOrderByPk(@NotNull @Valid OrderPK orderPk) { [...] }

    @NotNull @Valid
    public Set&lt;Order&gt; getOrdersByCustomer(@NotNull @Valid CustomerPK customerPk) { [...] }
}</pre></div><p>Here the following recursive validations will happen when
      validating the methods of the <tt class="classname">OrderService</tt>
      class:</p><div class="itemizedlist"><ul type="disc"><li><p>Validation of the constraints on the object passed for the
          <tt class="varname">creditCardProcessor</tt> parameter of the
          constructor</p></li><li><p>Validation of the constraints on the newly created
          <tt class="classname">OrderService</tt> instance returned by the
          constructor, i.e. the <tt class="classname">@NotNull</tt> constraint on
          the field <tt class="varname">creditCardProcessor</tt> and the constraints
          on the referenced <tt class="classname">CreditCardProcessor</tt>
          instance (as the field is annotated with
          <tt class="classname">@Valid</tt>).</p></li><li><p>Validation of the constraints on the object passed for the
          <tt class="varname">orderPk</tt> parameter and the returned
          <tt class="classname">Order</tt> object of the
          <tt class="methodname">getOrderByPk()</tt> method</p></li><li><p>Validation of the constraints on the object passed for the
          <tt class="varname">customerPk</tt> parameter and the constraints on each
          object contained within the returned
          <tt class="varname">Set&lt;Order&gt;</tt> of the
          <tt class="methodname">getOrdersByCustomer()</tt> method</p></li></ul></div><p>Again, solely marking parameters and return values for cascaded
      validation does not trigger the actual validation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance"></a>4.5.5.&nbsp;Method constraints in inheritance hierarchies</h3></div></div><div></div></div><p>When defining method constraints within inheritance hierarchies
      (that is, class inheritance by extending base classes and interface
      inheritance by implementing or extending interfaces) one has to obey the
      <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_top">Liskov
      substitution</a> principle which mandates that:</p><div class="itemizedlist"><ul type="disc"><li><p>a method's preconditions (as represented by parameter
          constraints) must not be strengthened in sub types</p></li><li><p>a method's postconditions (as represented by return value
          constraints) must not be weakened in sub types</p></li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>Very informally speaking, the Liskov substitution principle says
        that where a given type T is used, it should be possible to replace T
        with a sub-type S of T ("Behavioral subtyping"). If S
        overrides/implements a method from T and S would strengthen the
        method's preconditions (e.g. by adding parameter constraints) this
        principle would be violated as client code working correctly against T
        might fail when working against S. Also if S overrides/implements a
        method from T and S weakens the method's postconditions this principle
        would be violated. However S may strengthen the method's
        postconditions (by adding return value constraints), as client code
        working against T still will work against S.</p></div><p>Therefore the following rules with respect to the definition of
      method level constraints in inheritance hierarchies apply:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable">In sub types (be it sub classes/interfaces
          or interface implementations), no parameter constraints may be
          declared on overridden or implemented methods, nor may parameters be
          marked for cascaded validation. This would pose a strengthening of
          preconditions to be fulfilled by the caller.</p></li><li><p class="tck-testable">If a sub type overrides/implements a
          method originally defined in several parallel types of the hierarchy
          (e.g. two interfaces not extending each other, or a class and an
          interface not implemented by said class), no parameter constraints
          may be declared for that method at all nor parameters be marked for
          cascaded validation. This again is to avoid an unexpected
          strengthening of preconditions to be fulfilled by the caller.</p></li><li><p class="tck-testable">In sub types (be it sub classes/interfaces
          or interface implementations), return value constraints may be
          declared on overridden or implemented methods and the return value
          may be marked for cascaded validation. Upon validation, all return
          value constraints of the method in question are validated, wherever
          they are declared in the hierarchy. This only poses possibly a
          strengthening but no weakening of the method's postconditions
          guaranteed to the caller.</p></li><li><p class="tck-testable">One must not mark a method return value
          for cascaded validation more than once in a line of a class
          hierarchy. In other words, overriding methods on sub types (be it
          sub classes/interfaces or interface implementations) cannot mark the
          return value for cascaded validation if the return value has already
          been marked on the overridden method of the super type or
          interface.</p></li></ul></div><p><span class="tck-testable">Out of the box, a conforming Bean
      Validation provider must throw a
      <tt class="classname">ConstraintDeclarationException</tt> when discovering
      that any of these rules are violated.</span> In addition providers may
      implement alternative, potentially more liberal, approaches for handling
      constrained methods in inheritance hierarchies. Possible means for
      activating such alternative behavior include provider-specific
      configuration properties or annotations. Note that client code relying
      on such alternative behavior is not portable between Bean Validation
      providers.</p><p class="tck-testable">The above rules do not apply when validating
      constructor constraints as constructors do not override one another.
      Parameter and return value constraints can be applied to any constructor
      in the type hierarchy, but only the constraints defined directly on the
      validated constructor are evaluated.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3176"></a>4.5.5.1.&nbsp;Examples</h4></div></div><div></div></div><p>This sections provides some examples of illegal constraint
        definitions which violate the rules stated above in one way or
        another.</p><div class="example"><a name="d0e3181"></a><p class="title"><b>Example&nbsp;4.16.&nbsp;Illegally declared parameter constraints on interface
          implementation</b></p><pre class="programlisting">public interface OrderService {

    void placeOrder(String customerCode, Item item, int quantity);
}

public class SimpleOrderService implements OrderService {

    @Override
    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity) {
        [...]
    }
}</pre></div><p>The constraints in <tt class="classname">SimpleOrderService</tt> are
        illegal, as they strengthen the preconditions of the
        <tt class="methodname">placeOrder()</tt> method as constituted by the
        interface <tt class="classname">OrderService</tt>.</p><div class="example"><a name="d0e3198"></a><p class="title"><b>Example&nbsp;4.17.&nbsp;Illegally declared parameter constraints on sub
            class</b></p><pre class="programlisting">public class OrderService {

    void placeOrder(String customerCode, Item item, int quantity) { [...] }
}

public class SimpleOrderService extends OrderService {

    @Override
    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity) {
        [...]
    }
}</pre></div><p>The constraints in <tt class="classname">SimpleOrderService</tt> are
        illegal, as they strengthen the preconditions of the
        <tt class="methodname">placeOrder()</tt> method as constituted by the
        super class <tt class="classname">OrderService</tt>.</p><div class="example"><a name="illegal_constraints_in_parallel_types"></a><p class="title"><b>Example&nbsp;4.18.&nbsp;Illegally declared parameter constraints on parallel
            types</b></p><pre class="programlisting">public interface OrderService {

    void placeOrder(String customerCode, Item item, int quantity);
}

public interface OrderPlacementService {

    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity);
}

public class SimpleOrderService implements OrderService, OrderPlacementService {

    @Override
    public void placeOrder(String customerCode, Item item, int quantity) {
        [...]
    }
}</pre></div><p>Here the class <tt class="classname">SimpleOrderService</tt>
        implements the interfaces <tt class="classname">OrderService</tt> and
        <tt class="classname">OrderPlacementService</tt>, which themselves are
        unrelated to each other but both define a method
        <tt class="methodname">placeOrder()</tt> with an identical signature.
        This hierarchy is illegal with respect to the parameter constraints as
        a client of <tt class="classname">SimpleOrderService</tt> would have to
        fulfill the constraints defined on the interface
        <tt class="classname">OrderPlacementService</tt> even if the client only
        expects <tt class="classname">OrderService</tt>.</p><div class="example"><a name="d0e3243"></a><p class="title"><b>Example&nbsp;4.19.&nbsp;Correctly declared return value constraints on sub
            class</b></p><pre class="programlisting">public class OrderService {

    Order placeOrder(String customerCode, Item item, int quantity) {
        [...]
    }
}

public class SimpleOrderService extends OrderService {

    @Override
    @NotNull
    @Valid
    public Order placeOrder(String customerCode, Item item, int quantity) {
        [...]
    }
}</pre></div><p>The return value constraints in
        <tt class="classname">DefaultOrderService</tt> are legal, as they
        strengthen the postconditions of the
        <tt class="methodname">placeOrder()</tt> method as constituted by the
        super class <tt class="classname">OrderService</tt> but don't weaken
        them.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintdeclarationvalidationprocess-validationroutine"></a>4.6.&nbsp;Validation routine</h2></div></div><div></div></div><p class="tck-testable">For a given group, the validation routine
    applied on a given bean instance is expected to execute the following
    constraint validations in no particular order:</p><div class="itemizedlist"><ul type="disc"><li><p>for all <span class="emphasis"><em>reachable</em></span> fields, execute all
          field level validations (including the ones expressed on
          superclasses) matching the targeted group unless the given
          validation constraint has already been processed during this
          validation routine for a given navigation path (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
          as part of a previous group match.</p></li><li><p>for all <span class="emphasis"><em>reachable</em></span> getters, execute all
          getter level validations (including the ones expressed on interfaces
          and superclasses) matching the targeted group unless the given
          validation constraint has already been processed during this
          validation routine for a given navigation path (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
          as part of a previous group match.</p></li><li><p>execute all class level validations (including the ones
          expressed on interfaces and superclasses) matching the targeted
          group unless the given validation constraint has already been
          processed during this validation routine for a given navigation path
          (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
          as part of a previous group match.</p></li><li><p>for all <span class="emphasis"><em>reachable</em></span> and
          <span class="emphasis"><em>cascadable</em></span> associations, execute all cascading
          validations (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
          including the ones expressed on interfaces and superclasses (see
          <a href="#constraintdeclarationvalidationprocess-groupsequence-formaldefinition" title="4.4.6.&nbsp;Formal group definitions">Section&nbsp;4.4.6, &#8220;Formal group definitions&#8221;</a>).
          Note that group conversion can apply (see <a href="#constraintdeclarationvalidationprocess-groupsequence-groupconversion" title="4.4.5.&nbsp;Group conversion">Section&nbsp;4.4.5, &#8220;Group conversion&#8221;</a>).</p></li></ul></div><p>Reachable fields, getters and associations as well as cascadable
    associations are defined in <a href="#constraintdeclarationvalidationprocess-validationroutine-traversable" title="4.6.3.&nbsp;Traversable property">Section&nbsp;4.6.3, &#8220;Traversable property&#8221;</a>.</p><p>Note that this implies that a given validation constraint will not
    be processed more than once per validation per path. Some implementations
    might even process a single constraint only once across paths provided
    that they return the expected set of
    <tt class="classname">ConstraintViolation</tt>.</p><p><span class="tck-not-testable">Unless ordered by group sequences,
    groups can be validated in no particular order.</span> This implies that
    the validation routine can be run for several groups in the same
    pass.</p><p class="tck-testable">The object validation routine is described as
    such. For each constraint declaration:</p><div class="itemizedlist"><ul type="disc"><li><p>determine for the constraint declaration, the appropriate
          <tt class="classname">ConstraintValidator</tt> to use (see <a href="#typevalidatorresolution" title="4.6.4.&nbsp;ConstraintValidator resolution algorithm">Section&nbsp;4.6.4, &#8220;ConstraintValidator resolution algorithm&#8221;</a>).</p></li><li><p>execute the <tt class="methodname">isValid</tt> operation (from
          the constraint validation implementation) on the appropriate data
          (see <a href="#constraintsdefinitionimplementation-validationimplementation" title="3.4.&nbsp;Constraint validation implementation">Section&nbsp;3.4, &#8220;Constraint validation implementation&#8221;</a>)</p></li><li><p>if <tt class="methodname">isValid()</tt> returns
          <tt class="literal">true</tt>, continue to the next constraint,</p></li><li><p>if <tt class="methodname">isValid()</tt> returns
          <tt class="literal">false</tt>, the Bean Validation provider populates
          <tt class="classname">ConstraintViolation</tt> object(s) according to
          the rules defined in <a href="#constraintsdefinitionimplementation-validationimplementation" title="3.4.&nbsp;Constraint validation implementation">Section&nbsp;3.4, &#8220;Constraint validation implementation&#8221;</a>
          and appends these objects to the list of constraint
          violations.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-validationroutine-graphvalidation"></a>4.6.1.&nbsp;Object graph validation</h3></div></div><div></div></div><p><span class="tck-testable">The <tt class="classname">@Valid</tt>
      annotation on a given association (i.e. object reference or collection,
      array, <tt class="classname">Iterable</tt> of objects), dictates the Bean
      Validator implementation to apply recursively the Bean Validation
      routine on (each of) the associated object(s).</span> <span class="tck-testable">This mechanism is recursive: an associated object
      can itself contain cascaded references.</span></p><p class="tck-testable">Null references are ignored.</p><p><span class="tck-testable">To prevent infinite loops, the Bean
      Validation implementation must ignore the cascading operation if the
      associated object instance has already been validated in the current
      navigation path (starting from the root object).</span> See <a href="#example-oglimit" title="Example&nbsp;4.20.&nbsp;Object graph limits">Example&nbsp;4.20, &#8220;Object graph limits&#8221;</a> for an example. A navigation path is defined
      as a set of <tt class="classname">@Valid</tt> associations starting from the
      root object instance and reaching the associated instance. A given
      navigation path cannot contain the same instance multiple times (the
      complete validated object graph can though). See <a href="#example-oglimit" title="Example&nbsp;4.20.&nbsp;Object graph limits">Example&nbsp;4.20, &#8220;Object graph limits&#8221;</a> for an example.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This object graph navigation can lead to multiple validations of
        the same constraint and the same object instance but the set of
        constraint validation is deterministic and the algorithm prevents
        infinite loops.</p></div><div class="example"><a name="example-oglimit"></a><p class="title"><b>Example&nbsp;4.20.&nbsp;Object graph limits</b></p><pre class="programlisting">#assuming the following object graph

Order -(lines)-&gt; Orderline1
Order -(lines)-&gt; Orderline2
Orderline1 -(order)-&gt; Order
Orderline2 -(order)-&gt; Order
Order -(customer)-&gt; User
Order -(shippingAddress)-&gt; Address1
Order -(billingAddress)-&gt; Address2
Address1 -(inhabitant)-&gt; User
Address2 -(inhabitant)-&gt; User
User -(addresses)-&gt; Address1
User -(addresses)-&gt; Address2

#validation branches are as followed
Order -(lines)-&gt; Orderline1
  - order is ignored: Order is already present in the branch 

Order -(lines)-&gt; Orderline2
  - order is ignored: Order is already present in the branch

Order -(customer)-&gt; User -(addresses)-&gt; Address1
  - inhabitant is ignored: User is already present in the branch

Order -(customer)-&gt; User -(addresses)-&gt; Address2
  - inhabitant is ignored: User is already present in the branch

Order -(shippingAddress)-&gt; Address1 -(inhabitant)-&gt; User 
  - addresses to Address1 is ignored: Address1 is already present in the branch

Order -(shippingAddress)-&gt; Address1 -(inhabitant)-&gt; User -(addresses)-&gt; Address2
  - inhabitant is ignored: User is already present in the branch

Order -(billingAddress)-&gt; Address2 -(inhabitant)-&gt; User 
  - addresses to Address2 is ignored: Address2 is already present in the branch

Order -(billingAddress)-&gt; Address2 -(inhabitant)-&gt; User -(addresses)-&gt; Address1
  - inhabitant is ignored: User is already present in the branch</pre></div><p>The <tt class="classname">ConstraintViolation</tt> objects are built
      when a failing constraint on an associated object is found. They reflect
      the path to reach the object from the root validated object (See <a href="#validationapi-constraintviolation" title="5.2.&nbsp;ConstraintViolation">Section&nbsp;5.2, &#8220;ConstraintViolation&#8221;</a>).</p><p><span class="tck-testable"><tt class="classname">@Valid</tt> is an
      orthogonal concept to the notion of group. If two groups are in
      sequence, the first group must pass for all associated objects before
      the second group is evaluated.</span> Note however that the
      <tt class="classname">Default</tt> group sequence overriding is local to the
      class it is defined on and is not propagated to the associated objects.
      The following example illustrates this:</p><div class="example"><a name="d0e3408"></a><p class="title"><b>Example&nbsp;4.21.&nbsp;Class Driver with redefined default group</b></p><pre class="programlisting">@GroupSequence({ Minimal.class, Driver.class })
public class Driver {
  @Min(value = 18, groups = Minimal.class)
  int age;

  @AssertTrue
  Boolean passedDrivingTest;

  @Valid
  Car car;

  // setter/getters
}</pre></div><div class="example"><a name="d0e3413"></a><p class="title"><b>Example&nbsp;4.22.&nbsp;Class Car with redefined default group</b></p><pre class="programlisting">@GroupSequence({ Car.class, Later.class })
public class Car {
  @NotNull
  String type;

  @AssertTruegroups = Later.class)
  Boolean roadWorthy;

  // setter/getters
}</pre></div><div class="example"><a name="d0e3418"></a><p class="title"><b>Example&nbsp;4.23.&nbsp;Defining a group sequence</b></p><pre class="programlisting">@GroupSequence({ Minimal.class, Later.class })
public interface SequencedGroups {
}</pre></div><div class="example"><a name="d0e3423"></a><p class="title"><b>Example&nbsp;4.24.&nbsp;Group sequence overriding is not propagated to associated
          objects</b></p><pre class="programlisting">Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Driver driver = new Driver();
driver.setAge(16);
Car porsche = new Car();
driver.setCar(porsche);


Set&lt;ConstraintViolation&lt;Driver&gt;&gt; violations = validator.validate( driver );

assert violations.size() == 2;

violations = validator.validate( driver, SequencedGroups.class );

assert violations.size() == 1;</pre></div><p>The default group sequence is redefined for the
      <tt class="classname">Driver</tt> as well as <tt class="classname">Car</tt>.
      When the default group is requested via <tt class="methodname">validator.validate(
      driver )</tt> the group <tt class="classname">Minimal</tt> gets
      validated in class <tt class="classname">Driver</tt>. The constraint will
      fail since the driver's age in the example is only 16. The constraint on
      <span class="property">passedDrivingTest</span> will not be evaluated due to the
      redefined default sequence of <tt class="classname">Driver</tt>. However,
      there is one more constraint violation, namely the
      <tt class="classname">@NotNull</tt> on <span class="property">Car.type</span>. The
      reason for this is that the group <tt class="classname">Default</tt> gets
      propagated to <tt class="classname">Car</tt> (not
      <tt class="classname">Minimal</tt>). Class <tt class="classname">Driver</tt>
      defines its own group sequence which means that <tt class="classname">only
      @NotNull</tt> on <span class="property">type</span> gets evaluated.</p><p>In the second call to <tt class="methodname">validate</tt> the group
      <tt class="classname">SequencedGroups</tt> is requested which defines a
      sequence of <tt class="classname">Minimal</tt> followed by
      <tt class="classname">Later</tt>. In this case there is only one constraint
      violation. Again <tt class="classname">@Min</tt> on <span class="property">age</span>
      fails, but in this case the group <tt class="classname">Minimal</tt> gets
      propagated to <tt class="classname">Car</tt> which does not have any
      constraints defined against this group. Constraints belonging to the
      group <tt class="classname">Later</tt> won't get validated until all
      constraints belonging to <tt class="classname">Minimal</tt> pass.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3506"></a>4.6.2.&nbsp;Method and constructor validation</h3></div></div><div></div></div><p class="tck-testable">For a given group, the validation routine
      applied to validate parameters of a method or constructor is expected to
      execute the following constraint validations <span class="tck-not-testable">in no particular order</span>:</p><div class="itemizedlist"><ul type="disc"><li><p>execute all parameter validations (in case of overriding
            method validation, including the ones expressed on overridden
            methods of the interfaces and superclasses) matching the targeted
            group unless the given validation constraint has already been
            processed during this validation routine for a given navigation
            path (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
            as part of a previous group match.</p></li><li><p>execute all cross parameter validations (in case of
            overriding method validation, including the ones expressed on
            overridden methods of the interfaces and superclasses) matching
            the targeted group unless the given validation constraint has
            already been processed during this validation routine for a given
            navigation path (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
            as part of a previous group match.</p></li><li><p>for all parameters marked for cascaded validation, execute
            all cascading validations (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>),
            in case of overriding method validation including the ones
            expressed on overridden methods of the interfaces and superclasses
            (see <a href="#constraintdeclarationvalidationprocess-groupsequence-formaldefinition" title="4.4.6.&nbsp;Formal group definitions">Section&nbsp;4.4.6, &#8220;Formal group definitions&#8221;</a>).
            Note that group conversion can apply (see <a href="#constraintdeclarationvalidationprocess-groupsequence-groupconversion" title="4.4.5.&nbsp;Group conversion">Section&nbsp;4.4.5, &#8220;Group conversion&#8221;</a>).</p></li></ul></div><p class="tck-testable">For a given group, the validation routine
      applied to validate the return value of a method or constructor is
      expected to execute the following constraint validations in no
      particular order:</p><div class="itemizedlist"><ul type="disc"><li><p>execute all return value validations (including the ones
            expressed on interfaces and superclasses) matching the targeted
            group unless the given validation constraint has already been
            processed during this validation routine for a given navigation
            path (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
            as part of a previous group match.</p></li><li><p>if the return value is marked for cascaded validation,
            execute all cascading validations (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
            including the ones expressed on interfaces and superclasses (see
            <a href="#constraintdeclarationvalidationprocess-groupsequence-formaldefinition" title="4.4.6.&nbsp;Formal group definitions">Section&nbsp;4.4.6, &#8220;Formal group definitions&#8221;</a>).
            Note that group conversion can apply (see <a href="#constraintdeclarationvalidationprocess-groupsequence-groupconversion" title="4.4.5.&nbsp;Group conversion">Section&nbsp;4.4.5, &#8220;Group conversion&#8221;</a>).</p></li></ul></div><p>Note that this implies that a given validation constraint will not
      be processed more than once per validation per path. Some
      implementations might even process a single constraint only once across
      paths provided that they return the expected set of
      <tt class="classname">ConstraintViolation</tt>.</p><p><span class="tck-not-testable"><span class="tck-testable">Unless
      ordered by group sequences, groups can be validated in no particular
      order.</span></span> This implies that the validation routine can be
      run for several groups in the same pass.</p><p>The object validation routine is as defined in described in <a href="#constraintdeclarationvalidationprocess-validationroutine" title="4.6.&nbsp;Validation routine">Section&nbsp;4.6, &#8220;Validation routine&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-validationroutine-traversable"></a>4.6.3.&nbsp;Traversable property</h3></div></div><div></div></div><p>In some cases, the state of some properties should not be
      accessed. For example, if a property loaded by a Java Persistence
      provider is a lazy property or a lazy association, accessing its state
      would trigger a load from the database. An undesired behavior.</p><p>Bean Validation offers a way to control which property can and
      cannot be accessed via the
      <tt class="classname">TraversableResolver.isReachable</tt>()
      contract.</p><p>Likewise, it is sometimes undesirable to cascade validation
      despite the use of <tt class="classname">@Valid</tt>. Java Persistence 2 for
      example does not cascade to associated entities during flush. You can
      control this behavior by implementing
      <tt class="methodname">Traversable.isCascadable()</tt>.</p><pre class="programlisting">/**
 * Contract determining if a property can be accessed by the Bean Validation provider.
 * This contract is called for each property that is being either validated or cascaded.
 * &lt;p/&gt;
 * A traversable resolver implementation must be thread-safe.
 *
 * @author Emmanuel Bernard
 */
public interface TraversableResolver {
    /**
     * Determines if the Bean Validation provider is allowed to reach the property state.
     *
     * @param traversableObject object hosting {@code traversableProperty}
     *        or {@code null} if {@code validateValue} is called
     * @param traversableProperty the traversable property
     * @param rootBeanType type of the root object passed to the Validator
     *        or hosting the method or constructor validated
     * @param pathToTraversableObject path from the root object to
     *        {@code traversableObject}
     *        (using the path specification defined by Bean Validator)
     * @param elementType either {@code FIELD} or {@code METHOD}
     * @return {@code true} if the Bean Validation provider is allowed to
     *         reach the property state, {@code false} otherwise
     */
    boolean isReachable(Object traversableObject,
                        Node traversableProperty,
                        Class&lt;?&gt; rootBeanType,
                        Path pathToTraversableObject,
                        ElementType elementType);

    /**
     * Determines if the Bean Validation provider is allowed to cascade validation on
     * the bean instance returned by the property value
     * marked as {@code @Valid}.
     * &lt;p/&gt;
     * Note that this method is called only if
     * {@link #isReachable(Object, javax.validation.Path.Node, Class, Path, java.lang.annotation.ElementType)}
     * returns {@code true} for the same set of arguments and if the property
     * is marked as {@link Valid}.
     *
     * @param traversableObject object hosting {@code traversableProperty}
     *        or {@code null} if {@code validateValue} is called
     * @param traversableProperty the traversable property
     * @param rootBeanType type of the root object passed to the Validator
     *        or hosting the method or constructor validated
     * @param pathToTraversableObject path from the root object to
     *        {@code traversableObject}
     *        (using the path specification defined by Bean Validator)
     * @param elementType either {@code FIELD} or {@code METHOD}
     * @return {@code true} if the Bean Validation provider is allowed to
     *         cascade validation, {@code false} otherwise
     */
    boolean isCascadable(Object traversableObject,
                         Node traversableProperty,
                         Class&lt;?&gt; rootBeanType,
                         Path pathToTraversableObject,
                         ElementType elementType);
}</pre><p><span class="tck-testable"><tt class="methodname">isReachable()</tt>
      is called for every property about to be accessed either for validation
      or for cascading.</span> A property is <span class="emphasis"><em>reachable</em></span>
      if this method returns <tt class="literal">true</tt>.</p><p><span class="tck-testable"><tt class="methodname">isCascadable()</tt> is called
      for every property about to be cascaded (i.e. marked as
      <tt class="classname">@Valid</tt>).</span> A property is
      <span class="emphasis"><em>cascadable</em></span> if it is reachable and if the
      <tt class="methodname">isCascadable</tt> method returns
      <tt class="literal">true</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p class="tck-testable"><tt class="methodname">isCascadable()</tt> for
        a given property is only called if
        <tt class="methodname">isReachable()</tt> returns
        <tt class="literal">true</tt>. In other words,
        <tt class="methodname">isReachable()</tt> is always called before
        <tt class="methodname">isCascadable()</tt> for a given property.</p></div><p class="tck-testable"><tt class="literal">traversableObject</tt> is the
      object instance being evaluated. <tt class="literal">null</tt> if the check is
      triggered as part of a <tt class="methodname">validateValue()</tt>
      call.</p><p class="tck-testable"><tt class="literal">traversableProperty</tt> is the
      <tt class="classname">Node</tt> representing the property hosted by the
      <tt class="methodname">traversableObject</tt> being considered for
      traversal. The name of a property is defined in <a href="#constraintdeclarationvalidationprocess-requirements-property" title="4.1.2.&nbsp;Field and property validation">Section&nbsp;4.1.2, &#8220;Field and property validation&#8221;</a>.</p><p class="tck-testable"><tt class="literal">rootBeanType</tt> is the class
      of the root being validated, i.e. either the type of the object passed
      to the <tt class="methodname">validate</tt> method or the type declaring
      the validated method/constructor in case of method validation).</p><p class="tck-testable"><tt class="literal">pathToTraversableObject</tt> is
      the <tt class="classname">Path</tt> from the
      <tt class="methodname">rootBeanType</tt> down to the
      <tt class="methodname">traversableObject</tt>. If the root object is
      <tt class="classname">traversableObject</tt>,
      <tt class="classname">pathToTraversableObject</tt> is composed of a single
      Node whose name is <tt class="literal">null</tt>. The path is described
      following the conventions described in <a href="#validationapi-constraintviolation" title="5.2.&nbsp;ConstraintViolation">Section&nbsp;5.2, &#8220;ConstraintViolation&#8221;</a>
      (<tt class="methodname">getPropertyPath</tt>).</p><p class="tck-testable"><tt class="literal">elementType</tt> is the
      <tt class="classname">java.lang.annotation.ElementType</tt> the annotation
      is placed on. It can be either <tt class="literal">FIELD</tt> or
      <tt class="literal">METHOD</tt>. Any other value is not expected.</p><p class="tck-testable">The Bean Validation provider must not access
      the state of a property, nor validate its constraints if the property is
      not traversable. A property is traversable if
      <tt class="classname">TraversableResolver</tt> returns
      <tt class="literal">true</tt> for this property.</p><p class="tck-testable">If an exception occurs when the
      <tt class="classname">TraversableResolver</tt> is called, the exception is
      wrapped into a <tt class="classname">ValidationException</tt>.</p><p class="tck-testable">The following elements are not passed through
      the traversable resolver filter:</p><div class="itemizedlist"><ul type="disc"><li><p>the bean instance validated</p></li><li><p>the method and constructor parameter values being
            validated</p></li><li><p>the method and constructor return value being
            validated</p></li></ul></div><p class="tck-testable">But the properties of these elements (if
      validated) are. In this case the complete path is provided via
      <tt class="literal">pathToTraversableObject</tt>.</p><p>The traversable resolver used by default by a Bean Validation
      provider behaves as followed:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="tck-not-testable">if Java Persistence is
          available in the runtime environment, a property is considered
          reachable if Java Persistence considers the property as
          loaded.</span> A typical implementation will use
          <tt class="code">Persistence.getPersistenceUtil().isLoaded(Object,
          String)</tt> to implement such contract.</p></li><li><p class="tck-not-testable">if Java Persistence is not available
          in the runtime environment, all properties are considered
          reachable.</p></li><li><p class="tck-not-testable">all properties are considered
          cascadable.</p></li></ul></div><p>An example implementation of such a resolver is shown in <a href="#constraintdeclarationvalidationprocess-validationroutine-traversable-jparesolver" title="Example&nbsp;4.25.&nbsp;Java Persistence aware TraversableResolver">Example&nbsp;4.25, &#8220;Java Persistence aware TraversableResolver&#8221;</a>.</p><div class="example"><a name="constraintdeclarationvalidationprocess-validationroutine-traversable-jparesolver"></a><p class="title"><b>Example&nbsp;4.25.&nbsp;Java Persistence aware TraversableResolver</b></p><pre class="programlisting">public class JPATraversableResolver implements TraversableResolver {

    public boolean isReachable(Object traversableObject,
                               Path.Node traversableProperty,
                               Class&lt;?&gt; rootBeanType,
                               Path pathToTraversableObject,
                               ElementType elementType) {
        return traversableObject == null ||
                Persistence.getPersistenceUtil().isLoaded(
                        traversableObject,
                        traversableProperty.getName() );
    }

    public boolean isCascadable(Object traversableObject,
                               Path.Node traversableProperty,
                               Class&lt;?&gt; rootBeanType,
                               Path pathToTraversableObject,
                               ElementType elementType) {
        return true;
    }
}</pre></div><p>See <a href="#bootstrapping" title="5.5.&nbsp;Bootstrapping">Section&nbsp;5.5, &#8220;Bootstrapping&#8221;</a> to how to pass a custom
      <tt class="classname">TraversableResolver</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="constraintdeclarationvalidationprocess-validationroutine-traversable-examples"></a>4.6.3.1.&nbsp;Examples</h4></div></div><div></div></div><p>The following example assumes the object graph defined in <a href="#example-ognav-definitions" title="Example&nbsp;4.26.&nbsp;Definitions used in the example">Example&nbsp;4.26, &#8220;Definitions used in the example&#8221;</a> and assumes the validation
        operation is applied on an address object.</p><div class="example"><a name="example-ognav-definitions"></a><p class="title"><b>Example&nbsp;4.26.&nbsp;Definitions used in the example</b></p><pre class="programlisting">public class Country {
    @NotNull private String name;
    @Size(max=2) private String ISO2Code;
    @Size(max=3) private String ISO3Code;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getISO2Code() {
        return ISO2Code;
    }

    public void setISO2Code(String ISO2Code) {
        this.ISO2Code = ISO2Code;
    }

    public String getISO3Code() {
        return ISO3Code;
    }

    public void setISO3Code(String ISO3Code) {
        this.ISO3Code = ISO3Code;
    }
}

public class Address {
    @NotNull @Size(max=30)
    private String addressline1;
    @Size(max=30)
    private String addressline2;
    @Size(max=11)
    private String zipCode;
    @Valid
    private Country country;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public Country getCountry() {
        return country;
    }

    public void setCountry(Country country) {
        this.country = country;
    }
}</pre></div><p>When the Bean Validation provider is about to check constraints
        of <tt class="literal">ISO3Code</tt>, it calls the
        <tt class="classname">TraversableResolver.isReachable()</tt> method to
        ensure that the <tt class="literal">ISO3Code</tt> property is reachable with
        the following parameter values:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">traversableObject</tt>: country. The instance
            returned by <tt class="code">address.getCountry()</tt>.</p></li><li><p><tt class="literal">traversableProperty</tt>: a
            <tt class="classname">PropertyNode</tt> whose name is "ISO3Code".
            Represents the property of <tt class="literal">traversableObject</tt>
            being verified.</p></li><li><p><tt class="methodname">rootBeanType</tt>:
            <tt class="classname">Address.class</tt>. The type of the root object
            being validated.</p></li><li><p><tt class="literal">pathtoTraversableObject</tt>: a
            <tt class="classname">Path</tt> containing a single
            <tt class="classname">PropertyNode</tt> whose name is "country". The
            path from address to the country instance.</p></li><li><p><tt class="literal">elementType</tt>:
            <tt class="classname">ElementType.FIELD</tt>. The ISO3Code property is
            annotated on its field.</p></li></ul></div><p>When the Bean Validation provider is about to cascade validation
        on <tt class="literal">country</tt> (<tt class="classname">Address</tt> object),
        it calls the <tt class="classname">TraversableResolver.isReachable()</tt>
        method to ensure that the <tt class="literal">country</tt> property is
        reachable and if this method returns <tt class="literal">true</tt>, it calls
        <tt class="classname">TraversableResolver.isCascadable()</tt> with the
        following parameter values:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">traversableObject</tt>: address. The address
            instance.</p></li><li><p><tt class="literal">traversableProperty</tt>: a
            <tt class="classname">PropertyNode</tt> whose name is "country".
            Represents the property of <tt class="literal">traversableObject</tt>
            being verified.</p></li><li><p><tt class="methodname">rootBeanType</tt>:
            <tt class="classname">Address.class</tt>. The type of the root object
            being validated.</p></li><li><p><tt class="literal">pathtoTraversableObject</tt>: a
            <tt class="classname">Path</tt> containing a single
            <tt class="classname">BeanNode</tt> whose name is
            <tt class="literal">null</tt>.</p></li><li><p><tt class="literal">elementType</tt>:
            <tt class="classname">ElementType.FIELD</tt>. The country property is
            annotated on its field.</p></li></ul></div><p>The following example shows invocations of the
        <tt class="classname">TraversableResolver</tt> as to be performed by the
        Bean Validation provider during method validation. The example is
        based on the object graph defined in <a href="#example-ognav-definitions" title="Example&nbsp;4.26.&nbsp;Definitions used in the example">Example&nbsp;4.26, &#8220;Definitions used in the example&#8221;</a> and the
        <tt class="classname">AddressService</tt> class shown in <a href="#example-ognav-definitions-methodvalidation" title="Example&nbsp;4.27.&nbsp;Examplary class AddressService">Example&nbsp;4.27, &#8220;Examplary class AddressService&#8221;</a>. It assumes
        that a call of <tt class="methodname">persistAddress()</tt> is subject to
        method parameter validation.</p><div class="example"><a name="example-ognav-definitions-methodvalidation"></a><p class="title"><b>Example&nbsp;4.27.&nbsp;Examplary class <tt class="classname">AddressService</tt></b></p><pre class="programlisting">public class AddressService {
    public void persistAddress(@NotNull @Valid Address address) {
        [...]
    }
}</pre></div><p>When the Bean Validation provider is about to validate the
        <tt class="classname">@NotNull</tt> constraint on the
        <tt class="varname">address</tt> parameter, no call to
        <tt class="methodname">isReachable()</tt> is expected, since parameters
        are assumed to always be reachable. Similarly, no call to
        <tt class="methodname">isCascable()</tt> is expected when performing
        cascaded validation of the <tt class="varname">address</tt> parameter, since
        parameters are assumed to always be cascadable.</p><p>When the Bean Validation provider is about to validate
        constraints on the field <tt class="varname">addressline1</tt> of the passed
        <tt class="classname">Address</tt> object, it calls the
        <tt class="methodname">isReachable()</tt> method to ensure that the
        property is reachable with the following parameter values:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">traversableObject</tt>: address. The instance
            passed to <tt class="methodname">persistAddress()</tt>.</p></li><li><p><tt class="literal">traversableProperty</tt>: a
            <tt class="classname">PropertyNode</tt> whose name is "addressline1".
            Represents the property of <tt class="literal">traversableObject</tt>
            being verified.</p></li><li><p><tt class="methodname">rootBeanType</tt>:
            <tt class="classname">AddressService.class</tt>. The type of the root
            object being validated.</p></li><li><p><tt class="literal">pathtoTraversableObject</tt>: a
            <tt class="classname">Path</tt> comprising a
            <tt class="classname">MethodNode</tt> (named "persistService") and a
            <tt class="classname">ParameterNode</tt> (with parameter index 0). The
            path from <tt class="classname">AddressService</tt> to the
            <tt class="classname">Address</tt> instance.</p></li><li><p><tt class="literal">elementType</tt>:
            <tt class="classname">ElementType.FIELD</tt>. The
            <tt class="varname">addressline1</tt> property is annotated on its
            field.</p></li></ul></div><p>When the Bean Validation provider is about to perform a cascaded
        validation of the <tt class="varname">country</tt> property of the passed
        <tt class="classname">Address</tt> object, it calls the
        <tt class="methodname">isReachable()</tt> method to ensure that the
        property is reachable. If this method returns
        <tt class="literal"><tt class="literal">true</tt></tt>, it calls
        <tt class="classname">TraversableResolver.isCascadable()</tt> with the
        following parameter values:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">traversableObject</tt>: address. The instance
            passed to <tt class="methodname">persistAddress()</tt>.</p></li><li><p><tt class="literal">traversableProperty</tt>: a
            <tt class="classname">PropertyNode</tt> whose name is "country".
            Represents the property of <tt class="literal">traversableObject</tt>
            being verified.</p></li><li><p><tt class="methodname">rootBeanType</tt>:
            <tt class="classname">AddressService.class</tt>. The type of the root
            object being validated.</p></li><li><p><tt class="literal">pathtoTraversableObject</tt>: a
            <tt class="classname">Path</tt> comprising a
            <tt class="classname">MethodNode</tt> (named "persistService") and a
            <tt class="classname">ParameterNode</tt> (with parameter index 0). The
            path from <tt class="classname">AddressService</tt> to the
            <tt class="classname">Address</tt> instance.</p></li><li><p><tt class="literal">elementType</tt>:
            <tt class="classname">ElementType.FIELD</tt>. The
            <tt class="varname">country</tt> property is annotated on its
            field.</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typevalidatorresolution"></a>4.6.4.&nbsp;ConstraintValidator resolution algorithm</h3></div></div><div></div></div><p>A constraint is associated to one or more
      <tt class="classname">ConstraintValidator</tt> implementations. Each
      <tt class="classname">ConstraintValidator&lt;A, T&gt;</tt> accepts the type
      <tt class="classname">T</tt>. The <tt class="classname">ConstraintValidator</tt>
      executed depends on the type hosting the constraint. For a given
      constraint evaluation, a single
      <tt class="classname">ConstraintValidator</tt> is considered.</p><p class="tck-testable">The list of
      <tt class="classname">ConstraintValidator</tt>s can contain at most one
      which targets cross-parameter. If the constraint targets the parameters
      of an executable either implicitly or by the use of
      <tt class="methodname">validationAppliesTo</tt> in the constraint - see
      <a href="#constraintsdefinitionimplementation-constraintdefinition-validationappliesto" title="3.1.1.4.&nbsp;validationAppliesTo">Section&nbsp;3.1.1.4, &#8220;validationAppliesTo&#8221;</a>,
      then the cross-parameter <tt class="classname">ConstraintValidator</tt> is
      used. If none is present, a
      <tt class="classname">ConstraintDefinitionException</tt> is raised. If more
      than one cross-parameter <tt class="classname">ConstraintValidator</tt> is
      present, a <tt class="classname">ConstraintDefinitionException</tt> is
      raised.</p><p><span class="tck-testable">If the constraint is a generic
      constraint, the following rules apply. If the constraint declaration is
      hosted on a class or an interface, the targeted type is the class or the
      interface.</span> <span class="tck-testable">If the constraint is
      hosted on a class attribute, the type of the attribute is the targeted
      type.</span> <span class="tck-testable">If the constraint is hosted
      on a getter, the return type of the getter is the targeted
      type.</span> In other words, the resolution algorithm considers the
      type as defined in the method signature and not the runtime type of the
      value.</p><p>The rules written below describe formally the following statement:
      <span class="tck-testable">the
      <tt class="classname">ConstraintValidator</tt> chosen to validate the
      generic constraint on a declared type <tt class="classname">T</tt> is the
      one where the <tt class="classname">ConstraintValidator</tt> targets the
      annotated element, where the type supported by the
      <tt class="classname">ConstraintValidator</tt> is a supertype of
      <tt class="classname">T</tt> and where there is no other
      <tt class="classname">ConstraintValidator</tt> whose supported type is a
      supertype of <tt class="classname">T</tt> and not a supertype of the chosen
      <tt class="classname">ConstraintValidator</tt> supported
      type.</span></p><p>When validating a generic constraint A placed on a target
      declaring the type <tt class="classname">T</tt>, the following resolution
      rules apply:</p><div class="itemizedlist"><ul type="disc"><li><p>Only <tt class="classname">ConstraintValidator</tt>
          implementations targeting annotated elements are considered.</p></li><li><p>Primitive types are considered equivalent to their respective
          primitive wrapper class.</p></li><li><p>A <tt class="classname">ConstraintValidator&lt;A, U&gt;</tt> is
          said to be <span class="emphasis"><em>compliant</em></span> with
          <tt class="classname">T</tt> if <tt class="classname">T</tt> is a subtype of
          <tt class="classname">U</tt> (according to the<a href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.10" target="_top">
          Java Language Specification 3rd edition chapter 4.10
          Subtyping</a>). Note that <tt class="classname">T</tt> is a subtype
          of <tt class="classname">U</tt> if <tt class="classname">T</tt> =
          <tt class="classname">U</tt>.</p></li><li><p class="tck-testable">If no
          <tt class="classname">ConstraintValidator</tt> compliant with
          <tt class="classname">T</tt> is found amongst the
          <tt class="classname">ConstraintValidator</tt>s listed by the constraint
          <tt class="classname">A</tt>, an
          <tt class="classname">UnexpectedTypeException</tt> is raised.</p></li><li><p>A <tt class="classname">ConstraintValidator&lt;A, U&gt;</tt>
          compliant with <tt class="classname">T</tt> is considered
          <span class="emphasis"><em>strictly more specific</em></span> than a
          <tt class="classname">ConstraintValidator&lt;A, V&gt;</tt> compliant
          with <tt class="classname">T</tt> if <tt class="classname">U</tt> is a
          strict subtype of <tt class="classname">V</tt>. <tt class="classname">U</tt>
          is a strict subtype of <tt class="classname">V</tt> if
          <tt class="classname">U</tt> is a subtype of <tt class="classname">V</tt>
          and <tt class="classname">U</tt> != <tt class="classname">V</tt> (according
          to the <a href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.10" target="_top">Java
          Language Specification 3rd edition chapter 4.10
          Subtyping</a>).</p></li><li><p>A <tt class="classname">ConstraintValidator&lt;A, U&gt;</tt>
          compliant with <tt class="classname">T</tt> is considered maximally
          specific if no other <tt class="classname">ConstraintValidator&lt;A,
          V&gt;</tt> compliant with <tt class="classname">T</tt> is
          strictly more specific than <tt class="classname">ConstraintValidator&lt;A,
          U&gt;</tt>.</p></li><li><p class="tck-testable">If more than one maximally specific
          <tt class="classname">ConstraintValidator</tt> is found, an
          <tt class="classname">UnexpectedTypeException</tt> is raised.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>While the Java compiler itself cannot determine if a constraint
        declaration will lead to a
        <tt class="classname">UnexpectedTypeException</tt>, rules can be
        statically checked. A tool such as an IDE or a Java 6 annotation
        processor can apply these rules and prevent compilation in case of
        ambiguity. The specification encourages Bean Validation providers to
        provide such a tool to their users.</p></div><p>Let's see a couple of declarations and their respective
      <tt class="classname">ConstraintValidator</tt> resolution. Assuming the
      definitions shown in <a href="#example-constraintvalidator-resolution" title="Example&nbsp;4.28.&nbsp;ConstraintValidator and type resolution">Example&nbsp;4.28, &#8220;ConstraintValidator and type resolution&#8221;</a>:</p><div class="example"><a name="example-constraintvalidator-resolution"></a><p class="title"><b>Example&nbsp;4.28.&nbsp;ConstraintValidator and type resolution</b></p><pre class="programlisting">[...]
@Constraint(validatedBy={
    SizeValidatorForCollection.class,
    SizeValidatorForSet.class,
    SizeValidatorForSerializable.class })
public @interface Size { [...] }

public class SizeValidatorForCollection implements ConstraintValidator&lt;Size, Collection&gt; {
    [...]
}
public class SizeValidatorForSet implements ConstraintValidator&lt;Size, Set&gt; {
    [...]
}
public class SizeValidatorForSerializable implements ConstraintValidator&lt;Size, Serializable&gt; {
    [...]
}

public interface SerializableCollection extends Serializable, Collection {
}</pre></div><p>The resolutions shown in <a href="#table-constraintvalidator-resolution" title="Table&nbsp;4.1.&nbsp;Resolution of ConstraintValidator for various constraints&#xA;        declarations">Table&nbsp;4.1, &#8220;Resolution of ConstraintValidator for various constraints
        declarations&#8221;</a> occur.</p><div class="table"><a name="table-constraintvalidator-resolution"></a><p class="title"><b>Table&nbsp;4.1.&nbsp;Resolution of ConstraintValidator for various constraints
        declarations</b></p><table summary="Resolution of ConstraintValidator for various constraints&#xA;        declarations" border="1"><colgroup><col align="center"><col></colgroup><thead><tr><th align="center">Declaration</th><th>Resolution</th></tr></thead><tbody><tr><td align="center"><tt class="code">@Size Collection getAddresses() { [...]
              }</tt></td><td><tt class="classname">SizeValidatorForCollection</tt>: direct
              match</td></tr><tr><td align="center"><tt class="code">@Size Collection&lt;?&gt; getAddresses() { [...]
              }</tt></td><td><tt class="classname">SizeValidatorForCollection</tt>:
              <tt class="classname">Collection</tt> is a direct supertype of
              <tt class="classname">Collection&lt;?&gt;</tt></td></tr><tr><td align="center"><tt class="code">@Size Collection&lt;Address&gt; getAddresses() {
              [...] }</tt></td><td><tt class="classname">SizeValidatorForCollection</tt>:
              <tt class="classname">Collection</tt> is a direct supertype of
              <tt class="classname">Collection&lt;Address&gt;</tt></td></tr><tr><td align="center"><tt class="code">@Size Set&lt;Address&gt; getAddresses() { [...]
              }</tt></td><td><tt class="classname">SizeValidatorForSet</tt>: direct
              supertype of <tt class="classname">Set&lt;Address&gt;</tt></td></tr><tr><td align="center"><tt class="code">@Size SortedSet&lt;Address&gt; getAddresses() {
              [...] }</tt></td><td><tt class="classname">SizeValidatorForSet</tt>:
              <tt class="classname">Set</tt> is the closest supertype of
              <tt class="classname">SortedSet&lt;Address&gt;</tt></td></tr><tr><td align="center"><tt class="code">@Size SerializableCollection getAddresses() { [...]
              }</tt></td><td><tt class="classname">UnexpectedTypeException</tt>:
              <tt class="classname">SerializableCollection</tt> is a subtype of
              both <tt class="classname">Collection</tt> and
              <tt class="classname">Serializable</tt> and neither
              <tt class="classname">Collection</tt> nor
              <tt class="classname">Serializable</tt> are subtypes of each
              other.</td></tr><tr><td align="center"><tt class="code">@Size String getName() { [...] }</tt></td><td><tt class="classname">UnexpectedTypeException</tt>: none of
              the <tt class="classname">ConstraintValidator</tt> types are
              supertypes of <tt class="classname">String</tt>.</td></tr></tbody></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4436"></a>4.7.&nbsp;Examples</h2></div></div><div></div></div><p>The first example demonstrates how beans, fields and getters are
    annotated to express some constraints.</p><div class="example"><a name="d0e4441"></a><p class="title"><b>Example&nbsp;4.29.&nbsp;Place constraint declarations on the element to validate</b></p><pre class="programlisting">@ZipCodeCityCoherenceChecker
public class Address {
    @NotNull @Size(max=30)
    private String addressline1;

    @Size(max=30)
    private String addressline2;

    private String zipCode;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}</pre></div><p>During the validation routine execution on an
    <tt class="classname">Address</tt> object,</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">addressline1</tt> field value is passed to
        the <tt class="classname">@NotNull</tt> as well as
        <tt class="classname">@Size</tt> constraint validation
        implementation.</p></li><li><p><tt class="methodname">addressline2</tt> field value is passed to
        the <tt class="classname">@Size</tt> constraint validation
        implementation.</p></li><li><p><tt class="methodname">getCity</tt> value is passed to the
        <tt class="classname">@Size</tt> and <tt class="classname">@NotNull</tt>
        constraint validation implementations</p></li><li><p><tt class="classname">@ZipCodeCoherenceChecker</tt> is a constraint
        whose validation implementation's <tt class="methodname">isValid</tt>
        method receives the <tt class="classname">Address</tt> object</p></li></ul></div><p>The second example demonstrates object graph validation</p><div class="example"><a name="d0e4495"></a><p class="title"><b>Example&nbsp;4.30.&nbsp;Define object graph validation</b></p><pre class="programlisting">public class Country {
    @NotNull
    private String name;
    @Size(max=2) private String ISO2Code;
    @Size(max=3) private String ISO3Code;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getISO2Code() {
        return ISO2Code;
    }

    public void setISO2Code(String ISO2Code) {
        this.ISO2Code = ISO2Code;
    }

    public String getISO3Code() {
        return ISO3Code;
    }

    public void setISO3Code(String ISO3Code) {
        this.ISO3Code = ISO3Code;
    }
}

public class Address {
    @NotNull @Size(max=30)
    private String addressline1;
    @Size(max=30)
    private String addressline2;
    @Size(max=11)
    private String zipCode;
    <span class="bold"><b>@NotNull @Valid</b></span>
    private Country country;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public Country getCountry() {
        return country;
    }

    public void setCountry(Country country) {
        this.country = country;
    }
}</pre></div><p>During the validation routine execution on an
    <tt class="classname">Address</tt> object, constraints on
    <tt class="methodname">addressLine1</tt>,
    <tt class="methodname">addressLine2</tt>, <tt class="methodname">zipCode</tt>,
    <tt class="classname">getCity</tt> and <tt class="methodname">country</tt> are
    processed as well as the validation of the <tt class="classname">Country</tt>
    object itself, more specifically <tt class="methodname">country.name</tt> is
    checked for <tt class="classname">@NotNull</tt>,
    <tt class="methodname">ISO2Code</tt> and <tt class="methodname">ISO3Code</tt>
    are checked for <tt class="classname">@Size</tt>.</p><p>Assuming that <tt class="classname">@NotEmpty</tt> is defined as
    such</p><pre class="programlisting">package com.acme.constraint;

@Documented
@NotNull
@Size(min=1)
@ReportAsSingleViolation
@Constraint(validatedBy = NotEmpty.NotEmptyValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface NotEmpty {
    String message() default "{com.acme.constraint.NotEmpty.message}"
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        NotEmpty[] value();
    }    

    class NotEmptyValidator implements ConstraintValidator&lt;NotEmpty, String&gt; {
        public void initialize(NotEmpty constraintAnnotation) {}

        public boolean isValid(String value, ConstraintValidatorContext context) {
            return true;
        }
    }
}</pre><p>The third example demonstrates superclass, inheritance and composite
    constraints.</p><div class="example"><a name="d0e4550"></a><p class="title"><b>Example&nbsp;4.31.&nbsp;Use inheritance, constraints on superclasses and composite
      constraints</b></p><pre class="programlisting">public interface Person {
    @NotEmpty
    String getFirstName();

    String getMiddleName();
    
    @NotEmpty
    String getLastName();
}

public class Customer implements Person {
    private String firstName;
    private String middleName;
    private String lastName;
    @NotNull
    private String customerId;
    @Password(robustness=5)
    private String password;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getMiddleName() {
        return middleName;
    }

    public void setMiddleName(String middleName) {
        this.middleName = middleName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCustomerId() {
        return customerId;
    }

    public void setCustomerId(String customerId) {
        this.customerId = customerId;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

public class PreferredGuest extends Customer {
    @CreditCard
    private String guestCreditCardNumber;

    public String getGuestCreditCardNumber() {
        return guestCreditCardNumber;
    }

    public void setGuestCreditCardNumber(String guestCreditCardNumber) {
        this.guestCreditCardNumber = guestCreditCardNumber;
    }
}

public class CommonGuest extends customer {}</pre></div><p>When validating a <tt class="classname">PreferredGuest</tt> the
    following constraints are processed:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">@NotEmpty</tt>,
        <tt class="classname">@NotNull</tt> and
        <tt class="classname">@Size(min=1)</tt> on
        <tt class="methodname">firstName</tt></p></li><li><p><tt class="classname">@NotEmpty</tt>,
        <tt class="classname">@NotNull</tt> and
        <tt class="classname">@Size(min=1)</tt> on
        <tt class="methodname">lastName</tt></p></li><li><p><tt class="classname">@NotNull</tt> on
        <tt class="methodname">customerId</tt>, <tt class="classname">@Password</tt>
        on <tt class="methodname">password</tt></p></li><li><p><tt class="classname">@CreditCard</tt> on
        <tt class="methodname">guestCreditCardNumber</tt></p></li></ul></div><p>When validating <tt class="classname">CommonGuest</tt>, the following
    constraints are processed:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">@NotEmpty</tt>,
        <tt class="classname">@NotNull</tt> and
        <tt class="classname">@Size(min=1)</tt> on
        <tt class="methodname">firstName</tt></p></li><li><p><tt class="classname">@NotEmpty</tt>,
        <tt class="classname">@NotNull</tt> and
        <tt class="classname">@Size(min=1)</tt> on
        <tt class="methodname">lastName</tt></p></li><li><p><tt class="classname">@NotNull</tt> on
        <tt class="methodname">customerId</tt>, <tt class="classname">@Password</tt>
        on <tt class="methodname">password</tt></p></li></ul></div><p>The fourth example demonstrates the influence of group
    sequence.</p><div class="example"><a name="d0e4654"></a><p class="title"><b>Example&nbsp;4.32.&nbsp;Use groups and group sequence to define constraint
      ordering</b></p><pre class="programlisting"><span class="bold"><b>@GroupSequence({First.class, Second.class, Last.class})</b></span>
public interface Complete {}

public class Book {
    @NotEmpty(groups=First.class)
    private String title;

    @Size(max=30, groups=Second.class)
    private String subtitle;

    @Valid
    @NotNull(groups=First.class)
    private Author author;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getSubtitle() {
        return subtitle;
    }

    public void setSubtitle(String subtitle) {
        this.subtitle = subtitle;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }
}

public class Author {
    @NotEmpty(groups=Last.class)
    private String firstName;
    
    @NotEmpty(groups=First.class)
    private String lastName;

    @Size(max=30, groups=Last.class)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}</pre></div><p>Assuming the validation of the <tt class="classname">Complete</tt> group
    on the following book instance:</p><pre class="programlisting">Author author = new Author();
author.setLastName( "Baudelaire" );
author.setFirstName( "" );
Book book = new Book();
book.setAuthor( author );</pre><p>the validation routine will return the following failure:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">@NotNull</tt> failure (from
        <tt class="classname">@NotEmpty</tt>) on the <tt class="literal">title</tt>
        field</p></li></ul></div><p>As both <tt class="methodname">title</tt> and
    <tt class="methodname">author.lastname</tt> are checked as part of the
    <tt class="literal"><tt class="classname">First</tt></tt> group. If the instance is
    updated:</p><pre class="programlisting">book.setTitle( "Les fleurs du mal" );
author.setCompany("Some random publisher with a very very very long name");</pre><p>the validation routine will return the following failures:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">author.firstName</tt> fails to pass the
        <tt class="classname">@Size(min=1)</tt> (from
        <tt class="classname">@NotEmpty</tt>) constraint</p></li><li><p><tt class="methodname">author.company</tt> fails to pass the
        <tt class="classname">@Size</tt> constraint</p></li></ul></div><p>As the <tt class="classname">First</tt> and
    <tt class="classname">Second</tt> groups pass without failure, the
    <tt class="classname">Last</tt> group is going through validation.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="validationapi"></a>Chapter&nbsp;5.&nbsp;Validation APIs</h2></div></div><div></div></div><p>The default package for the Bean Validation APIs is
  <tt class="classname">javax.validation.</tt></p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validationapi-validatorapi"></a>5.1.&nbsp;Validator API</h2></div></div><div></div></div><p>The main Bean Validation API is the
    <tt class="classname">javax.validation.Validator</tt> interface.</p><p>A <tt class="classname">Validator</tt> instance is able to validate
    instances of beans and their associated objects if any. It is recommended
    to leave the caching of <tt class="classname">Validator</tt> instances to the
    <tt class="classname">ValidatorFactory</tt>. <span class="tck-not-testable"><tt class="classname">Validator</tt> implementations
    must be thread-safe.</span></p><div class="example"><a name="d0e4759"></a><p class="title"><b>Example&nbsp;5.1.&nbsp;Validator interface</b></p><pre class="programlisting">/**
 * Validates bean instances. Implementations of this interface must be thread-safe.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @author Gunnar Morling
 */
public interface Validator {

    /**
     * Validates all constraints on {@code object}.
     *
     * @param object object to validate
     * @param groups the group or list of groups targeted for validation (defaults to
     *        {@link Default})
     * @return constraint violations or an empty set if none
     * @throws IllegalArgumentException if object is {@code null}
     *         or if {@code null} is passed to the varargs groups
     * @throws ValidationException if a non recoverable error happens
     *         during the validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T object, Class&lt;?&gt;... groups);

    /**
     * Validates all constraints placed on the property of {@code object}
     * named {@code propertyName}.
     *
     * @param object object to validate
     * @param propertyName property to validate (i.e. field and getter constraints)
     * @param groups the group or list of groups targeted for validation (defaults to
     *        {@link Default})
     * @return constraint violations or an empty set if none
     * @throws IllegalArgumentException if {@code object} is {@code null},
     *         if {@code propertyName} is {@code null}, empty or not a valid object property
     *         or if {@code null} is passed to the varargs groups
     * @throws ValidationException if a non recoverable error happens
     *         during the validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateProperty(T object,
                                                     String propertyName,
                                                     Class&lt;?&gt;... groups);

    /**
     * Validates all constraints placed on the property named {@code propertyName}
     * of the class {@code beanType} would the property value be {@code value}.
     * &lt;p/&gt;
     * {@link ConstraintViolation} objects return {@code null} for
     * {@link ConstraintViolation#getRootBean()} and {@link ConstraintViolation#getLeafBean()}.
     *
     * @param beanType the bean type
     * @param propertyName property to validate
     * @param value property value to validate
     * @param groups the group or list of groups targeted for validation (defaults to
     *        {@link Default}).
     * @return constraint violations or an empty set if none
     * @throws IllegalArgumentException if {@code beanType} is {@code null},
     *         if {@code propertyName} is {@code null}, empty or not a valid object property
     *         or if {@code null} is passed to the varargs groups
     * @throws ValidationException if a non recoverable error happens
     *         during the validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue(Class&lt;T&gt; beanType,
                                                  String propertyName,
                                                  Object value,
                                                  Class&lt;?&gt;... groups);

    /**
     * Returns the descriptor object describing bean constraints.
     * &lt;p/&gt;
     * The returned object (and associated objects including
     * {@link ConstraintDescriptor}s) are immutable.
     *
     * @param clazz class or interface type evaluated
     * @return the bean descriptor for the specified class
     * @throws IllegalArgumentException if clazz is {@code null}
     * @throws ValidationException if a non recoverable error happens
     *         during the metadata discovery or if some
     *         constraints are invalid.
     */
    BeanDescriptor getConstraintsForClass(Class&lt;?&gt; clazz);

    /**
     * Returns an instance of the specified type allowing access to
     * provider-specific APIs.
     * &lt;p/&gt;
     * If the Bean Validation provider implementation does not support
     * the specified class, {@link ValidationException} is thrown.
     *
     * @param type the class of the object to be returned
     * @return an instance of the specified class
     * @throws ValidationException if the provider does not support the call
     */
    &lt;T&gt; T unwrap(Class&lt;T&gt; type);

    /**
     * Returns the contract for validating parameters and return values of methods
     * and constructors.
     *
     * @return contract for method and constructor validation
     *
     * @since 1.1
     */
    ExecutableValidator forExecutables();
}</pre></div><p>The methods <tt class="methodname">validate()</tt>,
    <tt class="methodname">validateProperty()</tt> and
    <tt class="methodname">validateValue()</tt> are used for the validation of
    Java beans respectively single bean properties. See the next section for
    more details.</p><p><tt class="methodname">forExecutables()</tt> provides access to the
    contract for validating method and constructor parameters and return
    values. The individual methods for method and constructor validation are
    described in <a href="#validationapi-validatorapi-methodlevelvalidationmethods" title="5.1.2.&nbsp;Methods for validating method and constructor constraints">Section&nbsp;5.1.2, &#8220;Methods for validating method and constructor constraints&#8221;</a>.</p><p><tt class="methodname">getConstraintsForClass()</tt> returns
    constraint-related metadata for given types and is described in detail in
    <a href="#constraintmetadata" title="Chapter&nbsp;6.&nbsp;Constraint metadata request APIs">Chapter&nbsp;6, <i>Constraint metadata request APIs</i></a>.</p><p><tt class="methodname">unwrap()</tt> is provided as a way to access
    objects of a given type specific to a Bean Validation provider typically
    as a complement to the <tt class="classname">Validator</tt> contract. Using
    this method makes your code non portable.</p><div class="example"><a name="d0e4794"></a><p class="title"><b>Example&nbsp;5.2.&nbsp;Using unwrap to access a provider specific contract</b></p><pre class="programlisting">//if using the ACME provider
ACMEValidator acmeValidator = factory.unwrap(ACMEValidator.class);
acmeValidator.setSpecificConfiguration( [...] );</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="validationapi-validatorapi-validationmethods"></a>5.1.1.&nbsp;Validation methods</h3></div></div><div></div></div><p><span class="tck-testable"><tt class="methodname">&lt;T&gt;
      Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T object,
      Class&lt;?&gt;... groups)</tt> is used to validate a given
      object.</span> This method implements the logic described in <a href="#constraintdeclarationvalidationprocess-validationroutine" title="4.6.&nbsp;Validation routine">Section&nbsp;4.6, &#8220;Validation routine&#8221;</a>.
      <span class="tck-testable">An
      <tt class="classname">IllegalArgumentException</tt> is thrown when null is
      passed for the <tt class="varname">object</tt> parameter or the varargs
      <tt class="varname">groups</tt> parameter.</span> <span class="tck-testable">A <tt class="classname">Set</tt> containing all
      <tt class="classname">ConstraintViolation</tt> objects representing the
      failing constraints is returned, an empty <tt class="classname">Set</tt> is
      returned otherwise.</span></p><p><span class="tck-testable"><tt class="methodname">&lt;T&gt;
      Set&lt;ConstraintViolation&lt;T&gt;&gt; validateProperty(T object,
      String propertyName, Class&lt;?&gt;... groups)</tt> validates a
      given field or property of an object. </span><span class="tck-testable">An <tt class="classname">IllegalArgumentException</tt>
      is thrown when <tt class="methodname">validateProperty()</tt> is called and
      <tt class="varname">object</tt> is null or <tt class="varname">propertyName</tt> is
      null empty or invalid or null is passed to the varargs
      <tt class="varname">groups</tt> parameter.</span><span class="tck-testable"> The property name is the JavaBeans property name
      (as defined by the JavaBeans <tt class="classname">Introspector</tt>
      class).</span> This method implements the logic described in <a href="#constraintdeclarationvalidationprocess-validationroutine" title="4.6.&nbsp;Validation routine">Section&nbsp;4.6, &#8220;Validation routine&#8221;</a> but
      only to the given property. <span class="tck-testable"><tt class="literal">@Valid</tt> is not honored by this
      method.</span> This method is useful for partial object
      validation.</p><p><span class="tck-testable"><tt class="methodname">&lt;T&gt;
      Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue(Class&lt;T&gt;
      beanType, String propertyName, Object value, Class&lt;?&gt;...
      groups)</tt> validates the property referenced by
      <i class="parameter"><tt>propertyName</tt></i> present on
      <tt class="literal">beanType</tt> or any of its superclasses, if the property
      value were <i class="parameter"><tt>value</tt></i>.</span> <span class="tck-testable">An <tt class="classname">IllegalArgumentException</tt>
      is thrown when <tt class="methodname">validateValue()</tt> is called and
      <tt class="varname">object</tt> is null or <tt class="varname">propertyName</tt> is
      null empty or invalid or null is passed to the varargs
      <tt class="varname">groups</tt> parameter.</span> This method implements the
      logic described in <a href="#constraintdeclarationvalidationprocess-validationroutine" title="4.6.&nbsp;Validation routine">Section&nbsp;4.6, &#8220;Validation routine&#8221;</a> and
      apply it only to the given property and for the given value. <span class="tck-testable"><tt class="literal">@Valid</tt> is not honored by this
      method.</span> This method is useful for ahead of time validation
      (i.e. before the JavaBean is populated or updated).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If multiple constrained fields or getters share the same name
        and hide one another in the class hierarchy according to the Java
        visibility rules, the list of constraints evaluated is unspecified.
        This will be clarified in a later version of this specification. Note
        that method overriding is not impacted.</p><p>If getters and fields share the same name and are present at
        different levels of the hierarchy, the list of constraints evaluated
        is unspecified. This will be clarified in a later version of this
        specification.</p><p>However, constraints hosted on the most specific (hierarchy
        wise) element type are always evaluated.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><tt class="methodname">validateProperty()</tt> and
        <tt class="methodname">validateValue()</tt> accept property names and not
        full paths. Bean Validation implementations might accept string
        representations of paths but this behavior is not portable.</p></div><p><span class="tck-testable">If some unrecoverable failure happens
      during validation, a <tt class="classname">ValidationException</tt> is
      raised.</span> This exception can be specialized in some situations
      (invalid group definition, invalid constraint definition, invalid
      constraint declaration). See <a href="#exception" title="Chapter&nbsp;9.&nbsp;Exception model">Chapter&nbsp;9, <i>Exception model</i></a> or the relative
      sections for more information.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4932"></a>5.1.1.1.&nbsp;Examples</h4></div></div><div></div></div><p>All the examples will be based on the following class
        definition, constraint declarations and address instance.</p><pre class="programlisting">public class Address {
    <span class="bold"><b>@NotNull @Size(max=30)</b></span>
    private String addressline1;

    <span class="bold"><b>@Size(max=30)</b></span>
    private String addressline2;

    private String zipCode;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    <span class="bold"><b>@Size(max=30) @NotNull</b></span>
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}

Address address = new Address();
address.setAddressline1( null );
address.setAddressline2( null );
address.setCity("Llanfairpwllgwyngyllgogerychwyrndrobwyll-llantysiliogogogoch");
//town in North Wales</pre><p>The following code will return two
        <tt class="classname">ConstraintViolation</tt> objects. One for
        <tt class="literal">addressline1</tt> violating <tt class="literal">@NotNull</tt>
        and one for <tt class="literal">city</tt> violating
        <tt class="literal">@Size</tt>.</p><pre class="programlisting">validator.validate(address).size() == 2</pre><p>The following code will return one
        <tt class="classname">ConstraintViolation</tt> since
        <tt class="literal">city</tt> violates <tt class="literal">@Size</tt> and only
        <tt class="literal">city</tt> is validated.</p><pre class="programlisting">validator.validateProperty(address, "city").size() == 1</pre><p>The following code will return no
        <tt class="classname">ConstraintViolation</tt> object because the value
        "Paris" for <tt class="literal">city</tt> would not raise any constraint
        failure.</p><pre class="programlisting">validator.validateValue("city", "Paris").size() == 0</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="validationapi-validatorapi-methodlevelvalidationmethods"></a>5.1.2.&nbsp;Methods for validating method and constructor constraints</h3></div></div><div></div></div><p>The methods for the validation of parameters and return values of
      methods and constructors can be found on the interface
      <tt class="classname">javax.validation.executable.ExecutableValidator</tt>.</p><div class="example"><a name="d0e5001"></a><p class="title"><b>Example&nbsp;5.3.&nbsp;ExecutableValidator interface</b></p><pre class="programlisting">package javax.validation.executable;

/**
 * Validates parameters and return values of methods and constructors.
 * Implementations of this interface must be thread-safe.
 *
 * @author Gunnar Morling
 * @since 1.1
 */
public interface ExecutableValidator {

    /**
     * Validates all constraints placed on the parameters of the given method.
     *
     * @param &lt;T&gt; the type hosting the method to validate
     * @param object the object on which the method to validate is invoked
     * @param method the method for which the parameter constraints is validated
     * @param parameterValues the values provided by the caller for the given method's
     *        parameters
     * @param groups the group or list of groups targeted for validation (defaults to
     *        {@link Default})
     * @return a set with the constraint violations caused by this validation;
     *         will be empty if no error occurs, but never {@code null}
     * @throws IllegalArgumentException if {@code null} is passed for any of the parameters
     *         or if parameters don't match with each other
     * @throws ValidationException if a non recoverable error happens during the
     *         validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateParameters(T object,
                                                       Method method,
                                                       Object[] parameterValues,
                                                       Class&lt;?&gt;... groups);

    /**
     * Validates all return value constraints of the given method.
     *
     * @param &lt;T&gt; the type hosting the method to validate
     * @param object the object on which the method to validate is invoked
     * @param method the method for which the return value constraints is validated
     * @param returnValue the value returned by the given method
     * @param groups the group or list of groups targeted for validation (defaults to
     *        {@link Default})
     * @return a set with the constraint violations caused by this validation;
     *         will be empty if no error occurs, but never {@code null}
     * @throws IllegalArgumentException if {@code null} is passed for any of the object,
     *         method or groups parameters or if parameters don't match with each other
     * @throws ValidationException if a non recoverable error happens during the
     *         validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateReturnValue(T object,
                                                        Method method,
                                                        Object returnValue,
                                                        Class&lt;?&gt;... groups);

    /**
     * Validates all constraints placed on the parameters of the given constructor.
     *
     * @param &lt;T&gt; the type hosting the constructor to validate
     * @param constructor the constructor for which the parameter constraints is validated
     * @param parameterValues the values provided by the caller for the given constructor's
     *        parameters
     * @param groups the group or list of groups targeted for validation (defaults to
     *        {@link Default})
     * @return a set with the constraint violations caused by this validation;
     *         Will be empty if no error occurs, but never {@code null}
     * @throws IllegalArgumentException if {@code null} is passed for any of the parameters
     *         or if parameters don't match with each other
     * @throws ValidationException if a non recoverable error happens during the
     *         validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateConstructorParameters(Constructor&lt;? extends T&gt; constructor,
                                                                  Object[] parameterValues,
                                                                  Class&lt;?&gt;... groups);

    /**
     * Validates all return value constraints of the given constructor.
     *
     * @param &lt;T&gt; the type hosting the constructor to validate
     * @param constructor the constructor for which the return value constraints is validated
     * @param createdObject the object instantiated by the given method
     * @param groups the group or list of groups targeted for validation (defaults to
     *        {@link Default})
     * @return a set with the constraint violations caused by this validation;
     *         will be empty, if no error occurs, but never {@code null}
     * @throws IllegalArgumentException if {@code null} is passed for any of the parameters
     *         or if parameters don't match with each other
     * @throws ValidationException if a non recoverable error happens during the
     *         validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateConstructorReturnValue(Constructor&lt;? extends T&gt; constructor,
                                                                   T createdObject,
                                                                   Class&lt;?&gt;... groups);
}
</pre></div><p><span class="tck-testable"><tt class="methodname">&lt;T&gt;
      Set&lt;ConstraintViolation&lt;T&gt;&gt; validateParameters(T object,
      Method method, Object[] parameterValues, Class&lt;?&gt;...
      groups)</tt> validates the arguments (as given in
      <tt class="varname">parameterValues</tt>) for the parameters of a given method
      (identified by <tt class="varname">method</tt>). Cross-parameter constraints
      are also validated.</span><span class="tck-testable"> A set
      containing all <tt class="classname">ConstraintViolation</tt> objects
      representing the failing constraints is returned, an empty set is
      returned if no constraint violation occurred. </span><span class="tck-testable">An <tt class="classname">IllegalArgumentException</tt>
      will be thrown if null is passed for any of the parameters or if the
      parameters don't match with each other (i.e. <tt class="literal">object</tt>
      and <tt class="literal">method</tt> don't match,
      <tt class="literal">parameterValues</tt> and <tt class="literal">method</tt> don't
      match).</span></p><p><span class="tck-testable"><tt class="methodname">&lt;T&gt;
      Set&lt;ConstraintViolation&lt;T&gt;&gt; validateReturnValue(T object,
      Method method, Object returnValue, Class&lt;?&gt;...
      groups)</tt> validates the return value (specified by
      <tt class="varname">returnValue</tt>) of a given method (identified by
      <tt class="varname">method</tt>).</span> <span class="tck-testable">A set
      containing all <tt class="classname">ConstraintViolation</tt> objects
      representing the failing constraints is returned, an empty set is
      returned if no constraint violation occurred.</span><span class="tck-testable"> An <tt class="classname">IllegalArgumentException</tt>
      will be thrown if null is passed for any of the parameters
      <tt class="varname">object</tt>, <tt class="varname">method</tt> and
      <tt class="varname">groups</tt> or if the parameters don't match with each
      other (i.e. <tt class="literal">object</tt> and <tt class="literal">method</tt>
      don't match, <tt class="literal">returnValue</tt> and
      <tt class="literal">method</tt> don't match).</span></p><p><span class="tck-testable"><tt class="methodname">&lt;T&gt;
      Set&lt;ConstraintViolation&lt;T&gt;&gt;
      validateConstructorParameters(Constructor&lt;T&gt; constructor, Object[]
      parameterValues, Class&lt;?&gt;... groups)</tt> validates the
      arguments (as given in <tt class="varname">parameterValues</tt>) for the
      parameters of a given constructor (identified by
      <tt class="varname">constructor</tt>). Cross-parameter constraints are also
      validated.</span> <span class="tck-testable">A set containing all
      <tt class="classname">ConstraintViolation</tt> objects representing the
      failing constraints is returned, an empty set is returned if no
      constraint violation occurred.</span> <span class="tck-testable">An
      <tt class="classname">IllegalArgumentException</tt> will be thrown if null
      is passed for any of the parameters or if the parameters don't match
      with each other (i.e. <tt class="literal">parameterValues</tt> and
      <tt class="literal">constructor</tt> don't match).</span></p><p><span class="tck-testable"><tt class="methodname">&lt;T&gt;
      Set&lt;ConstraintViolation&lt;T&gt;&gt;
      validateConstructorReturnValue(Constructor&lt;T&gt; constructor, T
      createdObject, Class&lt;?&gt;... groups)</tt> validates the
      object (specified by <tt class="varname">createdObject</tt>) of a given
      constructor (identified by <tt class="varname">constructor</tt>).</span>
      <span class="tck-testable">A set containing all
      <tt class="classname">ConstraintViolation</tt> objects representing the
      failing constraints is returned, an empty set is returned if no
      constraint violation occurred.</span><span class="tck-testable"> An
      <tt class="classname">IllegalArgumentException</tt> will be thrown if null
      is passed for any of the parameters or if the parameters don't match
      with each other (i.e. <tt class="literal">createdObject</tt> and
      <tt class="literal">constructor</tt> don't match).</span></p><p class="tck-testable">None of those methods honor the XML
      configuration around executable validation nor the presence of
      <tt class="classname">@ValidateOnExecution</tt>. In other words, elements
      will be validated regardless of these settings when explicitly calling
      the validation methods.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5144"></a>5.1.2.1.&nbsp;Examples</h4></div></div><div></div></div><p>All the examples will be based on the following class
        definitions, constraint declarations and instances.</p><pre class="programlisting">public class OrderService {

    @NotNull
    private CreditCardProcessor creditCardProcessor;

    @Valid
    public OrderService(@NotNull CreditCardProcessor creditCardProcessor) {
        [...]
    }

    @NotNull
    public Order placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull @Valid Item item,
        @Min(1) int quantity) {

        [...]
    }
}

public class Item {

    @NotNull;
    private String name;

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}

Item item1 = new Item();
item1.setName("Kiwi");

Item item2 = new Item();
item2.setName(null);

Constructor&lt;OrderService&gt; constructor = [...]; //get constructor object
Method placeOrder = [...]; //get method object

OrderService orderService = new OrderService(new DefaultCreditCardProcessor());

ExecutableValidator executableValidator = Validation
    .buildDefaultValidatorFactory().getValidator().forExecutables();</pre><p>The following method parameter validation will return one
        <tt class="classname">ConstraintViolation</tt> object as the customer code
        is null:</p><pre class="programlisting">//orderService.placeOrder(null, item1, 1);
executableValidator.validateParameters(
    orderService, placeOrder, new Object[] { null, item1, 1 }).size() == 1;</pre><p>The following method parameter validation will return one
        <tt class="classname">ConstraintViolation</tt> object as the
        <tt class="varname">item</tt> parameter is marked for cascaded validation
        and the given <tt class="classname">Item</tt> instance is not valid (its
        name is null):</p><pre class="programlisting">//orderService.placeOrder("CUST-123", item2, 1);
executableValidator.validateParameters(
    orderService, placeOrder, new Object[] { "CUST-123", item2, 1 }).size() == 1;</pre><p>The following constructor parameter validation will return one
        <tt class="classname">ConstraintViolation</tt> object as null is passed
        for the <tt class="varname">creditCardProcessor</tt> parameter:</p><pre class="programlisting">//new OrderService(null);
executableValidator.validateConstructorParameters(constructor, new Object[] { null })
    .size() == 1;</pre><p>Assuming the <tt class="methodname">placeOrder()</tt> method
        returned <tt class="varname">null</tt>, the following return value
        validation will return one
        <tt class="classname">ConstraintViolation</tt>:</p><pre class="programlisting">executableValidator.validateReturnValue(orderService, placeOrder, null).size() == 1;</pre><p>Assuming the constructor of <tt class="classname">OrderService</tt>
        failed to store the given credit card processor into the
        <tt class="varname">creditCardProcessor</tt>, field the following validation
        of the constructor return value would fail as the constructor is
        marked with <tt class="classname">@Valid</tt> and the
        <tt class="classname">@NotNull</tt> constraint of the
        <tt class="classname">OrderService</tt> class would be violated:</p><pre class="programlisting">executableValidator.validateConstructorReturnValue(constructor, orderService).size() == 1;</pre><p>Let's now look at how a validation interceptor would use these
        methods.</p><pre class="programlisting">@Interceptor
public class SampleMethodInterceptor {
    @Inject
    private Validator validator;

    @AroundInvoke
    public Object validateMethodInvocation(InvocationContext ctx) throws Exception {
        //validate parameters
        Set&lt;ConstraintViolation&lt;Object&gt;&gt; violations;
        violations = validator.forExecutables().validateParameters(
                ctx.getTarget(),
                ctx.getMethod(),
                ctx.getParameters()
        );

        //if a violation occurs for parameters, raise an exception
        if ( !violations.isEmpty() ) {
            throw new ConstraintViolationException(
                    buildMessage( ctx.getMethod(), ctx.getParameters(), violations ),
                    violations
            );
        }

        //execute the method proper
        Object result = ctx.proceed();

        //validate the return type
        violations = validator.forExecutables().validateReturnValue(
                ctx.getTarget(),
                ctx.getMethod(),
                result
        );

        //if a violation occurs for the return type, raise an exception
        if ( !violations.isEmpty() ) {
            throw new ConstraintViolationException(
                    buildMessage( ctx.getMethod(), ctx.getParameters(), violations ),
                    violations
            );
        }

        //return the result
        return result;
    }
}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="validationapi-validatorapi-groups"></a>5.1.3.&nbsp;groups</h3></div></div><div></div></div><p>Groups allow you to restrict the set of constraints applied during
      validation. Groups targeted are passed as parameters to the
      <tt class="methodname">validate()</tt>,
      <tt class="methodname">validateProperty()</tt> and
      <tt class="methodname">validateValue()</tt> methods as well as the methods
      to validate method/constructor constraints (see <a href="#validationapi-validatorapi-methodlevelvalidationmethods" title="5.1.2.&nbsp;Methods for validating method and constructor constraints">Section&nbsp;5.1.2, &#8220;Methods for validating method and constructor constraints&#8221;</a>).
      <span class="tck-testable">All constraints belonging to the targeted
      group(s) are applied during the <a href="#constraintdeclarationvalidationprocess-validationroutine" title="4.6.&nbsp;Validation routine">Section&nbsp;4.6, &#8220;Validation routine&#8221;</a>.</span>
      <span class="tck-testable">If no group is passed, the
      <tt class="literal"><tt class="classname">Default</tt></tt> group is
      assumed.</span> <a href="#constraintsdefinitionimplementation-constraintdefinition-groups" title="3.1.1.2.&nbsp;groups">Section&nbsp;3.1.1.2, &#8220;groups&#8221;</a>
      describes how to define groups on constraints.</p><p><span class="tck-not-testable">When more than one group is
      evaluated and passed to the various validate methods, order is not
      constrained.</span> It is equivalent to the validation of a group
      <tt class="literal">G</tt> inheriting all groups (i.e. implementing all
      interfaces) passed to the validation method.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5254"></a>5.1.3.1.&nbsp;Examples</h4></div></div><div></div></div><pre class="programlisting">/** Validates a minimal set of constraints */
public interface Minimal {}

public class Address {

    @NotEmpty(groups = Minimal.class)
    @Size(max=50)
    private String street1;
    
    @NotEmpty
    private String city;

    @NotEmpty(groups = {Minimal.class, Default.class})
    private String zipCode;

    [...]
}</pre><p>In the previous example, <tt class="classname">@NotEmpty</tt> (and
        it's composing constraints) on <tt class="methodname">street1</tt>
        applies to the group <tt class="classname">Minimal</tt>,
        <tt class="classname">@Size</tt> on <tt class="methodname">street1</tt>
        applies to the group <tt class="literal">Default</tt> and
        <tt class="classname">@NotEmpty </tt>(and it's composing constraints) on
        <tt class="methodname">zipCode</tt> applies to the groups
        <tt class="literal"><tt class="classname">Default</tt></tt> and
        <tt class="literal"><tt class="classname">Minimal</tt></tt>.</p><pre class="programlisting">validator.validate(address);</pre><p>validates the group <tt class="classname">Default</tt> (implicitly)
        and applies <tt class="classname">@Size</tt> on
        <tt class="methodname">street1</tt>, <tt class="classname">@NotEmpty</tt>
        (and its composing constraints) on <tt class="methodname">city</tt>,
        <tt class="classname">@NotEmpty</tt> (and its composing constraints) on
        <tt class="methodname">zipCode</tt>. Particularly,
        <tt class="classname">@NotEmpty</tt> (and its composing constraints) on
        <tt class="methodname">street1</tt> are not applied.</p><pre class="programlisting">validator.validate(address, Minimal.class);</pre><p>applies <tt class="classname">@NotEmpty</tt> (and its composing
        constraints) on <tt class="methodname">street1</tt> and
        <tt class="classname">@NotEmpty</tt> (and its composing constraints) on
        <tt class="methodname">zipCode</tt> because they belong to the
        <tt class="classname">Minimal</tt> group.</p><pre class="programlisting">validator.validate(address, Minimal.class, Default.class);</pre><p>validates both <tt class="classname">Default</tt> and
        <tt class="classname">Minimal</tt> groups. The routine applies
        <tt class="classname">@NotEmpty</tt> (and its composing constraints) and
        <tt class="classname">@Size</tt> on <tt class="methodname">street1</tt>,
        <tt class="classname">@NotEmpty</tt> (and its composing constraints) on
        <tt class="methodname">city</tt>, <tt class="classname">@NotEmpty</tt> (and
        its composing constraints) on <tt class="methodname">zipCode</tt>. Note
        that if <tt class="methodname">zipCode</tt> is empty, only one
        <tt class="classname">ConstraintViolation</tt> object will represent the
        failure and the not empty validation will only be executed
        once.</p><p>Let's look at a more complex example involving group
        sequence.</p><pre class="programlisting">public class Address {
    @NotEmpty(groups = Minimal.class)
    @Size(max=50, groups=FirstStep.class)
    private String street1;
    
    @NotEmpty(groups=SecondStep.class)
    private String city;

    @NotEmpty(groups = {Minimal.class, SecondStep.class})
    private String zipCode;

    [...]

    public interface FirstStep {}

    public interface SecondStep {}
    
    @GroupSequence({Firststep.class, SecondStep.class})
    public interface Total {}
}</pre><p>When running:</p><pre class="programlisting">validator.validate(address, Minimal.class, Total.class);</pre><p>the validation process will process
        <tt class="classname">@NotEmpty</tt> (and it's composing constraints) and
        <tt class="classname">@Size</tt> from <tt class="methodname">street1</tt> and
        <tt class="classname">@NotEmpty</tt> (and it's composing constraints) from
        <tt class="methodname">zipCode</tt>. If <tt class="classname">@Size</tt> from
        <tt class="methodname">street1</tt> does not generate a failure, then
        <tt class="classname">@NotEmpty</tt> (and it's composing constraints) from
        <tt class="methodname">city</tt> will be processed as part of
        <tt class="classname">SecondStep</tt>. Note that
        <tt class="classname">@NotEmpty</tt> (and it's composing constraints) from
        <tt class="methodname">zipCode</tt> are not reprocessed as they have
        already been processed before.</p><p>When running:</p><pre class="programlisting">validator.validate(address, Total.class, SecondStep.class);</pre><p><tt class="classname">@NotEmpty</tt> (and it's composing
        constraints) from <tt class="methodname">city</tt> and
        <tt class="classname">@NotEmpty</tt> (and it's composing constraints) from
        <tt class="methodname">zipCode</tt> will be processed even if
        <tt class="classname">@Size</tt> from <tt class="methodname">street1</tt>
        fails: while <tt class="literal"><tt class="classname">SecondStep</tt></tt> is
        in the <tt class="literal"><tt class="classname">Total</tt></tt> group sequence
        and hence should not be triggered if
        <tt class="literal"><tt class="classname">FirstStep</tt></tt> has a failure, it
        also has been requested outside the sequence (in this case
        explicitly).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If the group definition is invalid, a
          <tt class="classname">GroupDefinitionException</tt> is raised.</p></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validationapi-constraintviolation"></a>5.2.&nbsp;ConstraintViolation</h2></div></div><div></div></div><p><tt class="classname">ConstraintViolation</tt> is the class describing a
    single constraint failure. A set of
    <tt class="classname">ConstraintViolation</tt> is returned for an object
    validation.</p><pre class="programlisting">/**
 * Describes a constraint violation. This object exposes the constraint
 * violation context as well as the message describing the violation.
 *
 * @author Emmanuel Bernard
 */
public interface ConstraintViolation&lt;T&gt; {

    /**
     * @return the interpolated error message for this constraint violation
     */
    String getMessage();

    /**
     * @return the non-interpolated error message for this constraint violation
     */
    String getMessageTemplate();

    /**
     * Returns the root bean being validated. For method validation, returns
     * the object the method is executed on.
     * &lt;p/&gt;
     * Returns {@code null} when:
     * &lt;ul&gt;
     *     &lt;li&gt;the {@code ConstraintViolation} is returned after calling
     *     {@link Validator#validateValue(Class, String, Object, Class[])}&lt;/li&gt;
     *     &lt;li&gt;the {@code ConstraintViolation} is returned after validating a
     *     constructor.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return the validated object, the object hosting the validated element or {@code null}
     */
    T getRootBean();

    /**
     * Returns the class of the root bean being validated.
     * For method validation, this is the object class the
     * method is executed on.
     * For constructor validation, this is the class the constructor
     * is declared on.
     *
     * @return the class of the root bean or of the object hosting the validated element
     */
    Class&lt;T&gt; getRootBeanClass();

    /**
     * Returns:
     * &lt;ul&gt;
     *     &lt;li&gt;the bean instance the constraint is applied on if it is
     *     a bean constraint&lt;/li&gt;
     *     &lt;li&gt;the bean instance hosting the property the constraint
     *     is applied on if it is a property constraint&lt;/li&gt;
     *     &lt;li&gt;{@code null} when the {@code ConstraintViolation} is returned
     *     after calling {@link Validator#validateValue(Class, String, Object, Class[])}
     *     &lt;/li&gt;
     *     &lt;li&gt;the object the method is executed on if it is
     *     a method parameter, cross-parameter or return value constraint&lt;/li&gt;
     *     &lt;li&gt;{@code null} if it is a constructor parameter or
     *     cross-parameter constraint&lt;/li&gt;
     *     &lt;li&gt;the object the constructor has created if it is a
     *     constructor return value constraint&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return the leaf bean
     */
    Object getLeafBean();

    /**
     * Returns an {@code Object[]} representing the constructor or method invocation
     * arguments if the {@code ConstraintViolation} is returned after validating the
     * method or constructor parameters.
     * Returns {@code null} otherwise.
     *
     * @return parameters of the method or constructor invocation or {@code null}
     *
     * @since 1.1
     */
    Object[] getExecutableParameters();

    /**
     * Returns the return value of the constructor or method invocation
     * if the {@code ConstraintViolation} is returned after validating the method
     * or constructor return value.
     * &lt;p/&gt;
     * Returns {@code null} if the method has no return value.
     * Returns {@code null} otherwise.
     *
     * @return the method or constructor return value or {@code null}
     *
     * @since 1.1
     */
    Object getExecutableReturnValue();

    /**
     * @return the property path to the value from {@code rootBean}
     */
    Path getPropertyPath();

    /**
     * Returns the value failing to pass the constraint.
     * For cross-parameter constraints, an {@code Object[]} representing
     * the method invocation arguments is returned.
     *
     * @return the value failing to pass the constraint
     */
    Object getInvalidValue();

    /**
     * Returns the constraint metadata reported to fail.
     * The returned instance is immutable.
     *
     * @return constraint metadata
     */
    ConstraintDescriptor&lt;?&gt; getConstraintDescriptor();

    /**
     * Returns an instance of the specified type allowing access to
     * provider-specific APIs. If the Bean Validation provider
     * implementation does not support the specified class,
     * {@link ValidationException} is thrown.
     *
     * @param type the class of the object to be returned
     * @return an instance of the specified class
     * @throws ValidationException if the provider does not support the call
     *
     * @since 1.1
     */
    &lt;U&gt; U unwrap(Class&lt;U&gt; type);
}</pre><p><span class="tck-testable">The
    <tt class="methodname">getMessage()</tt> method returns the interpolated
    (localized) message for the failing constraint</span> (see <a href="#validationapi-message" title="5.3.&nbsp;Message interpolation">Section&nbsp;5.3, &#8220;Message interpolation&#8221;</a> for more information on message
    interpolator). This can be used by clients to expose user friendly
    messages.</p><p><span class="tck-testable">The
    <tt class="methodname">getMessageTemplate()</tt> method returns the
    non-interpolated error message</span> (usually the
    <tt class="literal">message</tt> attribute on the constraint declaration).
    Frameworks can use this as an error code key.</p><p><span class="tck-testable">The
    <tt class="methodname">getRootBean()</tt> method returns the root object
    being validated that led to the failing constraint</span> (i.e. the
    object the client code passes to the
    <tt class="methodname">Validator.validate()</tt> method). <span class="tck-testable">For method validation, returns the object the method
    is executed on. For constructors or when
    <tt class="methodname">Validator.validateValue()</tt> is used, returns
    <tt class="literal">null</tt>.</span></p><p class="tck-testable">The <tt class="methodname">getRootBeanClass()</tt>
    method returns the class of the root bean being validated. For method
    validation, this is the object class the method is executed on. For
    constructor validation, this is the class the constructor is declared
    on.</p><p class="tck-testable">The <tt class="methodname">getLeafBean()</tt>
    method returns the following object:</p><div class="itemizedlist"><ul type="disc"><li><p>If a bean constraint, the bean instance the constraint is
          applied on.</p></li><li><p>If a property constraint, the bean instance hosting the
          property the constraint is applied on.</p></li><li><p>If a property constraint, <tt class="literal">null</tt> when the
          <tt class="classname">ConstraintViolation</tt> is returned after calling
          <tt class="methodname">Validator.validateValue()</tt>.</p></li><li><p>If a method parameter, cross-parameter or return value
          constraint, the object the method is executed on.</p></li><li><p>If a constructor parameter or cross-parameter constraint,
          <tt class="literal">null</tt>.</p></li><li><p>If a constructor return value constraint, the object the
          constructor has created.</p></li></ul></div><p class="tck-testable">The
    <tt class="methodname">getExecutableParameters()</tt> returns the parameters
    provided to the method or constructor invocation or
    <tt class="literal">null</tt> if not validating the method or constructor
    parameters.</p><p class="tck-testable">The
    <tt class="methodname">getExecutableReturnValue()</tt> returns the return
    value of the method or constructor invocation or <tt class="literal">null</tt>
    if the method has no return value or if not validating the method or
    constructor return value.</p><p><span class="tck-testable">The
    <tt class="methodname">getInvalidValue()</tt> method returns the value
    (field, property, method/constructor parameter, method/constructor return
    value or validated object) being passed to
    <tt class="methodname">isValid()</tt>.</span> <span class="tck-testable">For a cross-parameter constraint failure, an
    <tt class="code">Object[]</tt> representing the method/constructor invocation
    arguments is returned.</span></p><p><span class="tck-testable"><tt class="methodname">getConstraintDescriptor()</tt>
    provides access to the failing constraint metadata</span> (see <a href="#constraintmetadata-constraintdescriptor" title="6.11.&nbsp;ConstraintDescriptor">Section&nbsp;6.11, &#8220;ConstraintDescriptor&#8221;</a>).</p><p class="tck-testable">The <tt class="methodname">getPropertyPath()</tt>
    method returns the <tt class="classname">Path</tt> object representing the
    navigation path from the root object to the failing object.</p><p><tt class="methodname">unwrap()</tt> is provided as a way to access
    objects of a given type specific to a Bean Validation provider typically
    as a complement to the <tt class="classname">ConstraintViolation</tt>
    contract. Using this method makes your code non portable.</p><div class="example"><a name="d0e5611"></a><p class="title"><b>Example&nbsp;5.4.&nbsp;Path, Node and ElementKind interfaces</b></p><pre class="programlisting">/**
 * Represents the navigation path from an object to another
 * in an object graph.
 * Each path element is represented by a {@code Node}.
 * &lt;p/&gt;
 * The path corresponds to the succession of nodes
 * in the order they are returned by the {@code Iterator}.
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 */
public interface Path extends Iterable&lt;Path.Node&gt; {

    /**
     * Represents an element of a navigation path.
     */
    interface Node {

        /**
         * Returns the name of the element which the node represents:
         * &lt;ul&gt;
         *     &lt;li&gt;{@code null} if it is a leaf node which represents an entity / bean.
         *     In particular, the node representing the root object.&lt;/li&gt;
         *     &lt;li&gt;The property name for a property.&lt;/li&gt;
         *     &lt;li&gt;The method name for a method.&lt;/li&gt;
         *     &lt;li&gt;The unqualified name of the type declaring the constructor
         *     for a constructor.&lt;/li&gt;
         *     &lt;li&gt;The parameter named as defined by the {@link ParameterNameProvider}
         *     for a method or constructor parameter.&lt;/li&gt;
         *     &lt;li&gt;The literal {@code &lt;cross-parameter&gt;} for a method or constructor
         *     cross-parameter.&lt;/li&gt;
         *     &lt;li&gt;The literal {@code &lt;return value&gt;} for a method or constructor return
         *     value.&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * @return name of the element which the node represents
         */
        String getName();

        /**
         * @return {@code true} if the node represents an object contained in an
         *         {@code Iterable} or in a {@code Map}, {@code false} otherwise
         */
        boolean isInIterable();

        /**
         * @return the index the node is placed in if contained in an array or
         *         {@code List}; {@code null} otherwise
         */
        Integer getIndex();

        /**
         * @return the key the node is placed in if contained in a {@code Map},
         *         {@code null} otherwise
         */
        Object getKey();

        /**
         * The kind of element represented by the node. The following relationship
         * between an {@link ElementKind} and its {@code Node} subtype exists:
         * &lt;ul&gt;
         *     &lt;li&gt;{@link ElementKind#BEAN}: {@link BeanNode}&lt;/li&gt;
         *     &lt;li&gt;{@link ElementKind#PROPERTY}: {@link PropertyNode}&lt;/li&gt;
         *     &lt;li&gt;{@link ElementKind#METHOD}: {@link MethodNode}&lt;/li&gt;
         *     &lt;li&gt;{@link ElementKind#CONSTRUCTOR}: {@link ConstructorNode}&lt;/li&gt;
         *     &lt;li&gt;{@link ElementKind#PARAMETER}: {@link ParameterNode}&lt;/li&gt;
         *     &lt;li&gt;{@link ElementKind#CROSS_PARAMETER}: {@link CrossParameterNode}&lt;/li&gt;
         *     &lt;li&gt;{@link ElementKind#RETURN_VALUE}: {@link ReturnValueNode}&lt;/li&gt;
         * &lt;/ul&gt;
         * &lt;p/&gt;
         * This is useful to narrow down the {@code Node} type and access node specific
         * information:
         * &lt;pre&gt;
         * switch(node.getKind() {
         * case METHOD:
         *     name = node.getName();
         *     params = node.as(MethodNode.class).getParameterTypes();
         * case PARAMETER:
         *     index = node.as(ParameterNode.class).getParameterIndex();
         * [...]
         * }
         * &lt;/pre&gt;
         *  @return the {@code ElementKind}
         *
         * @since 1.1
         */
        ElementKind getKind();

        /**
         * Narrows the type of this node down to the given type. The appropriate
         * type should be checked before by calling {@link #getKind()}.
         *
         * @param &lt;T&gt; the type to narrow down to
         * @param nodeType class object representing the descriptor type to narrow down to
         *                 to
         *
         * @return this node narrowed down to the given type.
         *
         * @throws ClassCastException If this node is not assignable to the type {@code T}
         * @since 1.1
         */
        &lt;T extends Node&gt; T as(Class&lt;T&gt; nodeType);
    }

    /**
     * Node representing a method.
     *
     * @since 1.1
     */
    interface MethodNode extends Node {

        /**
         * @return the list of parameter types
         */
        List&lt;Class&lt;?&gt;&gt; getParameterTypes();
    }

    /**
     * Node representing a constructor.
     *
     * @since 1.1
     */
    interface ConstructorNode extends Node {

        /**
         * @return the list of parameter types
         */
        List&lt;Class&lt;?&gt;&gt; getParameterTypes();
    }

    /**
     * Node representing the return value of a method or constructor.
     *
     * @since 1.1
     */
    interface ReturnValueNode extends Node {
    }

    /**
     * Node representing a parameter of a method or constructor.
     *
     * @since 1.1
     */
    interface ParameterNode extends Node {

        /**
         * @return the parameter index in the method or constructor definition
         */
        int getParameterIndex();
    }

    /**
     * Node representing the element holding cross-parameter constraints
     * of a method or constructor.
     *
     * @since 1.1
     */
    interface CrossParameterNode extends Node {
    }

    /**
     * Node representing a bean.
     *
     * @since 1.1
     */
    interface BeanNode extends Node {
    }

    /**
     * Node representing a property.
     *
     * @since 1.1
     */
    interface PropertyNode extends Node {
    }
}</pre><pre class="programlisting">/**
 * Enum of possible kinds of elements encountered in Bean Validation.
 * &lt;p/&gt;
 * Mostly elements that can be constrained and described in the metadata
 * but also elements that can be part of a {@link Path} and represented
 * by a {@link Path.Node}
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 *
 * @since 1.1
 */
public enum ElementKind {
    /**
     * A Java Bean or object.
     */
    BEAN,

    /**
     * A property of a Java Bean.
     */
    PROPERTY,

    /**
     * A method.
     */
    METHOD,

    /**
     * A constructor.
     */
    CONSTRUCTOR,

    /**
     * A parameter of a method or constructor.
     */
    PARAMETER,

    /**
     * Element holding cross-parameter constraints of a method or constructor.
     */
    CROSS_PARAMETER,

    /**
     * The return value of a method or constructor.
     */
    RETURN_VALUE
}</pre></div><p><tt class="classname">Path</tt> is an iterable of
    <tt class="classname">Node</tt> objects. <tt class="classname">Node</tt> offers
    the following methods:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable"><tt class="methodname">getName()</tt> returns
          the name of the element which the node represents:</p><div class="itemizedlist"><ul type="circle"><li><p><tt class="literal">null</tt> if it is a leaf node which
              represents an entity / bean. In particular, the node
              representing the root object.</p></li><li><p>The property name for a property.</p></li><li><p>The method name for a method.</p></li><li><p>The unqualified name of the type declaring the constructor
              for a constructor.</p></li><li><p>The parameter named as defined by the
              <tt class="classname">ParameterNameProvider</tt> (see <a href="#constraintdeclarationvalidationprocess-methodlevelconstraints-definingparameterconstraints-namingparameters" title="4.5.2.2.&nbsp;Naming parameters">Section&nbsp;4.5.2.2, &#8220;Naming parameters&#8221;</a>)
              for a method or constructor parameter.</p></li><li><p>The literal <tt class="literal">&lt;cross-parameter&gt;</tt> for
              a method or constructor cross-parameter.</p></li><li><p>The literal <tt class="literal">&lt;return value&gt;</tt> for a
              method or constructor return value.</p></li></ul></div></li><li><p class="tck-testable"><tt class="methodname">isInIterable()</tt>
          returns <tt class="literal">true</tt> if the node represents an object
          contained in an <tt class="classname">Iterable</tt> or in a
          <tt class="classname">Map</tt>, <tt class="literal">false</tt>
          otherwise.</p></li><li><p class="tck-testable"><tt class="methodname">getIndex()</tt>
          returns the index of the node if it is contained in an array or
          <tt class="classname">List</tt>. Returns <tt class="literal">null</tt>
          otherwise.</p></li><li><p class="tck-testable"><tt class="methodname">getKey()</tt> returns
          the key of the node if it is contained in a
          <tt class="classname">Map</tt>. Returns <tt class="literal">null</tt>
          otherwise.</p></li><li><p class="tck-testable"><tt class="methodname">getKind()</tt> returns
          the <tt class="classname">ElementKind</tt> corresponding to the actual
          node type. This can be used in conjunction with the method
          <tt class="methodname">as()</tt> to narrow the type and access node
          specific methods</p></li><li><p class="tck-testable"><tt class="methodname">as(Class&lt;? extends
          Node&gt;)</tt> returns the node instance narrowed to the
          type passed as a parameter or
          <tt class="classname">ClassCastException</tt> if the type and node don't
          match.</p></li></ul></div><p>Nodes are of the following possible types:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">BeanNode</tt></p></li><li><p><tt class="classname">PropertyNode</tt></p></li><li><p><tt class="classname">MethodNode</tt></p></li><li><p><tt class="classname">ConstructorNode</tt></p></li><li><p><tt class="classname">ParameterNode</tt></p></li><li><p><tt class="classname">CrossParameterNode</tt></p></li><li><p><tt class="classname">ReturnValueNode</tt></p></li></ul></div><p>It is possible to narrow a node instance to its precise type and
    extract node specific information by the use of
    <tt class="methodname">Node.getKind()</tt> and <tt class="methodname">Node.as(Class&lt;?
    extends Node&gt;)</tt>. <span class="tck-testable">In particular,
    <tt class="classname">MethodNode</tt> and
    <tt class="classname">ConstructorNode</tt> host
    <tt class="methodname">getParameterTypes()</tt> which return the method or
    constructor parameter list.</span> <span class="tck-testable">Likewise
    <tt class="classname">ParameterNode</tt> hosts
    <tt class="methodname">getParameterIndex()</tt> which returns the parameter
    index in the method or constructor parameter list.</span></p><div class="example"><a name="d0e5787"></a><p class="title"><b>Example&nbsp;5.5.&nbsp;Narrow a node to its specific type</b></p><pre class="programlisting">Node node = [...];
switch ( node.getKind() ) {
case METHOD:
    MethodNode methodNode = node.as(MethodNode.class);
    methodName = methodNode.getName();
    params = methodNode.getParameterTypes().toArray( 
        new Class&lt;?&gt;[methodNode.getParameterTypes().size()] );
    break;
case CONSTRUCTOR:
    ConstructorNode constructorNode = node.as(ConstructorNode.class);
    methodName = constructorNode.getName();
    params = constructorNode.getParameterTypes().toArray( 
        new Class&lt;?&gt;[constructorNode.getParameterTypes().size()] );
    break;
case PARAMETER:
    arg = node.as(ParameterNode.class).getParameterIndex();
    break;
case CROSS_PARAMETER:
    [...]
case RETURN_VALUE:
    [...]
case PARAMETER:
    [...]
case BEAN:
    [...]
case PROPERTY:
    [...]
}</pre></div><p><tt class="classname">Path</tt> objects are built according to the
    following rules:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable">The runtime type is considered, not the
        static type. For example if a property is declared
        <tt class="classname">Collection&lt;String&gt;</tt> but its runtime type
        is <tt class="classname">ArrayList&lt;String&gt;</tt>, the property is
        considered an <tt class="classname">ArrayList&lt;String&gt;</tt>.</p></li><li><p class="tck-testable">If the failing object is the root object, a
        <tt class="classname">BeanNode</tt> with name set to null is added to the
        <tt class="classname">Path</tt>. The <tt class="classname">ElementKind</tt> of
        the node is <tt class="varname">ElementKind.BEAN</tt>.</p></li><li><p>When an association is traversed:</p><div class="itemizedlist"><ul type="circle"><li><p class="tck-testable">a <tt class="classname">PropertyNode</tt>
            object whose <tt class="literal">name</tt> equals the name of the
            association property (field name or Java Bean property name) is
            added to <tt class="classname">Path</tt>. The
            <tt class="classname">ElementKind</tt> of the node is
            <tt class="varname">ElementKind.PROPERTY</tt>.</p></li><li><p class="tck-testable">if the association is a
            <tt class="classname">List</tt> or an array, the following
            <tt class="classname">Node</tt> object added contains the index value
            in <tt class="methodname">getIndex()</tt>.</p></li><li><p class="tck-testable">if the association is a
            <tt class="classname">Map</tt>, the following
            <tt class="classname">Node</tt> object added (representing a given map
            entry) contains the key value in
            <tt class="methodname">getKey()</tt></p></li><li><p class="tck-testable">for all <tt class="classname">Iterable</tt>
            or <tt class="classname">Map</tt>, the following
            <tt class="classname">Node</tt> object added is marked as
            <tt class="literal">inIterable</tt>
            (<tt class="methodname">isInIterable()</tt>)</p></li></ul></div></li><li><p class="tck-testable">For a property level constraint (field and
        getter)</p><div class="itemizedlist"><ul type="circle"><li><p>a <tt class="classname">PropertyNode</tt> object is added to
              <tt class="classname">Path</tt> whose <tt class="literal">name</tt> equals
              the name of the property (field name or Java Bean property
              name). The <tt class="classname">ElementKind</tt> of the is
              <tt class="varname">ElementKind.PROPERTY</tt>.</p></li><li><p>the property path is considered complete</p></li></ul></div><div class="itemizedlist"><ul type="circle"><li><p>a <tt class="classname">PropertyNode</tt> object is added to
            <tt class="classname">Path</tt> whose <tt class="literal">name</tt> equals
            the name of the property (field name or Java Bean property name).
            The <tt class="classname">ElementKind</tt> of the is
            <tt class="varname">ElementKind.PROPERTY</tt>.</p></li><li><p>the property path is considered complete</p></li></ul></div></li><li><p class="tck-testable">For a class level constraint:</p><div class="itemizedlist"><ul type="circle"><li><p>a <tt class="classname">BeanNode</tt> object is added to
              <tt class="classname">Path</tt> whose <tt class="literal">name</tt> is
              null. The <tt class="classname">ElementKind</tt> of the node is
              <tt class="varname">ElementKind.BEAN</tt>.</p></li><li><p>the property path is considered complete</p></li></ul></div></li><li><p>For a method/constructor constraint (parameter, cross-parameter
        or return value constraint on a method or constructor):</p><div class="itemizedlist"><ul type="circle"><li><p class="tck-testable">a <tt class="classname">MethodNode</tt>
            respectively a <tt class="classname">ConstructorNode</tt> object is
            added to the <tt class="classname">Path</tt> which represents the
            validated method respectively constructor. The
            <tt class="literal">name</tt> of the node equals the validated method
            name or the validated constructor's unqualified class name, the
            <tt class="classname">ElementKind</tt> of the node is
            <tt class="varname">ElementKind.METHOD</tt> respectively
            <tt class="varname">ElementKind.CONSTRUCTOR</tt>.</p></li><li><p class="tck-testable">if the constraint is on a parameter, a
            <tt class="classname">ParameterNode</tt> object is added to the
            <tt class="classname">Path</tt> which represents the validated
            parameter. The <tt class="literal">name</tt> of the node equals the
            parameter name as determined by the current parameter name
            provider (see <a href="#constraintdeclarationvalidationprocess-methodlevelconstraints-definingparameterconstraints-namingparameters" title="4.5.2.2.&nbsp;Naming parameters">Section&nbsp;4.5.2.2, &#8220;Naming parameters&#8221;</a>).
            The <tt class="classname">ElementKind</tt> of the node is
            <tt class="varname">elementKind.PARAMETER</tt>.</p></li><li><p class="tck-testable">if the constraint is a cross-parameter
            constraint, a <tt class="classname">CrossParameterNode</tt> object is
            added to the <tt class="classname">Path</tt> which represents the
            validated cross-parameter element. The <tt class="literal">name</tt> of
            the node has the constant value
            <tt class="literal">&lt;cross-parameter&gt;</tt>. The
            <tt class="classname">ElementKind</tt> of the node is
            <tt class="varname">ElementKind.CROSS_PARAMETER.</tt></p></li><li><p class="tck-testable">if the constraint is on the return
            value, a <tt class="classname">ReturnValueNode</tt> object is added to
            the <tt class="classname">Path</tt> which represents the validated
            return value. The <tt class="literal">name</tt> of the node has the
            constant value <tt class="literal">&lt;return value&gt;</tt>. The
            <tt class="classname">ElementKind</tt> of the node is
            <tt class="varname">ElementKind.RETURN_VALUE.</tt></p></li><li><p class="tck-testable">the property path is considered
            complete</p></li></ul></div></li><li><p>If a parameter or the return value of a method or constructor is
        traversed:</p><div class="itemizedlist"><ul type="circle"><li><p class="tck-testable">a <tt class="classname">MethodNode</tt>
            respectively <tt class="classname">ConstructorNode</tt> object is
            added to the <tt class="classname">Path</tt> which represents the
            concerned method respectively constructor. The
            <tt class="literal">name</tt> of the node equals the concerned method
            name or the constructor's unqualified class name, the
            <tt class="classname">ElementKind</tt> of the node is
            <tt class="varname">ElementKind.METHOD</tt> or
            <tt class="varname">ElementKind.CONSTRUCTOR</tt>, respectively.</p></li><li><p class="tck-testable">if a parameter is traversed, a
            <tt class="classname">ParameterNode</tt> object is added to the
            <tt class="classname">Path</tt> which represents the traversed
            parameter. The <tt class="literal">name</tt> of the node equals the
            parameter name as determined by the current parameter name
            provider. The <tt class="classname">ElementKind</tt> of the node is
            <tt class="varname">ElementKind.PARAMETER</tt>.</p></li><li><p class="tck-testable">if a return value is traversed, a
            <tt class="classname">ReturnValueNode</tt> object is added to the
            <tt class="classname">Path</tt> which represents the traversed return
            value. The <tt class="literal">name</tt> of the node has the constant
            value <tt class="literal">&lt;return value&gt;</tt>. The
            <tt class="classname">ElementKind</tt> of the node is
            <tt class="varname">ElementKind.RETURN_VALUE.</tt></p></li><li><p class="tck-testable">if the parameter/return value is a
            <tt class="classname">List</tt> or an array, the following
            <tt class="classname">Node</tt> object added contains the index value
            in <tt class="methodname">getIndex()</tt>.</p></li><li><p class="tck-testable">if the parameter/return value is a
            <tt class="classname">Map</tt>, the following
            <tt class="classname">Node</tt> object added (representing a given map
            entry) contains the key value in
            <tt class="methodname">getKey()</tt>.</p></li><li><p class="tck-testable">for all <tt class="classname">Iterable</tt>
            or <tt class="classname">Map</tt>, the following
            <tt class="classname">Node</tt> object added is marked as
            <tt class="literal">inIterable</tt>
            (<tt class="methodname">isInIterable()</tt>).</p></li></ul></div></li></ul></div><p class="tck-testable">If additional path nodes are added in a
    constraint validator implementation using the node builder API (see <a href="#constraintsdefinitionimplementation-validationimplementation" title="3.4.&nbsp;Constraint validation implementation">Section&nbsp;3.4, &#8220;Constraint validation implementation&#8221;</a>),
    the following rules apply:</p><div class="itemizedlist"><ul type="disc"><li><p>if the default path ends with a
          <tt class="classname">BeanNode</tt>, this node is removed and the first
          added node (a <tt class="classname">PropertyNode</tt>) inherits its
          <tt class="literal">inIterable</tt>, <tt class="literal">key</tt> and
          <tt class="literal">index</tt> values. <tt class="literal">inIterable</tt>,
          <tt class="literal">key</tt> and <tt class="literal">index</tt> value must not
          be specified directly on this first node by the user.</p></li><li><p>if the default path ends with a
          <tt class="classname">CrossParameterNode</tt>, this node is
          removed.</p></li><li><p>then the additional nodes are appended to the (possibly
          amended) path generated by the Bean Validation engine as previously
          described:</p><div class="itemizedlist"><ul type="circle"><li><p class="tck-testable">A
                <tt class="classname">PropertyNode</tt> is appended in case
                <tt class="methodname">addPropertyNode(String)</tt> is invoked.
                The node name is equal to the name provided. The
                <tt class="classname">ElementKind</tt> of the node is
                <tt class="literal">ElementKind.PROPERTY</tt>.</p></li><li><p class="tck-testable">A <tt class="classname">BeanNode</tt> is
                appended in case <tt class="methodname">addBeanNode()</tt> is
                invoked. The node name is <tt class="literal">null</tt>. The
                <tt class="classname">ElementKind</tt> of the node is
                <tt class="literal">ElementKind.BEAN</tt>.</p></li><li><p class="tck-testable">A
                <tt class="classname">ParameterNode</tt> is appended in case
                <tt class="methodname">addParameterNode(int)</tt> is invoked. The
                node name is equal to the parameter name at the provided
                index. The name is determined by the current parameter name
                provider. The <tt class="classname">ElementKind</tt> of the node
                is <tt class="literal">ElementKind.PARAMETER</tt>. The previous node
                (removed) must be a
                <tt class="classname">CrossParameterNode</tt>.</p></li><li><p class="tck-testable">if
                <tt class="methodname">inIterable()</tt> is invoked, the node
                returns <tt class="literal">true</tt> for
                <tt class="methodname">isInIterable()</tt>,
                <tt class="literal">false</tt> otherwise.</p></li><li><p class="tck-testable">if
                <tt class="methodname">atIndex(Integer)</tt> is invoked, the node
                returns the provided integer for
                <tt class="methodname">getIndex()</tt>, <tt class="literal">null</tt>
                otherwise.</p></li><li><p class="tck-testable">if
                <tt class="methodname">atKey(Object)</tt> is invoked, the node
                returns the provided object for
                <tt class="methodname">getKey()</tt>, <tt class="literal">null</tt>
                otherwise.</p></li></ul></div></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A given <tt class="classname">Node</tt> object derives its
      <tt class="literal">inIterable</tt>, <tt class="literal">key</tt> and
      <tt class="literal">index</tt> properties from the previous association,
      method parameter or return value traversed.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>From <tt class="methodname">getRootBean()</tt>,
      <tt class="methodname">getPropertyPath()</tt>,
      <tt class="methodname">getExecutableParameters()</tt> and
      <tt class="methodname">getExecutableReturnValue()</tt>, it is possible to
      rebuild the context of the failure.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><tt class="classname">ConstraintViolation</tt>s occurred during
      standard bean validation can be distinguished from violations occurred
      during method/constructor validation by analyzing the
      <tt class="classname">ElementKind</tt> of the <tt class="classname">Node</tt> of
      the first node in the violation's property path. In case of constructor
      or method validation, that <tt class="classname">ElementKind</tt> will be
      either <tt class="varname">CONSTRUCTOR</tt> or
      <tt class="varname">METHOD</tt>.</p></div><p>Let there be the following object definitions:</p><div class="example"><a name="d0e6342"></a><p class="title"><b>Example&nbsp;5.6.&nbsp;Object model definition for examples</b></p><pre class="programlisting">@SecurityChecking
public class Author {
    private String firstName;
    
    @NotEmpty(message="lastname must not be null")
    private String lastName;

    @Size(max=30)
    private String company;

    [...]

    @OldAndNewPasswordsDifferent @NewPasswordsIdentical
    public void renewPassword(String oldPassword, String newPassword, String retypedNewPassword);
}

@AvailableInStore(groups={Availability.class})
public class Book {
    @NotEmpty(groups={FirstLevelCheck.class, Default.class})
    private String title;

    @Valid
    @NotNull
    private List&lt;Author&gt; authors;

    @Valid
    private Map&lt;String, Review&gt; reviewsPerSource;

    @Valid
    private Review pickedReview;

    [...]
}

public class Review {
    @Min(0) private int rating;
    [...]
}

public class Library {

    public Library(@NotNull String name, @NotNull String location) {
        [...]
    }

    public void addBook(@NotNull @Valid Book book) {
        [...]
    }

    public void addAllBooks(@NotNull @Valid List&lt;Book&gt; books) {
        [...]
    }

    @NotNull public String getLocation() {
        [...]
    }

    @Valid public Map&lt;Author, Book&gt; getMostPopularBookPerAuthor() {
        [...]
    }
}</pre></div><p>Assuming a <tt class="classname">Book</tt> instance gets validated, the
    property paths to the different constraints would be as described in <a href="#table-propertypath" title="Table&nbsp;5.1.&nbsp;propertyPath examples">Table&nbsp;5.1, &#8220;propertyPath examples&#8221;</a>:</p><div class="table"><a name="table-propertypath"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;propertyPath examples</b></p><table summary="propertyPath examples" border="1"><colgroup><col><col></colgroup><thead><tr><th>Constraint</th><th>propertyPath</th></tr></thead><tbody><tr><td><tt class="classname">@AvailableInStore</tt> on
            <tt class="classname">Book</tt></td><td><p>BeanNode(name=null,inIterable=false, index=null,
            key=null, kind=ElementKind.BEAN)</p></td></tr><tr><td><tt class="classname">@NotEmpty</tt> on
            <tt class="classname">Book.title</tt></td><td><p>PropertyNode(name=title,inIterable=false, index=null,
            key=null, kind=ElementKind.PROPERTY)</p></td></tr><tr><td><tt class="classname">@NotNull</tt> on
            <tt class="classname">Book.authors</tt></td><td><p>PropertyNode(name=authors,inIterable=false,
            index=null, key=null, kind=ElementKind.PROPERTY)</p></td></tr><tr><td><tt class="classname">@SecurityChecking</tt> on the fourth
            author, <tt class="classname">Author</tt></td><td><p>PropertyNode(name=authors,inIterable=false,
            index=null, key=null,
            kind=ElementKind.PROPERTY)</p><p>BeanNode(name=null,inIterable=true,
            index=3, key=null, kind=ElementKind.BEAN)</p></td></tr><tr><td><tt class="classname">@Size</tt> on the fourth author,
            <tt class="classname">Author.lastname</tt></td><td><p>PropertyNode(name=authors,inIterable=false,
            index=null, key=null,
            kind=ElementKind.PROPERTY)</p><p>PropertyNode(name=lastname,inIterable=true,
            index=4, key=null, kind=ElementKind.PROPERTY)</p></td></tr><tr><td><tt class="classname">@NotEmpty</tt> on the first author,
            <tt class="classname">Author.company</tt></td><td><p>PropertyNode(name=authors,inIterable=false,
            index=null, key=null,
            kind=ElementKind.PROPERTY)</p><p>PropertyNode(name=company,inIterable=true,
            index=0, key=null, kind=ElementKind.PROPERTY)</p></td></tr><tr><td><tt class="classname">@Min</tt> on the review associated to
            Consumer Report, <tt class="classname">Review.rating</tt></td><td><p>PropertyNode(name=reviewsPerSource,inIterable=false,
            index=null, key=null,
            kind=ElementKind.PROPERTY)</p><p>PropertyNode(name=rating,inIterable=true,
            index=null, key="Consumer Report",
            kind=ElementKind.PROPERTY)</p></td></tr><tr><td><tt class="classname">@Min</tt> on the picked review,
            <tt class="classname">Review.rating</tt></td><td><p>PropertyNode(name=pickedReview,inIterable=false,
            index=null, key=null,
            kind=ElementKind.PROPERTY)</p><p>PropertyNode(name=rating,inIterable=false,
            index=null, key=null, kind=ElementKind.PROPERTY)</p></td></tr></tbody></table></div><p>Assuming the constructor and methods of the
    <tt class="classname">Library</tt> class are subject to method constraint
    validation, the following property paths would exist for the different
    constraints:</p><div class="table"><a name="table-method-level-propertypath"></a><p class="title"><b>Table&nbsp;5.2.&nbsp;Property path examples for constrained methods or
        constructors</b></p><table summary="Property path examples for constrained methods or&#xA;        constructors" border="1"><colgroup><col><col></colgroup><thead><tr><th>Constraint</th><th>propertyPath</th></tr></thead><tbody><tr><td><tt class="classname">@NotNull</tt> on the <tt class="varname">location
              </tt>parameter of the constructor</td><td><p>ConstructorNode(name=Library, inIterable=false,
              index=null, key=null, kind=ElementKind.CONSTRUCTOR,
              parameterTypes=[String.class,String.class])</p><p>ParameterNode(name=arg1,
              inIterable=false, index=null, key=null,
              kind=ElementKind.PARAMETER, parameterIndex=1)</p></td></tr><tr><td><tt class="classname">@NotNull </tt>on the <tt class="varname">book
              </tt>parameter of the <tt class="methodname">addBook()</tt>
              method</td><td><p>MethodNode(name=addBook, inIterable=false,
              index=null, key=null, kind=ElementKind.METHOD,
              parameterTypes=[Book.class])</p><p>ParameterNode(name=arg0,
              inIterable=false, index=null, key=null,
              kind=ElementKind.PARAMETER, parameterIndex=0)</p></td></tr><tr><td><tt class="classname">@NotEmpty</tt> on
              <tt class="classname">Book.title</tt> during validation of
              <tt class="methodname">addBook()</tt></td><td><p>MethodNode(name=addBook, inIterable=false,
              index=null, key=null, kind=ElementKind.METHOD,
              parameterTypes=[Book.class])</p><p>ParameterNode(name=arg0,
              inIterable=false, index=null, key=null,
              kind=ElementKind.PARAMETER,
              parameterIndex=0)</p><p>PropertyNode(name=title,
              inIterable=false, index=null, key=null,
              kind=ElementKind.PROPERTY)</p></td></tr><tr><td><tt class="classname">@NotEmpty</tt> on fourth book,
              <tt class="classname">Book.title</tt> during validation of
              <tt class="methodname">addAllBooks()</tt></td><td><p>MethodNode(name=addAllBooks, inIterable=false,
              index=null, key=null, kind=ElementKind.METHOD,
              parameterTypes=[List.class])</p><p>ParameterNode(name=arg0,
              inIterable=false, index=null, key=null,
              kind=ElementKind.PARAMETER,
              parameterIndex=0)</p><p>PropertyNode(name=title,inIterable=true,
              index=3, key=null, kind=ElementKind.PROPERTY)</p></td></tr><tr><td><tt class="classname">@NotNull</tt> on the return value of
              the <tt class="methodname">getLocation()</tt> method</td><td><p>MethodNode(name=getLocation, inIterable=false,
              index=null, key=null, kind=ElementKind.METHOD,
              parameterTypes=[])</p><p>ReturnValueNode(name=&lt;return
              value&gt;, inIterable=false, index=null, key=null,
              kind=ElementKind.RETURN_VALUE)</p></td></tr><tr><td><tt class="classname">@NotEmpty</tt> on most popular book of
              author "John Doe", <tt class="classname">Book.title</tt> during
              validation of
              <tt class="methodname">getMostPopularBookPerAuthor()</tt></td><td><p>MethodNode(name=getMostPopularBookPerAuthor,
              inIterable=false, index=null, key=null, kind=ElementKind.METHOD,
              parameterTypes=[])</p><p>ReturnValueNode(name=&lt;return
              value&gt;, inIterable=false, index=null, key=null,
              kind=ElementKind.RETURN_VALUE)</p><p>PropertyNode(name=title,inIterable=true,
              index=null, key=Author(firstName=John, lastName=Doe),
              kind=ElementKind.PROPERTY)</p></td></tr><tr><td><tt class="classname">@OldAndNewPasswordsDifferent</tt> when
              executing <tt class="methodname">Author.renewPassword()</tt> with
              <tt class="literal">oldPassword</tt>, <tt class="literal">newPassword</tt>
              and <tt class="literal">retypedNewPassword</tt> set to "foo".
              <tt class="classname">@OldAndNewPasswordsDifferent</tt> is a
              cross-parameter constraint.</td><td><p>MethodNode(name=renewPassword, inIterable=false,
              index=null, key=null, kind=ElementKind.METHOD,
              parameterTypes=[String.class, String.class,
              String.class])</p><p>CrossParameterNode(name=&lt;cross-parameter&gt;,
              inIterable=false, index=null, key=null,
              kind=ElementKind.CROSS_PARAMETER)</p></td></tr><tr><td><tt class="classname">@NewPasswordsIdentical</tt> when
              executing <tt class="methodname">Author.renewPassword()</tt> with
              <tt class="literal">oldPassword</tt> as "foo",
              <tt class="literal">newPassword</tt> as "bar" and
              <tt class="literal">retypedNewPassword</tt> as "baz".
              <tt class="classname">@NewPasswordsIdentical</tt> is a
              cross-parameter constraint creating a constraint violation on
              the <tt class="literal">retypedNewPassword</tt> parameter.</td><td><p>MethodNode(name=renewPassword, inIterable=false,
              index=null, key=null, kind=ElementKind.METHOD,
              parameterTypes=[String.class, String.class,
              String.class])</p><p>ParameterNode(name=arg2,
              inIterable=false, index=null, key=null,
              kind=ElementKind.PARAMETER, parameterIndex=2)</p></td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p class="tck-not-testable">Bean Validation implementations should
      ensure that a <tt class="classname">ConstraintViolation</tt> implementation
      is <tt class="classname">Serializable</tt> provided that the root bean, the
      leaf bean, the invalid value and keys in the <tt class="classname">Path</tt>
      object are <tt class="classname">Serializable</tt> objects.</p><p>If a user wishes to send
      <tt class="classname">ConstraintViolation</tt> remotely, it should make sure
      the object graph validated is itself
      <tt class="classname">Serializable</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6641"></a>5.2.1.&nbsp;Examples</h3></div></div><div></div></div><p>These examples assume the following definition of
      <tt class="classname">@NotEmpty</tt>.</p><pre class="programlisting">package com.acme.constraint;

@Documented
@NotNull
@Size(min=1)
@ReportAsSingleViolation
@Constraint(validatedBy = NotEmpty.NotEmptyValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface NotEmpty {
    String message() default "{com.acme.constraint.NotEmpty.message}"
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        NotEmpty[] value();
    }

    class NotEmptyValidator implements ConstraintValidator&lt;NotEmpty, String&gt; {
        public void initialize(NotEmpty constraintAnnotation) {}

        public boolean isValid(String value, ConstraintValidatorContext context) {
            return true;
        }
    }
}</pre><p>and the following class definitions</p><pre class="programlisting">public class Author {
    private String firstName;
    
    @NotEmpty(message="lastname must not be null")
    private String lastName;

    @Size(max=30)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}

public class Book {
    @NotEmpty(groups={FirstLevelCheck.class, Default.class})
    private String title;

    @Valid
    @NotNull
    private Author author;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }
}

Author author = new Author();
author.setCompany("ACME");
Book book = new Book();
book.setTitle("");
book.setAuthor(author);

Set&lt;ConstraintViolation&gt; constraintViolations = validator.validate(book);</pre><p><tt class="classname">ConstraintViolations</tt> is a set of size 2.
      One of the entries represents the failure of
      <tt class="literal">@NotEmpty</tt> (or more precisely
      <tt class="classname">@Size(min=1)</tt> a composing constraint of
      <tt class="classname">@NotEmpty</tt>) on the <tt class="literal">title</tt>
      property.</p><p>The <tt class="classname">ConstraintViolation</tt> object for this
      failure passes the following assertions:</p><div class="example"><a name="d0e6676"></a><p class="title"><b>Example&nbsp;5.7.&nbsp;Test assertions on ContraintViolation</b></p><pre class="programlisting">//assuming an english locale, the interpolated message is returned
assert "may not be null or empty".equals( constraintViolation.getMessage() );
assert book == constraintViolation.getRootBean();
assert book == constraintViolation.getLeafBean();

//the offending value
assert book.getTitle().equals( constraintViolation.getInvalidValue() );

//the offending property
Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();
Node node = nodeIter.next();
assert "title".equals( node.getName() );
assert ElementKind.PROPERTY.equals( node.getKind() );

assert false == nodeIter.hasNext();</pre></div><p>The second failure, <tt class="literal">@NotEmpty</tt> (or more
      precisely <tt class="classname">@NotNull</tt> a composing constraint of
      <tt class="classname">@NotEmpty</tt>) on the author's
      <tt class="methodname">lastname</tt>, will produce the
      <tt class="classname">ConstraintViolation</tt> object satisfying the
      following assertions:</p><pre class="programlisting">assert "lastname must not be null".equals( constraintViolation.getMessage() );
assert book == constraintViolation.getRootBean();
assert author == constraintViolation.getLeafBean();

//the offending value
assert book.getAuthor().getLastName() == constraintViolation.getInvalidValue();

//the offending property
Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "author".equals( node.getName() );
assert ElementKind.PROPERTY.equals( node.getKind() );

node = nodeIter.next();
assert "lastName".equals( node.getName() );
assert ElementKind.PROPERTY.equals( node.getKind() );

assert false == nodeIter.hasNext();</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6700"></a>5.2.2.&nbsp;Examples for method and constructor constraint violations</h3></div></div><div></div></div><p>The following examples assume the constraint, class and object
      definitions given in the previous section. Additionally the following
      class and object definitions are assumed:</p><pre class="programlisting">public class Library {

    @PublicLibrary
    public Library() {
        [...]
    }

    public Library(@NotNull @Valid List&lt;Book&gt; books) {
        [...]
    }

    public void addBook(@NotNull @Valid Book book) {
        [...]
    }

    @Valid public Map&lt;Author, Book&gt; getMostPopularBookPerAuthor() {
        [...]
    }
}

public class User {

    @OldAndNewPasswordsDifferent
    public void renewPassword(String oldPassword, String newPassword, String retypedNewPassword);
}

Library library = new Library();
author.setLastName("Doe");</pre><p>Assuming the following invocation of
      <tt class="methodname">addBook()</tt> is subject to method parameter
      validation:</p><pre class="programlisting">library.addBook(null);</pre><p>Then one <tt class="classname">ConstraintViolation</tt> object would
      be returned by
      <tt class="methodname">ExecutableValidator.validateParameters()</tt> which
      satisfies the following assertions:</p><pre class="programlisting">//assuming an english locale, the interpolated message is returned
assert "may not be null".equals( constraintViolation.getMessage() );

assert library == constraintViolation.getRootBean();
assert Library.class == constraintViolation.getRootBeanClass();
assert library == constraintViolation.getLeafBean();
assert null == constraintViolation.getInvalidValue();

assert new Object[]{ null }.equals( constraintViolation.getExecutableParameters() );
assert null == constraintViolation.getExecutableReturnValue();

Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "addBook".equals( node.getName() );
assert ElementKind.METHOD.equals( node.getKind() );

node = nodeIter.next();
//assuming the default parameter name provider is used
assert "arg0".equals( node.getName() );
assert ElementKind.PARAMETER.equals( node.getKind() );

assert false == nodeIter.hasNext();</pre><p>Assuming the following invocation of
      <tt class="methodname">addBook()</tt> is subject to method parameter
      validation:</p><pre class="programlisting">library.addBook(book);</pre><p>Then one <tt class="classname">ConstraintViolation</tt> object would
      be returned by
      <tt class="methodname">ExecutableValidator.validateParameters()</tt> which
      satisfies the following assertions:</p><pre class="programlisting">//assuming an english locale, the interpolated message is returned
assert "may not be null or empty".equals( constraintViolation.getMessage() );

assert library == constraintViolation.getRootBean();
assert Library.class == constraintViolation.getRootBeanClass();
assert book == constraintViolation.getLeafBean();
assert book.getTitle().equals( constraintViolation.getInvalidValue() );

assert new Object[]{ book }.equals( constraintViolation.getExecutableParameters() );
assert null == constraintViolation.getExecutableReturnValue();

Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "addBook".equals( node.getName() );
assert ElementKind.METHOD.equals( node.getKind() );

node = nodeIter.next();
//assuming the default parameter name provider is used
assert "arg0".equals( node.getName() );
assert ElementKind.PARAMETER.equals( node.getKind() );

node = nodeIter.next();
assert "title".equals( node.getName() );
assert ElementKind.PROPERTY.equals( node.getKind() );

assert false == nodeIter.hasNext();</pre><p>Assuming the following invocation of
      <tt class="methodname">User.renewPassword()</tt> is subject to method
      parameter validation and the
      <tt class="classname">@OldAndNewPasswordsDifferent</tt> constraint is
      violated:</p><pre class="programlisting">User user = [...];
user.renewPassword("foo", "foo", "foo");</pre><p>Then one <tt class="classname">ConstraintViolation</tt> object would
      be returned by
      <tt class="methodname">ExecutableValidator.validateParameters()</tt> which
      satisfies the following assertions:</p><pre class="programlisting">assert user == constraintViolation.getRootBean();
assert User.class == constraintViolation.getRootBeanClass();
assert user == getLeafBean();
assert new Object[]{ "foo", "foo", "foo" }.equals( constraintViolation.getInvalidValue() );

assert new Object[]{ "foo", "foo", "foo" }.equals( constraintViolation.getExecutableParameters() );
assert null == constraintViolation.getExecutableReturnValue();

Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "renewPassword".equals( node.getName() );
assert ElementKind.METHOD.equals( node.getKind() );

node = nodeIter.next();
assert "&lt;cross-parameter&gt;" == node.getName();
assert ElementKind.CROSS_PARAMETER.equals( node.getKind() );

assert false == nodeIter.hasNext();</pre><p>Assuming the following invocation of the
      <tt class="classname">Library</tt> constructor accepting a list of books is
      subject to constructor parameter validation:</p><pre class="programlisting">Library anotherLibrary = new Library(null);</pre><p>Then one <tt class="classname">ConstraintViolation</tt> object would
      be returned by
      <tt class="methodname">ExecutableValidator.validateConstructorParameters()</tt>
      which satisfies the following assertions:</p><pre class="programlisting">//assuming an english locale, the interpolated message is returned
assert "may not be null".equals( constraintViolation.getMessage() );

assert null == constraintViolation.getRootBean();
assert Library.class == constraintViolation.getRootBeanClass();
assert null == constraintViolation.getLeafBean();
assert null == constraintViolation.getInvalidValue();

assert new Object[]{ null }.equals( constraintViolation.getExecutableParameters() );
assert null == constraintViolation.getExecutableReturnValue();

Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "Library".equals( node.getName() );
assert ElementKind.CONSTRUCTOR.equals( node.getKind() );

node = nodeIter.next();
//assuming the default parameter name provider is used
assert "arg0".equals( node.getName() );
assert ElementKind.PARAMETER.equals( node.getKind() );

assert false == nodeIter.hasNext();</pre><p>Assuming the following invocation of
      <tt class="methodname">getMostPopularBookPerAuthor()</tt> is subject to
      method return value validation and returns a <tt class="classname">Map</tt>
      containing one entry with key <tt class="varname">author</tt> and value
      <tt class="varname">book</tt>:</p><pre class="programlisting">Map&lt;Author, Book&gt; mostPopularBookPerAuthor = library.getMostPopularBookPerAuthor();</pre><p>Then one <tt class="classname">ConstraintViolation</tt> object would
      be returned by
      <tt class="methodname">ExecutableValidator.validateReturnValue()</tt> which
      satisfies the following assertions:</p><pre class="programlisting">//assuming an english locale, the interpolated message is returned
assert "may not be null or empty".equals( constraintViolation.getMessage() );

assert library == constraintViolation.getRootBean();
assert Library.class == constraintViolation.getRootBeanClass();
assert book == constraintViolation.getLeafBean();
assert book.getTitle().equals( constraintViolation.getInvalidValue() );

assert null == constraintViolation.getExecutableParameters();
assert mostPopularBookPerAuthor == constraintViolation.getExecutableReturnValue();

Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "getMostPopularBookPerAuthor".equals( node.getName() );
assert ElementKind.METHOD.equals( node.getKind() );

node = nodeIter.next();
assert "&lt;return value&gt;" == node.getName();
assert ElementKind.RETURN_VALUE.equals( node.getKind() );

node = nodeIter.next();
assert "title".equals( node.getName() );
assert ElementKind.PROPERTY.equals( node.getKind() );
assert author.equals( node.getKey() );
assert true == node.isInIterable();

assert false == nodeIter.hasNext();</pre><p>Assuming the following invocation of the
      <tt class="classname">Library</tt> default constructor is subject to
      constructor return value validation and returns an instance which
      violates the <tt class="classname">@PublicLibrary</tt> constraint:</p><pre class="programlisting">Library publicLibrary = new Library();</pre><p>Then one <tt class="classname">ConstraintViolation</tt> object would
      be returned by
      <tt class="methodname">ExecutableValidator.validateConstructorReturnValue()</tt>
      which satisfies the following assertions:</p><pre class="programlisting">assert null == constraintViolation.getRootBean();
assert Library.class == constraintViolation.getRootBeanClass();
assert publicLibrary == constraintViolation.getLeafBean();
assert publicLibrary == constraintViolation.getInvalidValue();

assert null == constraintViolation.getExecutableParameters();
assert library == constraintViolation.getExecutableReturnValue();

Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "Library".equals( node.getName() );
assert ElementKind.CONSTRUCTOR.equals( node.getKind() );

node = nodeIter.next();
assert "&lt;return value&gt;" == node.getName();
assert ElementKind.RETURN_VALUE.equals( node.getKind() );

assert false == nodeIter.hasNext();</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validationapi-message"></a>5.3.&nbsp;Message interpolation</h2></div></div><div></div></div><p>A message interpolator is responsible for transforming the so called
    message descriptor specified via the message attribute of the constraint
    into a fully expanded, human-readable error message.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="default-messageresolver"></a>5.3.1.&nbsp;Default message interpolation</h3></div></div><div></div></div><p><span class="tck-testable">Every conforming Bean Validation
      implementation includes a default message interpolator which has to
      comply with </span>the algorithm defined here to interpolate message
      descriptors. As precondition for message interpolation the following
      applies:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable">Each constraint defines a message
          descriptor via its <tt class="methodname">message</tt> property.</p></li><li><p class="tck-testable">Every constraint definition defines a
          default message descriptor for that constraint.</p></li><li><p class="tck-testable">Messages can be overridden at constraint
          declaration time by setting the <tt class="methodname">message</tt>
          property on the constraint.</p></li></ul></div><p><span class="tck-testable">The message descriptor is a string
      literal and may contain one or more message parameters or expressions.
      Message parameters and expressions are string literals enclosed in
      <tt class="constant">{}</tt> or <tt class="constant">${}</tt>
      respectively.</span> The following character escaping rules
      apply:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable"><tt class="code">\{</tt> is considered as the
          literal <tt class="literal">{</tt> instead of being considered as the
          beginning of a message parameter</p></li><li><p class="tck-testable"><tt class="code">\}</tt> is considered as the
          literal <tt class="literal">}</tt> instead of being considered as the end
          of a message parameter</p></li><li><p class="tck-testable"><tt class="code">\\</tt> is considered as the
          literal <tt class="literal">\</tt> instead of being considered as the
          escaping character</p></li><li><p class="tck-testable"><tt class="code">\$</tt> is considered as the
          literal <tt class="literal">$</tt> instead of being considered as the
          beginning of a message expression</p></li></ul></div><p>Below are two examples using message parameters and expressions.
      The second is evaluated using Expression Language as defined in <a href="#message-expressions" title="5.3.1.3.&nbsp;Message expressions using Expression Language (EL)">Section&nbsp;5.3.1.3, &#8220;Message expressions using Expression Language (EL)&#8221;</a>.</p><div class="example"><a name="d0e6899"></a><p class="title"><b>Example&nbsp;5.8.&nbsp;Message using parameters</b></p><pre class="programlisting">Value must be between {min} and {max}</pre></div><div class="example"><a name="d0e6904"></a><p class="title"><b>Example&nbsp;5.9.&nbsp;Message using expressions</b></p><pre class="programlisting">Must be greater than ${inclusive == true ? 'or equal to ' : ''}{value}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="default-resolution-algorithm"></a>5.3.1.1.&nbsp;Default message interpolation algorithm</h4></div></div><div></div></div><p>The default message interpolator uses the following
        steps:</p><div class="orderedlist"><ol type="1"><li><p><span class="tck-testable">Message parameters are extracted
            from the message string and used as keys to search the
            <tt class="classname">ResourceBundle</tt> named
            <tt class="literal">ValidationMessages</tt></span> (often materialized
            as the property file
            <tt class="filename">/ValidationMessages.properties</tt> and its locale
            variations) using the defined locale (see <a href="#message-interpolation-default-locale" title="5.3.1.2.&nbsp;Locale for default message interpolation">Section&nbsp;5.3.1.2, &#8220;Locale for default message interpolation&#8221;</a>). If a property
            is found, the message parameter is replaced with the property
            value in the message string. <span class="tck-testable">Step 1 is
            applied recursively until no replacement is performed</span>
            (i.e. a message parameter value can itself contain a message
            parameter).</p></li><li><p><span class="tck-testable">Message parameters are extracted
            from the message string and used as keys to search the Bean
            Validation provider's built-in
            <tt class="classname">ResourceBundle</tt> using the defined locale
            (see <a href="#message-interpolation-default-locale" title="5.3.1.2.&nbsp;Locale for default message interpolation">Section&nbsp;5.3.1.2, &#8220;Locale for default message interpolation&#8221;</a>). If a
            property is found, the message parameter is replaced with the
            property value in the message string.</span> <span class="tck-not-testable">Contrary to step 1, step 2 is not
            processed recursively.</span></p></li><li><p><span class="tck-not-testable">If step 2 triggers a
            replacement, then step 1 is applied again.</span> Otherwise step
            4 is performed.</p></li><li><p class="tck-testable">Message parameters are extracted from
            the message string. Those matching the name of an attribute of the
            constraint are replaced by the value of that attribute in the
            constraint declaration. Parameter interpolation has precedence
            over message expressions. For example for the message descriptor
            <tt class="constant">${value}</tt>, trying to evaluate
            <tt class="constant">{value}</tt> as message parameter has precedence
            over evaluating <tt class="constant">${value} </tt>as message
            expression.</p></li><li><p class="tck-testable">Message expressions are extracted from
            the message string and evaluated using Expression Language. See
            also <a href="#message-expressions" title="5.3.1.3.&nbsp;Message expressions using Expression Language (EL)">Section&nbsp;5.3.1.3, &#8220;Message expressions using Expression Language (EL)&#8221;</a>.</p></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The proposed algorithm ensures that custom resource bundle
          always have priority over built-in resource bundle at all level of
          the recursive resolution. It also ensures that constraint
          declarations attributes values are not interpolated further.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The precedence of message parameter over expression
          interpolation ensures backwards compatibility to Bean Validation
          1.0.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="message-interpolation-default-locale"></a>5.3.1.2.&nbsp;Locale for default message interpolation</h4></div></div><div></div></div><p>The locale to be used for message interpolation is defined as
        following:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable">if the locale is passed explicitly to
              the interpolator method via <tt class="methodname">interpolate(String,
              Context, Locale)</tt>, this provided instance is
              used.</p></li><li><p class="tck-testable">otherwise, the default
              <tt class="classname">Locale</tt> as provided by
              <tt class="methodname">Locale.getDefault()</tt> is used.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="message-expressions"></a>5.3.1.3.&nbsp;Message expressions using Expression Language (EL)</h4></div></div><div></div></div><p><span class="tck-testable">The default message interpolation
        allows the use of Expression Language (EL) as defined in JSR
        341.</span> <span class="tck-testable">Expressions to be evaluated
        by EL need to be enclosed in <tt class="constant">${}</tt> within the
        message descriptor</span>. The following properties and beans have
        to be made available in the EL context:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable">the attribute values of the constraint
            declaration mapped to their attribute name</p></li><li><p class="tck-testable">the validated value mapped under the
            name <tt class="constant">validatedValue</tt>.</p></li><li><p class="tck-testable">a bean mapped to the name
            <tt class="constant">formatter</tt> exposing the vararg method
            <tt class="methodname">format(String format, Object... args)</tt>.
            This method must behave like
            <tt class="methodname">java.util.Formatter.format(String format, Object...
            args)</tt>. The locale used for formatting is defined by
            <a href="#message-interpolation-default-locale" title="5.3.1.2.&nbsp;Locale for default message interpolation">Section&nbsp;5.3.1.2, &#8220;Locale for default message interpolation&#8221;</a>. The
            <tt class="constant">formatter</tt> bean allows to format property
            values, for example in the case of the validated value being
            98.12345678, <tt class="constant">${formatter.format('%1$.2f',
            validatedValue)}</tt> would format it to 98.12 (two digits
            after the decimal point, where the use of '.' vs ',' would be
            locale specific).</p></li></ul></div><p class="tck-testable">If an exception occurs during message
        interpolation, e.g. due invalid expressions or references to an
        unknown property, the message expression stays unchanged.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-message-resolution"></a>5.3.2.&nbsp;Custom message interpolation</h3></div></div><div></div></div><p>A custom message interpolator may be provided (e.g., to
      interpolate contextual data, or to adjust the default <tt class="classname">Locale
      </tt>used). A message interpolator implements the
      <tt class="classname">MessageInterpolator</tt> interface.</p><pre class="programlisting">/**
 * Interpolates a given constraint violation message.
 * &lt;p/&gt;
 * Implementations should be as tolerant as possible on syntax errors.
 * Implementations must be thread-safe.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface MessageInterpolator {

    /**
     * Interpolates the message template based on the constraint validation context.
     * &lt;p/&gt;
     * The locale is defaulted according to the {@code MessageInterpolator}
     * implementation. See the implementation documentation for more detail.
     *
     * @param messageTemplate the message to interpolate
     * @param context contextual information related to the interpolation
     *
     * @return interpolated error message
     */
    String interpolate(String messageTemplate, Context context);

    /**
     * Interpolates the message template based on the constraint validation context.
     * The {@code Locale} used is provided as a parameter.
     *
     * @param messageTemplate the message to interpolate
     * @param context contextual information related to the interpolation
     * @param locale the locale targeted for the message
     *
     * @return interpolated error message
     */
    String interpolate(String messageTemplate, Context context,  Locale locale);

    /**
     * Information related to the interpolation context.
     */
    interface Context {
        /**
         * @return {@link ConstraintDescriptor} corresponding to the constraint being validated
         */
        ConstraintDescriptor&lt;?&gt; getConstraintDescriptor();

        /**
         * @return value being validated
         */
        Object getValidatedValue();

        /**
         * Returns an instance of the specified type allowing access to
         * provider-specific APIs. If the Bean Validation provider
         * implementation does not support the specified class,
         * {@link ValidationException} is thrown.
         *
         * @param type the class of the object to be returned
         * @return an instance of the specified class
         * @throws ValidationException if the provider does not support the call
         *
         * @since 1.1
         */
        &lt;T&gt; T unwrap(Class&lt;T&gt; type);
    }
}</pre><p class="tck-testable"><i class="parameter"><tt>messageTemplate</tt></i> is the
      value of the <tt class="literal">message</tt> attribute of the constraint
      declaration or provided to the
      <tt class="classname">ConstraintValidatorContext</tt> methods.</p><p>The <tt class="classname">Context</tt> object contains contextual
      information related to the interpolation.</p><p class="tck-testable"><tt class="methodname">getConstraintDescriptor()</tt>
      returns the <tt class="classname">ConstraintDescriptor</tt> object
      representing the metadata of the failing constraint (see <a href="#constraintmetadata" title="Chapter&nbsp;6.&nbsp;Constraint metadata request APIs">Chapter&nbsp;6, <i>Constraint metadata request APIs</i></a>).</p><p class="tck-testable"><tt class="methodname">getValidatedValue()</tt>
      returns the value being validated.</p><p><tt class="methodname">MessageInterpolator.interpolate(String,
      Context)</tt> is invoked for each constraint violation report
      generated. The default <tt class="classname">Locale</tt> is implementation
      specific.</p><p><tt class="methodname">MessageInterpolator.interpolate(String, Context,
      Locale)</tt> can be invoked by a wrapping
      <tt class="classname">MessageInterpolator</tt> to enforce a specific
      <tt class="classname">Locale</tt> value by bypassing or overriding the
      default <tt class="classname">Locale</tt> strategy (see <a href="#validationapi-message-examples-specificlocale" title="Example&nbsp;5.10.&nbsp;Use MessageInterpolator to use a specific Locale value">Example&nbsp;5.10, &#8220;Use MessageInterpolator to use a specific Locale value&#8221;</a>).</p><p class="tck-not-testable">A message interpolator implementation must
      be thread-safe.</p><p>The message interpolator is provided to the
      <tt class="classname">ValidatorFactory</tt> at construction time using
      <tt class="methodname">Configuration.messageInterpolator(MessageInterpolator)</tt>.
      This message interpolator is shared by all
      <tt class="classname">Validator</tt> objects generated by this
      <tt class="classname">ValidatorFactory</tt>.</p><p class="tck-testable">It is possible to override the
      <tt class="classname">MessageInterpolator</tt> implementation for a given
      <tt class="classname">Validator</tt> instance by invoking
      <tt class="methodname">ValidatorFactory.usingContext().messageInterpolator(messageInterpolator).getValidator()</tt>.</p><p>It is recommended that <tt class="classname">MessageInterpolator</tt>
      implementations delegate final interpolation to the Bean Validation
      default <tt class="classname">MessageInterpolator</tt> to ensure standard
      Bean Validation interpolation rules are followed, <span class="tck-testable">The default implementation is accessible through
      <tt class="methodname">Configuration.getDefaultMessageInterpolator()</tt>.</span></p><p class="tck-testable">If the interpolation process leads to an
      exception, the exception is wrapped into a
      <tt class="classname">ValidationException</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="validationapi-message-examples"></a>5.3.3.&nbsp;Examples</h3></div></div><div></div></div><p>These examples describe message interpolation based on the default
      message interpolator's built-in messages (see <a href="#standard-resolver-messages" title="Appendix&nbsp;B.&nbsp;Standard ResourceBundle messages">Appendix&nbsp;B, <i>Standard ResourceBundle messages</i></a>), and the
      <tt class="filename">ValidationMessages.properties</tt> file shown in table
      <a href="#table-messageinterpolation" title="Table&nbsp;5.3.&nbsp;message interpolation">Table&nbsp;5.3, &#8220;message interpolation&#8221;</a>. The current locale is
      assumed English.</p><pre class="programlisting">//ValidationMessages.properties
myapp.creditcard.error=credit card number not valid</pre><div class="table"><a name="table-messageinterpolation"></a><p class="title"><b>Table&nbsp;5.3.&nbsp;message interpolation</b></p><table summary="message interpolation" border="1"><colgroup><col align="center"><col></colgroup><tbody><tr><td align="center">Failing constraint declaration</td><td>interpolated message</td></tr><tr><td align="center"><tt class="classname">@NotNull</tt></td><td>must not be null</td></tr><tr><td align="center"><tt class="classname">@Max(30)</tt></td><td>must be less than or equal to 30</td></tr><tr><td align="center"><tt class="classname">@Size(min=5, max=15, message="Key must have
              \\{{min}\\} \\ \\{{max}\\} characters")</tt></td><td>Key must have {5} \ {15} characters</td></tr><tr><td align="center"><tt class="classname">@Digits(integer=9,
              fraction=2)</tt></td><td>numeric value out of bounds (&lt;9 digits&gt;.&lt;2
              digits&gt; expected)</td></tr><tr><td align="center"><tt class="classname">@CreditCard(message={myapp.creditcard.error})</tt></td><td>credit card number not valid</td></tr></tbody></table></div><p>Here is an approach to specify the <tt class="classname">Locale</tt>
      value to choose on a given <tt class="classname">Validator</tt>.
      <tt class="classname">Locale</tt> aware
      <tt class="classname">MessageInterpolator</tt>. See <a href="#bootstrapping" title="5.5.&nbsp;Bootstrapping">Section&nbsp;5.5, &#8220;Bootstrapping&#8221;</a> for more details on the APIs.</p><div class="example"><a name="validationapi-message-examples-specificlocale"></a><p class="title"><b>Example&nbsp;5.10.&nbsp;Use MessageInterpolator to use a specific Locale value</b></p><pre class="programlisting">/**
 * Delegates to a MessageInterpolator implementation but enforces a given Locale
 */
public class LocaleSpecificMessageInterpolator implements MessageInterpolator {
    private final MessageInterpolator defaultInterpolator;
    private final Locale defaultLocale;

    public LocaleSpecificMessageInterpolator(MessageInterpolator interpolator, Locale locale) {
        this.defaultLocale = locale;
        this.defaultInterpolator = interpolator;
    }

    /**
     * enforces the locale passed to the interpolator
     */
    public String interpolate(String message, 
                              Context context) {
        return defaultInterpolator.interpolate(message, 
                                               context, 
                                               this.defaultLocale);
    }

    // no real use, implemented for completeness
    public String interpolate(String message,
                              Context context,
                              Locale locale) {
        return defaultInterpolator.interpolate(message, context, locale);
    }
}


Locale locale = getMyCurrentLocale();
MessageInterpolator interpolator = new LocaleSpecificMessageInterpolator(
                                       validatorFactory.getMessageInterpolator(),
                                       locale);

Validator validator = validatorFactory.usingContext()
                                      .messageInterpolator(interpolator)
                                      .getValidator();</pre></div><p>Most of the time, however, the relevant
      <tt class="classname">Locale</tt> will be provided by your application
      framework transparently. This framework will implement its own version
      of <tt class="classname">MessageInterpolator</tt> and pass it during the
      <tt class="classname">ValidatorFactory</tt> configuration. The application
      will not have to set the <tt class="classname">Locale</tt> itself. This
      example shows how a container framework would implement
      <tt class="classname">MessageInterpolator</tt> to provide a user specific
      default locale.</p><div class="example"><a name="validationapi-message-examples-jsflocale"></a><p class="title"><b>Example&nbsp;5.11.&nbsp;Contextual container possible
        <tt class="classname">MessageInterpolator</tt> implementation</b></p><pre class="programlisting">public class ContextualMessageInterpolator implements MessageInterpolator {
    private final MessageInterpolator delegate;

    public ContextualMessageInterpolator(MessageInterpolator delegate) { 
        this.delegate = delegate; 
    }

    public String interpolate(String message, Context context) {
        Locale locale = Container.getManager().getUserLocale();
        return this.delegate.interpolate(
                        message, context, locale );
    }

    public String interpolate(String message, Context context, Locale locale) {
        return this.delegate.interpolate(message, context, locale);
    }
}


//Build the ValidatorFactory
Configuration&lt;?&gt; configuration = Validation.byDefaultProvider().configure();
ValidatorFactory factory = configuration
    .messageInterpolator( 
        new ContextualMessageInterpolator( 
                configuration.getDefaultMessageInterpolator() ) )
    .buildValidatorFactory();

//The container uses the factory to validate constraints using the specific MessageInterpolator
Validator validator = factory.getValidator();</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validationapi-triggeringmethodvalidation"></a>5.4.&nbsp;Triggering method validation</h2></div></div><div></div></div><p>Bean Validation itself doesn't trigger the evaluation of method
    constraints. That is, just annotating any methods or constructors with
    parameter or return value constraints doesn't automatically enforce these
    constraints, just as annotating any fields or properties with bean
    constraints doesn't enforce these either.</p><p>Instead method constraints must be validated by invoking the
    appropriate methods on
    <tt class="classname">javax.validation.executable.ExecutableValidator</tt>.
    Typically this won't happen by manually calling these methods but rather
    automatically upon invocation of the constrained methods or constructors,
    using approaches and techniques such as CDI/EJB interceptors,
    aspect-oriented programming or dynamic proxies.</p><p class="tck-testable">The validation of method / constructor
    constraints comprises the following steps:</p><div class="itemizedlist"><ul type="disc"><li><p>Intercept the method call to be validated</p></li><li><p>Validate the parameter values provided by the method caller
          using
          <tt class="methodname">ExecutableValidator.validateParameters()</tt> or
          <tt class="methodname">ExecutableValidator.validateConstructorParameters()</tt>.</p></li><li><p>If this validation yields a non-empty set of constraint
          violations, throw a
          <tt class="classname">ConstraintViolationException</tt> wrapping the
          violations. Otherwise proceed with the actual method
          invocation.</p></li><li><p>Validate the result returned by the invoked method using
          <tt class="methodname">ExecutableValidator.validateReturnValue()</tt>
          or
          <tt class="methodname">ExecutableValidator.validateConstructorReturnValue()</tt>.</p></li><li><p>If this validation yields a non-empty set of constraint
          violations, throw a
          <tt class="classname">ConstraintViolationException</tt> wrapping the
          violations. Otherwise return the invocation result to the method
          caller.</p></li></ul></div><p>By throwing a <tt class="classname">ConstraintViolationException</tt> if
    either of the validation steps fails, it is ensured that the control
    flow</p><div class="itemizedlist"><ul type="disc"><li><p>only arrives at the method's body if the caller has satisfied
        the method's preconditions and</p></li><li><p>only returns to the method caller if the method's postconditions
        are guaranteed.</p></li></ul></div><p>By default, integrators intercept and validate methods hosting
    either a constraint or being marked for cascaded validation
    (<tt class="classname">@Valid</tt>) whether it be on the method itself or on
    any of its parameters. <span class="tck-testable">The
    <tt class="classname">Default</tt> group is used for validation out of the
    box.</span></p><p>Integrators are encouraged to use Bean Validation's metadata API to
    find whether or not a method or a constructor should be intercepted. This
    guarantees that XML descriptors as well as future mapping strategies are
    taken into account. Note that the metadata API does not take into account
    the fact that a method or constructor validation has been enabled or
    disabled by the techniques described in <a href="#integration-general-executable" title="10.1.2.&nbsp;Method and constructor validation">Section&nbsp;10.1.2, &#8220;Method and constructor validation&#8221;</a>.</p><p>Here is an example of what such metadata usage would be:</p><div class="example"><a name="d0e7322"></a><p class="title"><b>Example&nbsp;5.12.&nbsp;Using metadata API to figure out if method interception is
      required</b></p><pre class="programlisting">//For methods

// is there any constrained method on this type
// assuming we don't validate on getter execution
public boolean interceptMethods(Class&lt;?&gt; type) {
    return validator.getConstraintsForClass( type ).getConstrainedMethods(MethodType.NON_GETTER).size() &gt; 0;
}

// is this method constrained
public boolean interceptMethod(Class&lt;?&gt; type, Method method) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod(
        method.getName(), method.getParameterTypes() );
    return methodDescriptor != null;
}

// should method parameters be validated
public boolean requiresParametersValidation(Class&lt;?&gt; type, Method method) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod(
        method.getName(), method.getParameterTypes() );
    if ( methodDescriptor != null ) {
        return methodDescriptor.hasConstrainedParameters();
    }
    else {
        return false;
    }
}

// should method return value be validated?
public boolean requiresReturnValueValidation(Class&lt;?&gt; type, Method method) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod(
        method.getName(), method.getParameterTypes() );
    if ( methodDescriptor != null ) {
        return methodDescriptor.hasConstrainedReturnValue();
    }
    else {
        return false;
    }
}</pre></div><div class="example"><a name="d0e7327"></a><p class="title"><b>Example&nbsp;5.13.&nbsp;Using metadata API to figure out if constructor interception is
      required</b></p><pre class="programlisting">//For constructors

// is there any constrained constructor on this type
public &lt;T&gt; boolean interceptConstructors(Class&lt;T&gt; type) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    return bean.getConstrainedConstructors().size() &gt; 0;
}

// is this constructor constrained
public &lt;T&gt; boolean interceptConstructor(Class&lt;T&gt; type, Constructor&lt;T&gt; ctor) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    ConstructorDescriptor constructorDescriptor = bean.getConstraintsForConstructor(
        ctor.getParameterTypes() );
    return constructorDescriptor != null;
}

// should constructor parameters be validated
public &lt;T&gt; boolean requiresParametersValidation(Class&lt;T&gt; type, Constructor&lt;T&gt; ctor) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    ConstructorDescriptor constructorDescriptor = bean.getConstraintsForConstructor(
        ctor.getParameterTypes() );
    if ( constructorDescriptor != null ) {
        return constructorDescriptor.hasConstrainedParameters();
    }
    else {
        return false;
    }
}

// should constructor return value be validated?
public &lt;T&gt; boolean requiresReturnValueValidation(Class&lt;T&gt; type, Constructor&lt;T&gt; ctor) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    ConstructorDescriptor constructorDescriptor = bean.getConstraintsForConstructor(
        ctor.getName(), 
        ctor.getParameterTypes()
    );
    if ( constructorDescriptor != null ) {
        return constructorDescriptor.hasConstrainedReturnValue();
    }
    else {
        return false;
    }
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Calls to the metadata API is likely only going to be needed during
      the initialization phase of the interception framework. Results can then
      be cached.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Only methods or constructors intercepted by the underlying
      interception technology can be validated.</p></div><p>The integration technology must put the validation interceptor as
    late as possible (if not last) in the interception stack. In particular,
    validation of parameters should be done after the security and transaction
    start logic. Likewise, return value validation should be done before the
    transaction stop logic. Putting the validation interceptor as late as
    possible in the stack ensures this.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Why have the validation interceptor after other
      interceptors?</h3><p>There are several reasons for delaying validation compared to
      other interceptors:</p><div class="itemizedlist"><ul type="disc"><li><p>You don't want to start business code before security has been
          cleared</p></li><li><p>You might need transaction support in your validations</p></li><li><p>You want transaction to fail if the return value is
          invalid</p></li><li><p>Generally speaking, it makes more sense to apply technical
          layers around the more business focused constraints</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bootstrapping"></a>5.5.&nbsp;Bootstrapping</h2></div></div><div></div></div><p>The bootstrapping API aims at providing a
    <tt class="classname">ValidatorFactory</tt> object which is used to create
    <tt class="classname">Validator</tt> instances. The bootstrap process is
    decoupled from the provider implementation initialization: <span class="tck-testable">a bootstrap implementation must be able to bootstrap
    any Bean Validation provider implementation.</span> The bootstrap
    sequence has been designed to achieve several goals:</p><div class="itemizedlist"><ul type="disc"><li><p>plug multiple implementations</p></li><li><p>choose a specific implementation</p></li><li><p>extensibility: an application using a specific provider
        implementation can use specific configurations</p></li><li><p>share and reuse of metadata across
        <tt class="classname">Validator</tt>s</p></li><li><p>leave as much freedom as possible to implementations</p></li><li><p>provide integration mechanisms to Java EE (starting from version
        6) and other containers</p></li><li><p>type safety</p></li></ul></div><p>The main artifacts involved in the bootstrap process are:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">Validation</tt>: API entry point. Lets you
        optionally define the Bean Validation provider targeted as well as a
        provider resolution strategy. <tt class="classname">Validation</tt>
        generates <tt class="classname">Configuration</tt> objects and can
        bootstrap any provider implementation.</p></li><li><p><tt class="classname">ValidationProvider</tt>: contract between the
        bootstrap procedure and a Bean Validation provider
        implementation.</p></li><li><p><tt class="classname">ValidationProviderResolver</tt>: returns a
        list of all Bean Validation providers available in the execution
        context (generally the classpath).</p></li><li><p><tt class="classname">Configuration</tt>: collects the configuration
        details that will be used to build
        <tt class="classname">ValidatorFactory</tt>. A specific sub interface of
        <tt class="classname">Configuration</tt> must be provided by Bean
        Validation providers. This sub interface typically hosts provider
        specific configurations.</p></li><li><p><tt class="classname">ValidatorFactory</tt>: result of the bootstrap
        process. Build <tt class="classname">Validator</tt> instances from a given
        Bean Validation provider.</p></li><li><p><tt class="filename">META-INF/validation.xml</tt>: a configuration
        file Bean Validation users can use to customize the configuration of
        the default <tt class="classname">ValidatorFactory</tt>.</p></li></ul></div><p>Let's first see the API in action through some examples before
    diving into the concrete definitions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7450"></a>5.5.1.&nbsp;Examples</h3></div></div><div></div></div><p>The most simple approach is to initialize the default Bean
      Validation provider or the one defined in the XML configuration file.
      The <tt class="classname">ValidatorFactory</tt> is then ready to provide
      <tt class="classname">Validator</tt> instances.</p><div class="example"><a name="d0e7461"></a><p class="title"><b>Example&nbsp;5.14.&nbsp;Simple Bean Validation bootstrap sequence</b></p><pre class="programlisting">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();

//when the application shuts down, close ValidatorFactory
factory.close();</pre></div><p><span class="tck-not-testable">The
      <tt class="classname">ValidatorFactory</tt> object is thread-safe.</span>
      Building <tt class="classname">Validator</tt> instances is typically a cheap
      operation. Building a <tt class="classname">ValidatorFactory</tt> is
      typically more expensive. Make sure to check your Bean Validation
      implementation documentation for more accurate details.</p><p>The second example shows how a container can customize some Bean
      Validator resource handling to match its own behavior.</p><div class="example"><a name="d0e7481"></a><p class="title"><b>Example&nbsp;5.15.&nbsp;Customize message resolution, traversable resolver, constraint
        Validator factory and parameter name provider implementation</b></p><pre class="programlisting">//some customization from a container
ValidatorFactory factory = Validation
       .byDefaultProvider().configure()
          .messageInterpolator( new ContainerMessageInterpolator() )
          .constraintValidatorFactory( new ContainerComponentConstraintValidatorFactory() )
          .traversableResolver( new JPAAwareTraversableResolver() )
          .parameterNameProvider( new AnnotationBasedParameterNameProvider() )
          .buildValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();

//when the application shuts down, close ValidatorFactory
factory.close();</pre></div><p>The third example shows how to bootstrap Bean Validation in an
      environment not following the traditional Java classloader strategies
      (such as tools or alternative service containers like OSGi). They can
      provider some alternative provider resolution strategy to discover Bean
      Validation providers.</p><div class="example"><a name="d0e7488"></a><p class="title"><b>Example&nbsp;5.16.&nbsp;Customize the Bean Validation provider resolution
        mechanism</b></p><pre class="programlisting">//osgi environment
ValidatorFactory factory = Validation
       .byDefaultProvider()
          .providerResolver( new OSGiServiceDiscoverer() )
          .configure()
             .buildValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();

//when the bundle shuts down, close ValidatorFactory
factory.close();</pre></div><p>The next example shows how a client can choose a specific Bean
      Validation provider and configure provider specific properties
      programmatically in a type-safe way.</p><div class="example"><a name="d0e7495"></a><p class="title"><b>Example&nbsp;5.17.&nbsp;Use a specific provider and add specific configuration</b></p><pre class="programlisting">ValidatorFactory factory = Validation
       .byProvider( ACMEProvider.class )  //chose a specific provider
       .configure()
          .messageInterpolator( new ContainerMessageInterpolator() ) //default configuration option
          .addConstraint(Address.class, customConstraintDescriptor) //ACME specific method
          .buildValidatorFactory();

//same initialization decomposing calls
ACMEConfiguration acmeConfiguration = Validation
       .byProvider( ACMEProvider.class )
       .configure();

ValidatorFactory factory = acmeConfiguration
          .messageInterpolator( new ContainerMessageInterpolator() ) //default configuration option
          .addConstraint(Address.class, customConstraintDescriptor) //ACME specific method
          .buildValidatorFactory();

/**
 * ACME specific validator configuration and configuration options
 */
public interface ACMEConfiguration extends Configuration&lt;ACMEConfiguration&gt; {
    /**
     * Programmatically add constraints. Specific to the ACME provider.
     */
    ACMEConfiguration addConstraint(Class&lt;?&gt; entity, 
                                    ACMEConstraintDescriptor constraintDescriptor);
}

/**
 * ACME validation provider
 * Note how ACMEConfiguration and ACMEProvider are linked together 
 * via the generic parameter.
 */
public class ACMEProvider implements ValidationProvider&lt;ACMEConfiguration&gt; {
    [...]
}</pre></div><p>The last example shows how a <tt class="classname">Validator</tt> can
      use a specific <tt class="classname">MessageInterpolator</tt>
      implementation</p><div class="example"><a name="d0e7508"></a><p class="title"><b>Example&nbsp;5.18.&nbsp;Use a specific MessageInterpolator instance for a given
        Validator</b></p><pre class="programlisting">ValidatorFactory factory = [...];
MessageInterpolator customInterpolator = new LocaleSpecificMessageInterpolator(
    locale, 
    factory.getMessageInterpolator()
);

Validator localizedValidator = 
    factory.usingContext()
                   .messageInterpolator(customInterpolator)
                   .getValidator();</pre></div><p>In the same way, a custom
      <tt class="classname">TraversableResolver</tt> can be passed.</p><p>We will now explore the various interfaces, their constraints and
      usage. We will go from the <tt class="classname">ValidatorFactory</tt> to
      the <tt class="classname">Validation</tt> class walking up the bootstrap
      chain.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7526"></a>5.5.2.&nbsp;ValidatorFactory</h3></div></div><div></div></div><p><tt class="classname">ValidatorFactory</tt> objects build and provide
      initialized instances of <tt class="classname">Validator</tt> to Bean
      Validation clients. Each <tt class="classname">Validator</tt> instance is
      configured for a given context (message interpolator, traversable
      resolver etc.). Clients should cache
      <tt class="classname">ValidatorFactory</tt> objects and reuse them for
      optimal performances. The API is designed to allow implementors to share
      constraint metadata in <tt class="classname">ValidatorFactory</tt>.
      <tt class="classname">ValidatorFactory</tt> instances must be closed (by
      calling the <tt class="methodname">close()</tt> method) by its creator when
      no longer in use.</p><p><span class="tck-not-testable"><tt class="classname">ValidatorFactory</tt>
      implementations must be thread-safe.</span>
      <tt class="classname">ValidatorFactory</tt> implementations can cache
      <tt class="classname">Validator</tt> instances if needed.</p><div class="example"><a name="d0e7563"></a><p class="title"><b>Example&nbsp;5.19.&nbsp;ValidatorFactory interface</b></p><pre class="programlisting">/**
 * Factory returning initialized {@code Validator} instances.
 * &lt;p/&gt;
 * Implementations are thread-safe and instances are typically cached and reused.
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 * @author Hardy Ferentschik
 */
public interface ValidatorFactory {

    /**
     * Returns an initialized {@link Validator} instance using the
     * factory defaults for message interpolator, traversable resolver
     * and constraint validator factory.
     * &lt;p/&gt;
     * Validator instances can be pooled and shared by the implementation.
     *
     * @return an initialized {@code Validator} instance
     */
    Validator getValidator();

    /**
     * Defines a new validator context and returns a {@code Validator}
     * compliant this new context.
     *
     * @return a {@link ValidatorContext} instance
     */
    ValidatorContext usingContext();

    /**
     * Returns the {@link MessageInterpolator} instance configured at
     * initialization time for the {@code ValidatorFactory}.
     * This is the instance used by {@link #getValidator()}.
     *
     * @return {@code MessageInterpolator} instance
     */
    MessageInterpolator getMessageInterpolator();

    /**
     * Returns the {@link TraversableResolver} instance configured
     * at initialization time for the {@code ValidatorFactory}.
     * This is the instance used by {@link #getValidator()}.
     *
     * @return {@code TraversableResolver} instance
     */
    TraversableResolver getTraversableResolver();

    /**
     * Returns the {@link ConstraintValidatorFactory} instance
     * configured at initialization time for the
     * {@code ValidatorFactory}.
     * This is the instance used by {@link #getValidator()}.
     *
     * @return {@code ConstraintValidatorFactory} instance
     */
    ConstraintValidatorFactory getConstraintValidatorFactory();

    /**
     * Returns the {@link ParameterNameProvider} instance configured at
     * initialization time for the {@code ValidatorFactory}.
     * This is the instance used by #getValidator().
     *
     * @return {@code ParameterNameProvider} instance
     *
     * @since 1.1
     */
    ParameterNameProvider getParameterNameProvider();

    /**
     * Returns an instance of the specified type allowing access to
     * provider-specific APIs. If the Bean Validation provider
     * implementation does not support the specified class, a
     * {@code ValidationException} is thrown.
     *
     * @param type the class of the object to be returned
     * @return an instance of the specified class
     * @throws ValidationException if the provider does not
     *         support the call.
     */
    public &lt;T&gt; T unwrap(Class&lt;T&gt; type);

    /**
     * Closes the {@code ValidatorFactory} instance.
     *
     * After the {@code ValidatorFactory} instance is closed, calling the following
     * methods is not allowed:
     * &lt;ul&gt;
     *     &lt;li&gt;methods of this {@code ValidatorFactory} instance&lt;/li&gt;
     *     &lt;li&gt;methods of {@link Validator} instances created by this {@code ValidatorFactory}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @since 1.1
     */
    public void close();
}</pre></div><p>A <tt class="classname">ValidatorFactory</tt> is provided by a
      <tt class="classname">Configuration</tt> object.</p><p><tt class="methodname">unwrap()</tt> is provided as a way to access
      objects of a given type specific to a Bean Validation provider typically
      as a complement to the <tt class="classname">ValidatorFactory</tt> contract.
      Using this method makes your code non portable.</p><div class="example"><a name="d0e7583"></a><p class="title"><b>Example&nbsp;5.20.&nbsp;Using unwrap to access a provider specific contract</b></p><pre class="programlisting">//if using the ACME provider
ACMEValidatorFactory acmeFactory = factory.unwrap(ACMEValidatorFactory.class);
acmeFactory.setSpecificConfiguration( [...] );</pre></div><p><tt class="methodname">close()</tt> closes the
      <tt class="classname">ValidatorFactory</tt> instance which becomes
      unavailable and should be immediately discarded. This is also true of
      all the <tt class="classname">Validator</tt> instances it has spawned. The
      behavior is undefined and non portable if these instances are used after
      the <tt class="classname">ValidatorFactory</tt> has been closed.</p><p><span class="tck-testable"><tt class="methodname">getMessageInterpolator()</tt>
      returns the <tt class="classname">MessageInterpolator</tt> instance
      configured during the initialization of the
      <tt class="classname">ValidatorFactory</tt>.</span> It is particularly
      useful to build a <tt class="classname">Validator</tt> specific
      <tt class="classname">MessageInterpolator</tt> wrapping the one from the
      <tt class="classname">ValidatorFactory</tt>.</p><p><span class="tck-testable"><tt class="methodname">getTraversableResolver()</tt>
      returns the <tt class="classname">TraversableResolver</tt> instance
      configured during the initialization of the
      <tt class="classname">ValidatorFactory</tt>.</span> It is particularly
      useful to build a <tt class="classname">Validator</tt> specific
      <tt class="classname">TraversableResolver</tt> wrapping the one from the
      <tt class="classname">ValidatorFactory</tt>.</p><p><span class="tck-testable"><tt class="methodname">getConstraintValidatorFactory()</tt>
      returns the <tt class="classname">ConstraintValidatorFactory</tt> instance
      configured during the initialization of the
      <tt class="classname">ValidatorFactory</tt>.</span> It is particularly
      useful to build a <tt class="classname">Validator</tt> specific
      <tt class="classname">ConstraintValidatorFactory</tt> wrapping the one from
      the <tt class="classname">ValidatorFactory</tt>.</p><p><span class="tck-testable"><span class="tck-testable"><tt class="methodname">getParameterNameProvider()</tt>
      returns the <tt class="classname">ParameterNameProvider</tt> instance
      configured during the initialization of the
      <tt class="classname">ValidatorFactory</tt>.</span></span> It is
      particularly useful to build a <tt class="classname">Validator</tt> specific
      <tt class="classname">ParameterNameProvider</tt> wrapping the one from the
      <tt class="classname">ValidatorFactory</tt>.</p><p><tt class="classname">ValidatorContext</tt> returned by
      <tt class="methodname">usingContext()</tt> can be used to customize the
      state in which the <tt class="classname">Validator</tt> must be initialized.
      This is used to customize the
      <tt class="classname">MessageInterpolator</tt>, the
      <tt class="classname">TraversableResolver</tt>,
      <tt class="classname">ParameterNameProvider</tt> or the
      <tt class="classname">ConstraintValidatorFactory</tt>.</p><div class="example"><a name="d0e7708"></a><p class="title"><b>Example&nbsp;5.21.&nbsp;ValidatorContext interface</b></p><pre class="programlisting">/**
 * Represents the context that is used to create {@link Validator}
 * instances.
 *
 * A client may use methods of the {@code ValidatorContext} returned by
 * {@link ValidatorFactory#usingContext()} to customize
 * the context used to create {@code Validator} instances
 * (for instance establish different message interpolators or
 * traversable resolvers).
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 */
public interface ValidatorContext {

    /**
     * Defines the message interpolator implementation used by the
     * {@link Validator}.
     * &lt;p/&gt;
     * If not set or if {@code null} is passed as a parameter,
     * the message interpolator of the {@link ValidatorFactory}
     * is used.
     *
     * @param messageInterpolator the {@link MessageInterpolator} used by the {@code Validator}
     *
     * @return self following the chaining method pattern
     */
    ValidatorContext messageInterpolator(MessageInterpolator messageInterpolator);

    /**
     * Defines the traversable resolver implementation used by the
     * {@link Validator}.
     * &lt;p/&gt;
     * If not set or if {@code null} is passed as a parameter,
     * the traversable resolver of the {@link ValidatorFactory} is used.
     *
     * @param traversableResolver the {@code TraversableResolver} used by the {@code Validator}
     * @return self following the chaining method pattern
     */
    ValidatorContext traversableResolver(TraversableResolver traversableResolver);

    /**
     * Defines the constraint validator factory implementation used by the
     * {@link Validator}.
     * If not set or if {@code null} is passed as a parameter,
     * the constraint validator factory of the {@link ValidatorFactory} is used.
     *
     * @param factory the {@link ConstraintValidatorFactory} used by the {@code Validator}
     * @return self following the chaining method pattern
     */
    ValidatorContext constraintValidatorFactory(ConstraintValidatorFactory factory);

    /**
     * Defines the parameter name provider implementation used by the
     * {@link Validator}. If not set or if {@code null} is passed as a parameter,
     * the parameter name provider of the {@link ValidatorFactory} is used.
     *
     * @param parameterNameProvider parameter name provider implementation.
     * @return self following the chaining method pattern
     *
     * @since 1.1
     */
    ValidatorContext parameterNameProvider(ParameterNameProvider parameterNameProvider);

    /**
     * Returns an initialized {@link Validator} instance respecting the defined state.
     * {@code Validator} instances can be pooled and shared by the implementation.
     *
     * @return contextualized {@code Validator}
     */
    Validator getValidator();
}</pre></div><p class="tck-testable">The
      <tt class="classname">MessageInterpolator</tt>, the
      <tt class="classname">TraversableResolver</tt>, the
      <tt class="classname">ConstraintValidatorFactory</tt> or the
      <tt class="classname">ParameterNameProvider</tt> passed to the
      <tt class="classname">ValidatorContext</tt> are used instead of the
      <tt class="classname">ValidatorFactory</tt>'s
      <tt class="classname">MessageInterpolator</tt>,
      <tt class="classname">TraversableResolver</tt>,
      <tt class="classname">ConstraintValidatorFactory</tt> or
      <tt class="classname">ParameterNameProvider</tt> instances.</p><div class="example"><a name="d0e7745"></a><p class="title"><b>Example&nbsp;5.22.&nbsp;Use of ValidatorFactory</b></p><pre class="programlisting">ValidatorFactory factory = [...];
Validator validatorUsingDefaults = factory.getValidator();
Validator validatorUsingCustomTraversable = factory
                     .usingContext()
                     .traversableResolver( new JPATraversableResolver() )
                     .getValidator();</pre></div><p>See <a href="#validationapi-message-examples-specificlocale" title="Example&nbsp;5.10.&nbsp;Use MessageInterpolator to use a specific Locale value">Example&nbsp;5.10, &#8220;Use MessageInterpolator to use a specific Locale value&#8221;</a> for an example
      using
      <tt class="methodname">ValidatorFactory.getMessageInterpolator()</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7757"></a>5.5.3.&nbsp;Configuration</h3></div></div><div></div></div><p>The responsibility of the <tt class="classname">Configuration</tt> is
      to collect configuration information, to determine the correct provider
      implementation and to delegate the
      <tt class="classname">ValidatorFactory</tt> creation to the seleced
      provider. More concretely <tt class="classname">Configuration</tt> lets you
      define:</p><div class="itemizedlist"><ul type="disc"><li><p>the message interpolator instance</p></li><li><p>the traversable resolver instance</p></li><li><p>the constraint validator factory instance</p></li><li><p>the parameter name provider instance</p></li><li><p>XML constraint mappings</p></li><li><p>provider specific properties</p></li><li><p>whether or not <tt class="classname">META-INF/validation.xml</tt>
          is considered</p></li></ul></div><p><span class="tck-testable"><tt class="classname">Configuration</tt>
      does provide a <tt class="classname">MessageInterpolator</tt> implementation
      following the default Bean Validation
      <tt class="classname">MessageInterpolator</tt> rules as defined in <a href="#default-messageresolver" title="5.3.1.&nbsp;Default message interpolation">Section&nbsp;5.3.1, &#8220;Default message interpolation&#8221;</a>. You can access it by calling
      <tt class="methodname">getDefaultMessageInterpolator()</tt>.</span> Such
      an implementation is useful to let a custom
      <tt class="classname">MessageInterpolator</tt> delegate to the standard
      <tt class="classname">MessageInterpolator</tt> (see <a href="#custom-message-resolution" title="5.3.2.&nbsp;Custom message interpolation">Section&nbsp;5.3.2, &#8220;Custom message interpolation&#8221;</a> and an example making use of
      <tt class="methodname">getDefaultMessageInterpolator()</tt> in <a href="#validationapi-message-examples-jsflocale" title="Example&nbsp;5.11.&nbsp;Contextual container possible&#xA;        MessageInterpolator implementation">Example&nbsp;5.11, &#8220;Contextual container possible
        MessageInterpolator implementation&#8221;</a>).</p><p><span class="tck-testable"><tt class="classname">Configuration</tt>
      does provide a <tt class="classname">TraversableResolver</tt> implementation
      following the default Bean Validation
      <tt class="classname">TraversableResolver</tt> rules as defined in <a href="#constraintdeclarationvalidationprocess-validationroutine-traversable" title="4.6.3.&nbsp;Traversable property">Section&nbsp;4.6.3, &#8220;Traversable property&#8221;</a>.
      You can access it by calling
      <tt class="methodname">getDefaultTraversableResolver()</tt>.</span> Such
      an implementation is useful to let a custom
      <tt class="classname">TraversableResolver</tt> delegate to the standard
      <tt class="classname">TraversableResolver</tt>.</p><p><span class="tck-testable"><tt class="classname">Configuration</tt>
      does provide a <tt class="classname">ConstraintValidatorFactory</tt>
      implementation following the default Bean Validation
      <tt class="classname">ConstraintValidatorFactory</tt> rules as defined in
      <a href="#constraintsdefinitionimplementation-constraintfactory" title="3.5.&nbsp;The ConstraintValidatorFactory">Section&nbsp;3.5, &#8220;The ConstraintValidatorFactory&#8221;</a>.
      You can access it by calling
      <tt class="methodname">getDefaultConstraintValidatorFactory()</tt>.</span>
      Such an implementation is useful to let a custom
      <tt class="classname">ConstraintValidatorFactory</tt> delegate to the
      standard <tt class="classname">ConstraintValidatorFactory</tt>.</p><p><span class="tck-testable"><span class="tck-testable"><tt class="classname">Configuration</tt> does provide a
      <tt class="classname">ParameterNameProvider</tt> implementation following
      the default Bean Validation <tt class="classname">ParameterNameProvider</tt>
      rules as defined in <a href="#constraintdeclarationvalidationprocess-methodlevelconstraints-definingparameterconstraints-namingparameters" title="4.5.2.2.&nbsp;Naming parameters">Section&nbsp;4.5.2.2, &#8220;Naming parameters&#8221;</a>.
      You can access it by calling
      <tt class="methodname">getDefaultParameterNameProvider()</tt></span>.</span>
      Such an implementation is useful to let a custom
      <tt class="classname">ParameterNameProvider</tt> delegate to the standard
      <tt class="classname">ParameterNameProvider</tt>.</p><p><span class="tck-testable">Via
      <tt class="classname">getBootstrapConfiguration()</tt>,
      <tt class="classname">Configuration</tt> also exposes data stored in
      <tt class="classname">META-INF/validation.xml</tt></span> (see <a href="#xml-config" title="5.5.6.&nbsp;XML configuration: META-INF/validation.xml">Section&nbsp;5.5.6, &#8220;XML configuration: META-INF/validation.xml&#8221;</a>). This is particularly useful for containers
      wishing to control the instance creation and life cycle (more
      information at <a href="#bootstrapping-usageandcontainerexpectation" title="5.5.7.&nbsp;Bootstrapping considerations">Section&nbsp;5.5.7, &#8220;Bootstrapping considerations&#8221;</a>).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><tt class="methodname">BootstrapConfiguration.getDefaultValidatedExecutableTypes()</tt>
        and
        <tt class="methodname">BootstrapConfiguration.isExecutableValidationEnabled()</tt>
        are not used by the Bean Validation engine but exposed here for
        interception technologies - see <a href="#integration-general-executable" title="10.1.2.&nbsp;Method and constructor validation">Section&nbsp;10.1.2, &#8220;Method and constructor validation&#8221;</a>.</p></div><p><span class="tck-testable">Using
      <tt class="methodname">addMapping()</tt>, additional constraint mapping XML
      descriptors can be added to the configuration</span> (see <a href="#xml-config" title="5.5.6.&nbsp;XML configuration: META-INF/validation.xml">Section&nbsp;5.5.6, &#8220;XML configuration: META-INF/validation.xml&#8221;</a>). The given input streams should support the
      <tt class="methodname">mark()</tt> and <tt class="methodname">reset()</tt>
      methods defined by <tt class="classname">java.io.InputStream</tt>. <span class="tck-testable">Streams not supporting the
      <tt class="methodname">mark()</tt> and <tt class="methodname">reset()</tt>
      methods will be wrapped with an <tt class="classname">InputStream</tt>
      implementation supporting these methods by the Bean Validation provider
      in order to allow the streams to be read several times.</span></p><p>Clients call
      <tt class="methodname">Configuration.buildValidatorFactory()</tt> to
      retrieve the initialized <tt class="classname">ValidatorFactory</tt>
      instance.<span class="tck-testable"> It is legal to invoke
      <tt class="methodname">buildValidatorFactory()</tt> several times, e.g. in
      order to retrieval several <tt class="classname">ValidatorFactory</tt>
      instances with a slightly different configuration (see <a href="#using-configuration-several-times" title="Example&nbsp;5.27.&nbsp;Using Configuration to create several validator&#xA;        factories">Example&nbsp;5.27, &#8220;Using Configuration to create several validator
        factories&#8221;</a>).</span></p><div class="example"><a name="d0e7969"></a><p class="title"><b>Example&nbsp;5.23.&nbsp;Configuration and BootstrapConfiguration interfaces</b></p><pre class="programlisting">/**
 * Receives configuration information, selects the appropriate
 * Bean Validation provider and builds the appropriate {@link ValidatorFactory}.
 * &lt;p/&gt;
 * Usage:
 * &lt;pre&gt;
 * Configuration&lt;?&gt; configuration = //provided by one of the Validation bootstrap methods
 *     ValidatorFactory = configuration
 *         .messageInterpolator( new CustomMessageInterpolator() )
 *         .buildValidatorFactory();
 * &lt;/pre&gt;
 * &lt;p/&gt;
 * By default, the configuration information is retrieved from
 * {@code META-INF/validation.xml}.
 * It is possible to override the configuration retrieved from the XML file
 * by using one or more of the {@code Configuration} methods.
 * &lt;p/&gt;
 * The {@link ValidationProviderResolver} is specified at configuration time
 * (see {@link ValidationProvider}).
 * If none is explicitly requested, the default {@code ValidationProviderResolver} is used.
 * &lt;p/&gt;
 * The provider is selected in the following way:
 * &lt;ul&gt;
 *     &lt;li&gt;if a specific provider is requested programmatically using
 *     {@link Validation#byProvider(Class)}, find the first provider implementing
 *     the provider class requested and use it&lt;/li&gt;
 *     &lt;li&gt;if a specific provider is requested in {@code META-INF/validation.xml}&gt;,
 *     find the first provider implementing the provider class requested and use it&lt;/li&gt;
 *     &lt;li&gt;otherwise, use the first provider returned by the {@code ValidationProviderResolver}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * Implementations are not meant to be thread-safe.
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 * @author Hardy Ferentschik
 */
public interface Configuration&lt;T extends Configuration&lt;T&gt;&gt; {

    /**
     * Ignores data from the {@code META-INF/validation.xml} file if this
     * method is called.
     * &lt;p/&gt;
     * This method is typically useful for containers that parse
     * {@code META-INF/validation.xml} themselves and pass the information
     * via the {@code Configuration} methods.
     *
     * @return {@code this} following the chaining method pattern.
     */
    T ignoreXmlConfiguration();

    /**
     * Defines the message interpolator used. Has priority over the configuration
     * based message interpolator.
     * &lt;p/&gt;
     * If {@code null} is passed, the default message interpolator is used
     * (defined in XML or the specification default).
     *
     * @param interpolator message interpolator implementation
     * @return {@code this} following the chaining method pattern
     */
    T messageInterpolator(MessageInterpolator interpolator);

    /**
     * Defines the traversable resolver used. Has priority over the configuration
     * based traversable resolver.
     * &lt;p/&gt;
     * If {@code null} is passed, the default traversable resolver is used
     * (defined in XML or the specification default).
     *
     * @param resolver traversable resolver implementation
     * @return {@code this} following the chaining method pattern
     */
    T traversableResolver(TraversableResolver resolver);

    /**
     * Defines the constraint validator factory. Has priority over the configuration
     * based constraint factory.
     * &lt;p/&gt;
     * If {@code null} is passed, the default constraint validator factory is used
     * (defined in XML or the specification default).
     *
     * @param constraintValidatorFactory constraint factory implementation
     * @return {@code this} following the chaining method pattern
     */
    T constraintValidatorFactory(ConstraintValidatorFactory constraintValidatorFactory);

    /**
     * Defines the parameter name provider. Has priority over the configuration
     * based provider.
     * &lt;p/&gt;
     * If {@code null} is passed, the default parameter name provider is used
     * (defined in XML or the specification default).
     *
     * @param parameterNameProvider parameter name provider implementation
     * @return {@code this} following the chaining method pattern.
     *
     * @since 1.1
     */
    T parameterNameProvider(ParameterNameProvider parameterNameProvider);

    /**
     * Add a stream describing constraint mapping in the Bean Validation XML
     * format.
     * &lt;p/&gt;
     * The stream should be closed by the client API after the
     * {@link ValidatorFactory} has been built. The Bean Validation provider
     * must not close the stream.
     *
     * @param stream
     *        XML mapping stream; the given stream should support the
     *        mark/reset contract (see {@link InputStream#markSupported()});
     *        if it doesn't, it will be wrapped into a stream supporting the
     *        mark/reset contract by the Bean Validation provider
     *
     * @return {@code this} following the chaining method pattern
     * @throws IllegalArgumentException if {@code stream} is null
     */
    T addMapping(InputStream stream);

    /**
     * Adds a provider specific property. This property is equivalent to
     * XML configuration properties.
     * If the underlying provider does not know how to handle the property,
     * it must silently ignore it.
     * &lt;p/&gt;
     * Note: Using this non type-safe method is generally not recommended.
     * &lt;p/&gt;
     * It is more appropriate to use, if available, the type-safe equivalent provided
     * by a specific provider via its {@link Configuration} subclass.
     * &lt;pre&gt;
     * ValidatorFactory factory = Validation.byProvider(ACMEProvider.class)
     *     .configure()
     *         .providerSpecificProperty(ACMEState.FAST)
     *     .buildValidatorFactory();
     * &lt;/pre&gt;
     * This method is typically used by containers parsing {@code META-INF/validation.xml}
     * themselves and injecting the state to the {@code Configuration} object.
     * &lt;p/&gt;
     * If a property with a given name is defined both via this method and in the
     * XML configuration, the value set programmatically has priority.
     * &lt;p/&gt;
     * If {@code null} is passed as a value, the value defined in XML is used. If no value
     * is defined in XML, the property is considered unset.
     *
     * @param name property name
     * @param value property value
     * @return {@code this} following the chaining method pattern
     * @throws IllegalArgumentException if {@code name} is null
     */
    T addProperty(String name, String value);

    /**
     * Returns an implementation of the {@link MessageInterpolator} interface
     * following the default {@code MessageInterpolator} defined in the
     * specification:
     * &lt;ul&gt;
     *     &lt;li&gt;use the {@code ValidationMessages} resource bundle to load keys&lt;/li&gt;
     *     &lt;li&gt;use {@code Locale.getDefault()}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return default {@code MessageInterpolator} implementation compliant with the
     *         specification
     */
    MessageInterpolator getDefaultMessageInterpolator();

    /**
     * Returns an implementation of the {@link TraversableResolver} interface
     * following the default {@code TraversableResolver} defined in the
     * specification:
     * &lt;ul&gt;
     *     &lt;li&gt;if Java Persistence is available in the runtime environment,
     *     a property is considered reachable if Java Persistence considers
     *     the property as loaded&lt;/li&gt;
     *     &lt;li&gt;if Java Persistence is not available in the runtime environment,
     *     all properties are considered reachable&lt;/li&gt;
     *     &lt;li&gt;all properties are considered cascadable.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return default {@code TraversableResolver} implementation compliant with the
     *         specification
     */
    TraversableResolver getDefaultTraversableResolver();

    /**
     * Returns an implementation of the {@link ConstraintValidatorFactory} interface
     * following the default {@code ConstraintValidatorFactory} defined in the
     * specification:
     * &lt;ul&gt;
     *     &lt;li&gt;uses the public no-arg constructor of the {@link ConstraintValidator}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return default {@code ConstraintValidatorFactory} implementation compliant with the
     *         specification
     */
    ConstraintValidatorFactory getDefaultConstraintValidatorFactory();

    /**
     * Returns an implementation of the {@link ParameterNameProvider}
     * interface following the default {@code ParameterNameProvider}
     * defined in the specification:
     * &lt;ul&gt;
     *     &lt;li&gt;returns names in the form {@code arg&amp;lt;PARAMETER_INDEX&amp;gt;}
     *     where {@code PARAMETER_INDEX} starts at 0 for the first parameter,
     *     e.g. {@code arg0}, {@code arg1} etc.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return default {@code ParameterNameProvider} implementation compliant with
     *         the specification
     *
     * @since 1.1
     */
    ParameterNameProvider getDefaultParameterNameProvider();

    /**
     * Returns configuration information stored in the {@code META-INF/validation.xml} file.
     * &lt;p/&gt;
     * &lt;b&gt;Note&lt;/b&gt;:&lt;br/&gt;
     * Implementations are encouraged to lazily build this object to delay parsing.
     *
     * @return returns an instance of {@link BootstrapConfiguration}; this method never
     *         returns {@code null}; if there is no {@code META-INF/validation.xml} the
     *         different getters of the returned instance will return {@code null}
     *         respectively an empty set or map
     *
     * @since 1.1
     */
    BootstrapConfiguration getBootstrapConfiguration();

    /**
     * Build a {@link ValidatorFactory} implementation.
     *
     * @return the {@code ValidatorFactory}
     * @throws ValidationException if the {@code ValidatorFactory} cannot be built
     */
    ValidatorFactory buildValidatorFactory();
}</pre><pre class="programlisting">/**
 * Represents the user specified default configuration in
 * {@code META-INF/validation.xml}.
 * &lt;p/&gt;
 * Note that modifications to the returned objects do not have any effect.
 * Instead use the methods provided on {@link Configuration} in order to
 * apply modifications to the configuration.
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 * @author Hardy Ferentschik
 * @since 1.1
 */
public interface BootstrapConfiguration {

    /**
     * Class name of the {@link ValidationProvider} implementation
     * or {@code null} if none is specified.
     *
     * @return validation provider class name
     */
    String getDefaultProviderClassName();

    /**
     * Class name of the {@link ConstraintValidatorFactory} implementation
     * or {@code null} if none is specified.
     *
     * @return constraint validator factory class name
     */
    String getConstraintValidatorFactoryClassName();

    /**
     * Class name of the {@link MessageInterpolator} implementation
     * or {@code null} if none is specified.
     *
     * @return message interpolator class name or {@code null}
     */
    String getMessageInterpolatorClassName();

    /**
     * Class name of the {@link TraversableResolver} implementation
     * or {@code null} if none is specified.
     *
     * @return traversable resolver class name or {@code null}
     */
    String getTraversableResolverClassName();

    /**
     * Class name of the {@link ParameterNameProvider} implementation
     * or {@code null} if none is specified.
     *
     * @return parameter name provider class name or {@code null}
     */
    String getParameterNameProviderClassName();

    /**
     * Returns a set of resource paths pointing to XML constraint mapping files.
     * The set is empty if none are specified.
     *
     * @return set of constraint mapping resource paths
     */
    Set&lt;String&gt; getConstraintMappingResourcePaths();

    /**
     * Returns true if the validation execution is explicitly marked as enabled
     * or if it is left undefined.
     *
     * @return whether validation execution is globally enabled
     */
    boolean isExecutableValidationEnabled();

    /**
     * Returns the set of executable types that should be considered
     * unless explicitly overridden via {@link ValidateOnExecution}
     * &lt;p/&gt;
     * Returns a set containing {@link ExecutableType#CONSTRUCTORS} and
     * {@link ExecutableType#NON_GETTER_METHODS} if unspecified in the configuration.
     *
     * @return set of validated executable types
     */
    Set&lt;ExecutableType&gt; getDefaultValidatedExecutableTypes();

    /**
     * Returns properties as a map of string based key/value pairs.
     * The map is empty if no property has been specified.
     *
     * @return the properties map
     */
    Map&lt;String, String&gt; getProperties();
}</pre></div><p><span class="tck-testable">A Bean Validation provider must define
      a sub interface of <tt class="classname">Configuration</tt> uniquely
      identifying the provider.</span> This subclass is linked to its
      provider via the <tt class="classname">ValidationProvider</tt> generic
      parameter. The <tt class="classname">Configuration</tt> sub interface
      typically hosts provider specific configuration methods.</p><p>To facilitate the use of provider specific configuration methods,
      <tt class="classname">Configuration</tt> uses generics:
      <tt class="classname">Configuration&lt;T extends
      Configuration&lt;T&gt;&gt;</tt> ; the generic return type
      <tt class="classname">T</tt> is returned by chaining methods. The provider
      specific sub interface must resolve the generic T as itself as shown in
      <a href="#example-providerspecific-config" title="Example&nbsp;5.24.&nbsp;Example of provider specific Configuration sub&#xA;        interface">Example&nbsp;5.24, &#8220;Example of provider specific Configuration sub
        interface&#8221;</a>.</p><div class="example"><a name="example-providerspecific-config"></a><p class="title"><b>Example&nbsp;5.24.&nbsp;Example of provider specific Configuration sub
        interface</b></p><pre class="programlisting">/**
 * Unique identifier of the ACME provider
 * also hosts some provider specific configuration methods
 */
public interface ACMEConfiguration 
    extends Configuration&lt;ACMEConfiguration&gt; {

    /**
     * Enables constraints implementation dynamic reloading when using ACME
     * default to false
     */
    ACMEConfiguration enableDynamicReloading(boolean);

}</pre></div><p>When
      <tt class="methodname">Configuration.buildValidatorFactory()</tt> is
      called, the initialized <tt class="classname">ValidatorFactory</tt> is
      returned. More specifically, the requested Bean Validation provider is
      determined and the result of
      <tt class="code">validationProvider.buildValidatorFactory(ConfigurationState)</tt>
      is returned. <tt class="classname">ConfigurationState</tt> gives access to
      the configuration artifacts defined in
      <tt class="filename">META-INF/validation.xml</tt> (unless XML configuration
      is ignored) and provided programmatically to
      <tt class="classname">Configuration</tt>. Generally speaking,
      programmatically defined elements have priority over XML defined
      configuration elements (read the <tt class="classname">Configuration</tt>
      JavaDoc and see <a href="#xml-config" title="5.5.6.&nbsp;XML configuration: META-INF/validation.xml">Section&nbsp;5.5.6, &#8220;XML configuration: META-INF/validation.xml&#8221;</a> for more
      information).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A typical implementation of <tt class="classname">Configuration</tt>
        also implements <tt class="classname">ConfigurationState</tt>, hence
        <tt class="code">this</tt> can be passed to
        <tt class="methodname">buildValidatorFactory(ConfigurationState)</tt>.</p></div><p><span class="tck-not-testable">Streams represented in the XML
      configuration and opened by the <tt class="classname">Configuration</tt>
      implementation must be closed by the
      <tt class="classname">Configuration</tt> implementation after the
      <tt class="classname">ValidatorFactory</tt> creation (or if an exception
      occurs).</span> Streams provided programmatically are the
      responsibility of the application.</p><div class="example"><a name="d0e8060"></a><p class="title"><b>Example&nbsp;5.25.&nbsp;ConfigurationState interface</b></p><pre class="programlisting">package javax.validation.spi;

/**
 * Contract between a {@link Configuration} and a
 * {@link ValidationProvider} to create a {@link ValidatorFactory}.
 * &lt;p/&gt;
 * The configuration artifacts defined in the XML configuration and provided to the
 * {@code Configuration} are merged and passed along via
 * {@code ConfigurationState}.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @author Gunnar Morling
 */
public interface ConfigurationState {

    /**
     * Returns {@code true} if {@link Configuration#ignoreXmlConfiguration()} has been called.
     * &lt;p/&gt;
     * In this case, the {@link ValidatorFactory} must ignore
     * {@code META-INF/validation.xml}.
     *
     * @return {@code true} if {@code META-INF/validation.xml} should be ignored
     */
    boolean isIgnoreXmlConfiguration();

    /**
     * Returns the message interpolator of this configuration.
     * &lt;p/&gt;
     * Message interpolator is defined in the following decreasing priority:
     * &lt;ul&gt;
     *     &lt;li&gt;set via the {@link Configuration} programmatic API&lt;/li&gt;
     *     &lt;li&gt;defined in {@code META-INF/validation.xml} provided that
     *     {@code ignoreXmlConfiguration} is false. In this case the instance
     *     is created via its no-arg constructor.&lt;/li&gt;
     *     &lt;li&gt;{@code null} if undefined.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return message interpolator instance or {@code null} if not defined
     */
    MessageInterpolator getMessageInterpolator();

    /**
     * Returns a set of configuration streams.
     * &lt;p/&gt;
     * The streams are defined by:
     * &lt;ul&gt;
     *     &lt;li&gt;mapping XML streams passed programmatically in {@link Configuration}&lt;/li&gt;
     *     &lt;li&gt;mapping XML streams located in the resources defined in
     *     {@code META-INF/validation.xml} (constraint-mapping element)&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p/&gt;
     * Streams represented in the XML configuration and opened by the
     * {@code Configuration} implementation must be closed by the
     * {@code Configuration} implementation after the {@link ValidatorFactory}
     * creation (or if an exception occurs). All streams are guaranteed to
     * adhere to the mark/reset contract (see {@link InputStream#markSupported()}
     * by the Bean Validation provider.
     *
     * @return set of input stream
     */
    Set&lt;InputStream&gt; getMappingStreams();

    /**
     * Returns the constraint validator factory of this configuration.
     * &lt;p/&gt;
     * The {@link ConstraintValidatorFactory} implementation is defined in the following
     * decreasing priority:
     * &lt;ul&gt;
     *     &lt;li&gt;set via the {@link Configuration} programmatic API&lt;/li&gt;
     *     &lt;li&gt;defined in {@code META-INF/validation.xml} provided that
     *     {@code ignoredXmlConfiguration} is {@code false}. In this case the instance
     *     is created via its no-arg constructor.&lt;/li&gt;
     *     &lt;li&gt;{@code null} if undefined.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return factory instance or {@code null} if not defined
     */
    ConstraintValidatorFactory getConstraintValidatorFactory();

    /**
     * Returns the traversable resolver for this configuration.
     * &lt;p/&gt;
     * {@link TraversableResolver} is defined in the following decreasing priority:
     * &lt;ul&gt;
     *     &lt;li&gt;set via the {@link Configuration} programmatic API&lt;/li&gt;
     *     &lt;li&gt;defined in {@code META-INF/validation.xml} provided that
     *     {@code ignoredXmlConfiguration} is {@code false}. In this case the
     *     instance is created via its no-arg constructor.&lt;/li&gt;
     *     &lt;li&gt;{@code null} if undefined.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return traversable resolver instance or {@code null} if not defined
     */
    TraversableResolver getTraversableResolver();

    /**
     * Returns the parameter name provider for this configuration.
     * &lt;p/&gt;
     * {@link ParameterNameProvider} is defined in the following decreasing priority:
     * &lt;ul&gt;
     *     &lt;li&gt;set via the {@link Configuration} programmatic API&lt;/li&gt;
     *     &lt;li&gt;defined in {@code META-INF/validation.xml} provided that
     *     {@code ignoreXmlConfiguration} is {@code false}. In this case the instance
     *     is created via its no-arg constructor.&lt;/li&gt;
     *     &lt;li&gt;{@code null} if undefined.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return parameter name provider instance or {@code null} if not defined
     *
     * @since 1.1
     */
    ParameterNameProvider getParameterNameProvider();

    /**
     * Returns a map of non type-safe custom properties.
     * &lt;p/&gt;
     * Properties defined via:
     * &lt;ul&gt;
     *     &lt;li&gt;{@link Configuration#addProperty(String, String)}&lt;/li&gt;
     *     &lt;li&gt;{@code META-INF/validation.xml} provided that
     *     {@code ignoreXmlConfiguration}&lt;/li&gt; is {@code false}.
     * &lt;/ul&gt;
     * &lt;p/&gt;
     * If a property is defined both programmatically and in XML,
     * the value defined programmatically has priority.
     *
     * @return {@code Map} whose key is the property key and the value
     *         the property value
     */
    Map&lt;String, String&gt; getProperties();
}</pre></div><p class="tck-testable">The requested provider implementation is
      resolved according to the following rules in the following order:
      </p><div class="itemizedlist"><ul type="disc"><li><p>Use the provider implementation requested if
            <tt class="classname">Configuration</tt> has been created from
            <tt class="classname">Validation.byProvider(Class)</tt>.</p></li><li><p>Use the provider implementation described in the XML
            configuration (under
            <tt class="literal">validation-config.default-provider</tt> see <a href="#xml-config" title="5.5.6.&nbsp;XML configuration: META-INF/validation.xml">Section&nbsp;5.5.6, &#8220;XML configuration: META-INF/validation.xml&#8221;</a>) if defined: the value of this element is
            the fully qualified class name of the
            <tt class="classname">ValidationProvider</tt> implementation uniquely
            identifying the provider.</p></li><li><p>Use the first provider implementation returned by
            <tt class="classname">validationProviderResolver.getValidationProviders()</tt>.</p></li></ul></div><p>The <tt class="classname">ValidationProviderResolver</tt> is specified
      when <tt class="classname">Configuration</tt> instances are created (see
      <tt class="classname">ValidationProvider</tt>). <span class="tck-not-testable">If no
      <tt class="classname">ValidationProviderResolver</tt> instance has been
      specified, the default <tt class="classname">ValidationProviderResolver</tt>
      is used.</span></p><p><tt class="classname">Configuration</tt> instances are provided to the
      Bean Validation client through the <tt class="classname">Validation</tt>
      methods. <tt class="classname">Configuration</tt> instances are created by
      <tt class="classname">ValidationProvider</tt>.</p><p>If a problem occurs while building the
      <tt class="classname">ValidatorFactory</tt>, a
      <tt class="classname">ValidationException</tt> is raised. This can be due to
      various reasons including:</p><div class="itemizedlist"><ul type="disc"><li><p>malformed XML configuration</p></li><li><p>malformed XML mapping</p></li><li><p>inability to find the provider (or a provider)</p></li><li><p>inability to instantiate extension classes provided in the XML
          configuration</p></li><li><p>inconsistent XML mapping (entity declared more than once,
          incorrect field etc.)</p></li><li><p>invalid constraint declaration or definition</p></li></ul></div><p>Other exception causes may occur.</p><p>Here is an example of <tt class="classname">Configuration</tt>
      use.</p><div class="example"><a name="d0e8160"></a><p class="title"><b>Example&nbsp;5.26.&nbsp;Use Configuration</b></p><pre class="programlisting">Configuration&lt;?&gt; configuration = [...];
ValidatorFactory factory = configuration
              .messageInterpolator( new WBMessageInterpolator() )
              .traversableResolver( new JPAAwareTraversableResolver() )
              .buildValidatorFactory();</pre></div><p>The following shows an example of setting up a
      <tt class="classname">Configuration</tt>, retrieving a validator factory
      from it, subsequently altering the configuration and then retrieving
      another factory:</p><div class="example"><a name="using-configuration-several-times"></a><p class="title"><b>Example&nbsp;5.27.&nbsp;Using Configuration to create several validator
        factories</b></p><pre class="programlisting">Configuration&lt;?&gt; configuration = [...];
ValidatorFactory factory1 = configuration
              .messageInterpolator( new WBMessageInterpolator() )
              .buildValidatorFactory();

ValidatorFactory factory2 = configuration
              .traversableResolver( new JPAAwareTraversableResolver() )
              .buildValidatorFactory();</pre></div><p>Here, <tt class="varname">factory1</tt> is set up using a custom message
      interpolator, while <tt class="varname">factory2</tt> is set up using the same
      message interpolator and additionally using a custom traversable
      resolver.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8183"></a>5.5.4.&nbsp;ValidationProvider and ValidationProviderResolver</h3></div></div><div></div></div><p><tt class="classname">ValidationProvider</tt> is the contract between
      the bootstrap process and a specific Bean Validation provider.
      <tt class="classname">ValidationProviderResolver</tt> implements the
      discovery mechanism for Bean Validation provider implementations. Any
      Bean Validation client can implement such a discovery mechanism but it
      is typically implemented by containers having specific classloader
      structures and restrictions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8193"></a>5.5.4.1.&nbsp;ValidationProviderResolver</h4></div></div><div></div></div><p><span class="tck-testable"><tt class="classname">ValidationProviderResolver</tt>
        returns the list of Bean Validation providers available at runtime and
        more specifically a <tt class="classname">ValidationProvider</tt> instance
        for each provider available in the context.</span> This service can
        be customized by implementing
        <tt class="classname">ValidationProviderResolver</tt>. <span class="tck-not-testable">Implementations must be
        thread-safe.</span></p><div class="example"><a name="d0e8210"></a><p class="title"><b>Example&nbsp;5.28.&nbsp;ValidationProviderResolver</b></p><pre class="programlisting">/**
 * Determines the list of Bean Validation providers available in the runtime environment
 * &lt;p/&gt;
 * Bean Validation providers are identified by the presence of
 * {@code META-INF/services/javax.validation.spi.ValidationProvider}
 * files following the Service Provider pattern described
 * &lt;a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jar/jar.html#Service%20Provider"&gt;here&lt;/a&gt;.
 * &lt;p/&gt;
 * Each {@code META-INF/services/javax.validation.spi.ValidationProvider} file contains the list of
 * {@link ValidationProvider} implementations each of them representing a provider.
 * &lt;p/&gt;
 * Implementations must be thread-safe.
 *
 * @author Emmanuel Bernard
 */
public interface ValidationProviderResolver {

    /**
     * Returns a list of {@link ValidationProvider} available in the runtime environment.
     *
     * @return list of validation providers
     */
    List&lt;ValidationProvider&lt;?&gt;&gt; getValidationProviders();
}</pre></div><p>By default, providers are resolved using the Service Provider
        pattern described in <a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jar/jar.html#Service%20Provider" target="_top">http://docs.oracle.com/javase/6/docs/technotes/guides/jar/jar.html#Service%20Provider</a>.
        <span class="tck-not-testable">Bean Validation providers must supply
        a service provider configuration file by creating a text file
        <tt class="filename">javax.validation.spi.ValidationProvider</tt> and
        placing it in the <tt class="filename">META-INF/services</tt> directory of
        one of its jar files.</span> The content of the file contains the
        name of the provider implementation class of the
        <tt class="classname">javax.validation.spi.ValidationProvider</tt>
        interface.</p><p>Bean Validation provider jars may be installed or made available
        in the same ways as other service providers, e.g. as extensions or
        added to the application classpath according to the guidelines in the
        JAR file specification.</p><p>The default <tt class="classname">ValidationProviderResolver</tt>
        implementation will locate all the Bean Validation providers by their
        provider configuration files visible in the classpath. The default
        <tt class="classname">ValidationProviderResolver</tt> implementation is
        recommended and custom
        <tt class="classname">ValidationProviderResolver</tt> implementations
        should be rarely used. A typical use of a custom resolution is
        resolving providers in a classloader constrained container like OSGi
        or in a tool environment (IDE).</p><p>The default <tt class="classname">ValidationProviderResolver</tt>
        can be accessed via
        <tt class="classname">BootStrapState.getDefaultValidationProviderResolver()</tt>.
        This method is typically used by the Bean Validation provider
        <tt class="classname">Configuration</tt> implementation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id-bootstrap-validationprovider"></a>5.5.4.2.&nbsp;ValidationProvider</h4></div></div><div></div></div><p><tt class="classname">ValidationProvider</tt> represents the SPI
        (Service Provider Interface) defining the contract between the
        provider discovery and initialization mechanism, and the provider. A
        <tt class="classname">ValidationProvider</tt> does:</p><div class="itemizedlist"><ul type="disc"><li><p>Provide a generic <tt class="classname">Configuration</tt>
            implementation (i.e. not tied to a given provider).</p></li><li><p>Provide a provider specific
            <tt class="classname">Configuration</tt> implementation. This
            <tt class="classname">Configuration</tt> will specifically build
            <tt class="classname">ValidatorFactory</tt> instances of the provider
            it comes from.</p></li><li><p>Build a <tt class="classname">ValidatorFactory</tt> object from
            the configuration provided by
            <tt class="classname">ConfigurationState</tt>.</p></li></ul></div><div class="example"><a name="d0e8294"></a><p class="title"><b>Example&nbsp;5.29.&nbsp;ValidationProvider</b></p><pre class="programlisting">package javax.validation.spi;

/**
 * Contract between the validation bootstrap mechanism and the provider engine.
 * &lt;p/&gt;
 * Implementations must have a public no-arg constructor. The construction of a provider
 * should be as "lightweight" as possible.
 *
 * {@code T} represents the provider specific Configuration subclass
 * which typically host provider's additional configuration methods.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ValidationProvider&lt;T extends Configuration&lt;T&gt;&gt; {

    /**
     * Returns a {@link Configuration} instance implementing {@code T},
     * the {@code Configuration} sub-interface.
     * The returned {@code Configuration} instance must use the current provider
     * ({@code this}) to build the {@code ValidatorFactory} instance.
     *
     * @param state bootstrap state
     * @return specific {@code Configuration} implementation
     */
    T createSpecializedConfiguration(BootstrapState state);

    /**
     * Returns a {@link Configuration} instance. This instance is not bound to
     * use the current provider. The choice of provider follows the algorithm described
     * in {@code Configuration}
     * &lt;p/&gt;
     * The {@link ValidationProviderResolver} used by {@code Configuration}
     * is provided by {@code state}.
     * If null, the default {@code ValidationProviderResolver} is used.
     *
     * @param state bootstrap state
     * @return non specialized Configuration implementation
     */
    Configuration&lt;?&gt; createGenericConfiguration(BootstrapState state);

    /**
     * Build a {@link ValidatorFactory} using the current provider implementation.
     * &lt;p/&gt;
     * The {@code ValidatorFactory} is assembled and follows the configuration passed
     * via {@link ConfigurationState}.
     * &lt;p/&gt;
     * The returned {@code ValidatorFactory} is properly initialized and ready for use.
     *
     * @param configurationState the configuration descriptor
     * @return the instantiated {@code ValidatorFactory}
     * @throws ValidationException if the {@code ValidatorFactory} cannot be built
     */
    ValidatorFactory buildValidatorFactory(ConfigurationState configurationState);
}</pre></div><div class="example"><a name="d0e8299"></a><p class="title"><b>Example&nbsp;5.30.&nbsp;BootstrapState interface</b></p><pre class="programlisting">package javax.validation.spi;

/**
 * Defines the state used to bootstrap the {@link Configuration}.
 *
 * @author Emmanuel Bernard
 * @author Sebastian Thomschke 
 */
public interface BootstrapState {

    /**
     * User defined {@code ValidationProviderResolver} strategy
     * instance or {@code null} if undefined.
     *
     * @return ValidationProviderResolver instance or null
     */
    ValidationProviderResolver getValidationProviderResolver();

    /**
     * Specification default {@code ValidationProviderResolver}
     * strategy instance.
     * 
     * @return default implementation of ValidationProviderResolver
     */
    ValidationProviderResolver getDefaultValidationProviderResolver();
}</pre></div><p><span class="tck-testable">A client can request a specific Bean
        Validation provider by using <tt class="classname">&lt;T extends
        Configuration&lt;T&gt;, U extends ValidationProvider&lt;T&gt;&gt;
        Validation.byProvider(Class&lt;U&gt;)</tt> or by defining the
        provider in the XML configuration file.</span> The key uniquely
        identifying a Bean Validation provider is the
        <tt class="classname">ValidationProvider</tt> implementation specific to
        this provider.</p><p>A <tt class="classname">ValidationProvider</tt> implementation is
        linked (via its generic parameter) to a specific sub interface of
        <tt class="classname">Configuration</tt>. The Bean Validation bootstrap
        API makes use of this link to return the specific
        <tt class="classname">Configuration</tt> subinterface implementation in a
        type-safe way when a specific provider is requested. The sub interface
        does not have to add any new method but is the natural holder for
        provider specific configuration methods.</p><div class="example"><a name="d0e8325"></a><p class="title"><b>Example&nbsp;5.31.&nbsp;Example of provider specific Configuration sub
          interface</b></p><pre class="programlisting">/**
 * Unique identifier of the ACME provider
 * also hosts some provider specific configuration methods
 */
public interface ACMEConfiguration 
    extends Configuration&lt;ACMEConfiguration&gt; {

    /**
     * Enables constraints implementation dynamic reloading when using ACME
     * default to false
     */
    ACMEConfiguration enableDynamicReloading(boolean);

}

/**
 * ACME validation provider
 * Note how ACMEConfiguration and ACMEProvider are linked together 
 * via the generic parameter.
 */
public class ACMEProvider implements ValidationProvider&lt;ACMEConfiguration&gt; {
    [...]
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><tt class="classname">Configuration</tt> references itself in the
          generic definition. Methods of <tt class="classname">Configuration</tt>
          will return the <tt class="classname">ACMEConfiguration</tt> making the
          API easy to use even for vendor specific extensions.</p></div><p class="tck-testable">The provider discovery mechanism uses the
        following algorithm: </p><div class="itemizedlist"><ul type="disc"><li><p>Retrieve available providers using
              <tt class="methodname">ValidationProviderResolver.getValidationProviders()</tt>.</p></li><li><p>The first <tt class="classname">ValidationProvider</tt>
              matching the requested provider is returned. Providers are
              evaluated in the order they are returned by
              <tt class="classname">ValidationProviderResolver</tt>. A provider
              instance is considered matching if it is assignable to the
              requested provider class.</p></li></ul></div><p class="tck-testable">When the default Bean Validation provider is
        requested, the first <tt class="classname">ValidationProvider</tt>
        returned by the <tt class="classname">ValidationProviderResolver</tt>
        strategy is returned.</p><p><span class="tck-testable">Every Bean Validation provider must
        provide a <tt class="classname">ValidationProvider</tt> implementation
        containing a public no-arg constructor</span> and add the
        corresponding
        <tt class="filename">META-INF/services/javax.validation.spi.ValidationProvider</tt>
        file descriptor in one of its jars.</p><p><span class="tck-testable">If a problem occurs while building
        the <tt class="classname">ValidatorFactory</tt>, a
        <tt class="classname">ValidationException</tt> is raised.</span> This
        can be due to various reasons including:</p><div class="itemizedlist"><ul type="disc"><li><p>malformed XML mapping</p></li><li><p>inability to find the provider (or a provider)</p></li><li><p>inability to instantiate extension classes provided in the
            XML configuration</p></li><li><p>inconsistent XML mapping (entity declared more than once,
            incorrect field etc.)</p></li><li><p>invalid constraint declaration or definition</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="boostrapping-validation"></a>5.5.5.&nbsp;Validation</h3></div></div><div></div></div><p>The <tt class="classname">Validation</tt> class is the entry point
      used to bootstrap Bean Validation providers. <span class="tck-testable">The first entry point,
      <tt class="methodname">buildDefaultValidatorFactory()</tt>, is considered
      to be the default <tt class="classname">ValidatorFactory</tt> and is
      equivalent to the <tt class="classname">ValidatorFactory</tt> returned by
      <tt class="code">Validation.byDefaultProvider().configure().buildValidatorFactory()</tt>.</span></p><div class="example"><a name="d0e8425"></a><p class="title"><b>Example&nbsp;5.32.&nbsp;Validation methods available</b></p><pre class="programlisting">/**
 * This class is the entry point for Bean Validation.
 * &lt;p/&gt;
 * There are three ways to bootstrap it:
 * &lt;ul&gt;
 *     &lt;li&gt;The easiest approach is to build the default {@link ValidatorFactory}.
 *     &lt;pre&gt;
 * ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
 * &lt;/pre&gt;
 *     In this case, the default validation provider resolver
 *     will be used to locate available providers.
 *     &lt;p/&gt;
 *     The chosen provider is defined as followed:
 *     &lt;ul&gt;
 *         &lt;li&gt;if the XML configuration defines a provider, this provider is used&lt;/li&gt;
 *         &lt;li&gt;if the XML configuration does not define a provider or if no XML
 *         configuration is present the first provider returned by the
 *         {@link ValidationProviderResolver} instance is used.&lt;/li&gt;
 *     &lt;/ul&gt;
 *     &lt;/li&gt;
 *     &lt;li&gt;
 *     The second bootstrap approach allows to choose a custom
 *     {@code ValidationProviderResolver}. The chosen
 *     {@link ValidationProvider} is then determined in the same way
 *     as in the default bootstrapping case (see above).
 *     &lt;pre&gt;
 * Configuration&lt;?&gt; configuration = Validation
 *    .byDefaultProvider()
 *    .providerResolver( new MyResolverStrategy() )
 *    .configure();
 * ValidatorFactory factory = configuration.buildValidatorFactory();
 * &lt;/pre&gt;
 *     &lt;/li&gt;
 *     &lt;li&gt;
 *     The third approach allows you to specify explicitly and in
 *     a type safe fashion the expected provider.
 *     &lt;p/&gt;
 *     Optionally you can choose a custom {@code ValidationProviderResolver}.
 *     &lt;pre&gt;
 * ACMEConfiguration configuration = Validation
 *    .byProvider(ACMEProvider.class)
 *    .providerResolver( new MyResolverStrategy() )  // optionally set the provider resolver
 *    .configure();
 * ValidatorFactory factory = configuration.buildValidatorFactory();
 * &lt;/pre&gt;
 *     &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * Note:
 * &lt;ul&gt;
 *     &lt;li&gt;
 *     The {@code ValidatorFactory} object built by the bootstrap process should be cached
 *     and shared amongst {@code Validator} consumers.
 *     &lt;/li&gt;
 *     &lt;li&gt;This class is thread-safe.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public class Validation {

    /**
     * Builds and returns a {@link ValidatorFactory} instance based on the
     * default Bean Validation provider and following the XML configuration.
     * &lt;p/&gt;
     * The provider list is resolved using the default validation provider resolver
     * logic.
     * &lt;p/&gt;
     * The code is semantically equivalent to
     * {@code Validation.byDefaultProvider().configure().buildValidatorFactory()}.
     *
     * @return {@code ValidatorFactory} instance
     *
     * @throws ValidationException if the {@code ValidatorFactory} cannot be built
     */
    public static ValidatorFactory buildDefaultValidatorFactory() {
        [...]
    }

    /**
     * Builds a {@link Configuration}. The provider list is resolved
     * using the strategy provided to the bootstrap state.
     * &lt;pre&gt;
     * Configuration&amp;lt?&amp;gt; configuration = Validation
     *    .byDefaultProvider()
     *    .providerResolver( new MyResolverStrategy() )
     *    .configure();
     * ValidatorFactory factory = configuration.buildValidatorFactory();
     * &lt;/pre&gt;
     * The provider can be specified in the XML configuration. If the XML
     * configuration does not exist or if no provider is specified,
     * the first available provider will be returned.
     *
     * @return instance building a generic {@code Configuration}
     *         compliant with the bootstrap state provided
     */
    public static GenericBootstrap byDefaultProvider() {
        [...]
    }

    /**
     * Builds a {@link Configuration} for a particular provider implementation.
     * &lt;p/&gt;
     * Optionally overrides the provider resolution strategy used to determine the provider.
     * &lt;p/&gt;
     * Used by applications targeting a specific provider programmatically.
     * &lt;p/&gt;
     * &lt;pre&gt;
     * ACMEConfiguration configuration =
     *     Validation.byProvider(ACMEProvider.class)
     *             .providerResolver( new MyResolverStrategy() )
     *             .configure();
     * &lt;/pre&gt;,
     * where {@code ACMEConfiguration} is the
     * {@code Configuration} sub interface uniquely identifying the
     * ACME Bean Validation provider. and {@code ACMEProvider} is the
     * {@link ValidationProvider} implementation of the ACME provider.
     *
     * @param providerType the {@code ValidationProvider} implementation type
     *
     * @return instance building a provider specific {@code Configuration}
     *         sub interface implementation
     */
    public static &lt;T extends Configuration&lt;T&gt;, U extends ValidationProvider&lt;T&gt;&gt;
    ProviderSpecificBootstrap&lt;T&gt; byProvider(Class&lt;U&gt; providerType) {
        [...]
    }

    [...]
}</pre></div><p><span class="tck-testable">The second entry point lets the client
      provide a custom <tt class="classname">ValidationProviderResolution</tt>
      instance. This instance is passed to
      <tt class="classname">GenericBootstrap</tt>.
      <tt class="classname">GenericBootstrap</tt> builds a generic
      <tt class="classname">Configuration</tt> using the first
      <tt class="classname">ValidationProvider</tt> returned by
      <tt class="classname">ValidationProviderResolution</tt> and calling
      <tt class="code">ValidationProvider.createGenericConfiguration(BootstrapState
      state)</tt>.</span> <tt class="classname">BootstrapState</tt> holds the
      <tt class="classname">ValidationProviderResolution</tt> instance passed to
      <tt class="classname">GenericBootstrap</tt> and will be used by the
      <tt class="classname">Configuration</tt> instance when resolving the
      provider to use. Note that
      <tt class="code">ValidationProvider.createGenericConfiguration</tt> returns a
      <tt class="classname">Configuration</tt> object not bound to any particular
      provider.</p><div class="example"><a name="d0e8473"></a><p class="title"><b>Example&nbsp;5.33.&nbsp;GenericBootstrap interface</b></p><pre class="programlisting">package javax.validation.bootstrap;

/**
 * Defines the state used to bootstrap Bean Validation and
 * creates a provider agnostic {@link Configuration}.
 *
 * @author Emmanuel Bernard
 */
public interface GenericBootstrap {

    /**
     * Defines the provider resolution strategy.
     * This resolver returns the list of providers evaluated
     * to build the {@link Configuration}.
     * &lt;p/&gt;
     * If no resolver is defined, the default {@link ValidationProviderResolver}
     * implementation is used.
     *
     * @param resolver the {@code ValidationProviderResolver} to use for bootstrapping
     * @return {@code this} following the chaining method pattern
     */
    GenericBootstrap providerResolver(ValidationProviderResolver resolver);

    /**
     * Returns a generic {@link Configuration} implementation.
     * At this stage the provider used to build the {@link ValidatorFactory}
     * is not defined.
     * &lt;p/&gt;
     * The {@code Configuration} implementation is provided by the first provider
     * returned by the {@link ValidationProviderResolver} strategy.
     *
     * @return a {@code Configuration} implementation compliant with the bootstrap state
     * @throws ValidationException if the {@code Configuration} object cannot be built;
     *         this is generally due to an issue with the {@code ValidationProviderResolver}
     */
    Configuration&lt;?&gt; configure();
}</pre></div><p><span class="tck-testable">The last entry point lets the client
      define the specific Bean Validation provider requested as well as a
      custom <tt class="classname">ValidationProviderResolver</tt> implementation
      if needed. The entry point method,
      <tt class="methodname">Validation.byProvider(Class&lt;U&gt;
      providerType)</tt>, takes the provider specific
      <tt class="classname">ValidationProvider</tt> implementation type and
      returns a <tt class="classname">ProviderSpecificBootstrap</tt> object that
      guarantees to return an instance of the specific
      <tt class="classname">Configuration</tt> sub interface.</span> Thanks to
      the use of generics, the client API does not have to cast to the
      <tt class="classname">Configuration</tt> sub interface.</p><p>A <tt class="classname">ProviderSpecificBootstrap</tt> object can
      optionally receive a <tt class="classname">ValidationProviderResolver</tt>
      instance.</p><div class="example"><a name="d0e8508"></a><p class="title"><b>Example&nbsp;5.34.&nbsp;ProviderSpecificBootstrap interface</b></p><pre class="programlisting">package javax.validation.bootstrap;

/**
 * Defines the state used to bootstrap Bean Validation and
 * creates a provider specific {@link Configuration}
 * of type {@code T}.
 * &lt;p/&gt;
 * The specific {@code Configuration} is linked to the provider via the generic
 * parameter of the {@link ValidationProvider} implementation.
 * &lt;p/&gt;
 * The requested provider is the first provider instance assignable to
 * the requested provider type (known when {@link ProviderSpecificBootstrap} is built).
 * The list of providers evaluated is returned by {@link ValidationProviderResolver}.
 * If no {@code ValidationProviderResolver} is defined, the
 * default {@code ValidationProviderResolver} strategy is used.
 *
 * @author Emmanuel Bernard
 */
public interface ProviderSpecificBootstrap&lt;T extends Configuration&lt;T&gt;&gt; {

    /**
     * Optionally defines the provider resolver implementation used.
     * If not defined, use the default {@link ValidationProviderResolver}
     *
     * @param resolver {@code ValidationProviderResolver} implementation used
     *
     * @return {@code this} following the chaining method pattern
     */
    public ProviderSpecificBootstrap&lt;T&gt; providerResolver(ValidationProviderResolver resolver);

    /**
     * Determines the provider implementation suitable for {@code T} and delegates
     * the creation of this specific {@link Configuration} subclass to the provider.
     *
     * @return {@code Configuration} sub interface implementation
     *
     * @throws ValidationException if the {@code Configuration} object cannot be built;
     *         this is generally due to an issue with the {@code ValidationProviderResolver}
     */
    public T configure();
}</pre></div><p><tt class="methodname">ProviderSpecificBootstrap.configure()</tt>
      must return the result of
      <tt class="methodname">ValidationProvider.createSpecializedConfiguration(BootstrapState
      state)</tt>. The state parameter holds the
      <tt class="classname">ValidationProviderResolver</tt> passed to
      <tt class="classname">ProviderSpecificBootstrap</tt>. The validation
      provider instance used is the one assignable to the type passed as a
      parameter in <tt class="methodname">Validation.byProvider(Class)</tt>. The
      validation provider is selected according to the algorithm described in
      (<a href="#id-bootstrap-validationprovider" title="5.5.4.2.&nbsp;ValidationProvider">Section&nbsp;5.5.4.2, &#8220;ValidationProvider&#8221;</a>).</p><p class="tck-testable">The <tt class="classname">Validation</tt>
      implementation must not contain any non private attribute or method
      aside from the three public static bootstrap methods:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">public static ValidatorFactory
          buildDefaultValidatorFactory()</tt></p></li><li><p><tt class="methodname">public static GenericBootstrap
          byDefaultProvider()</tt></p></li><li><p><tt class="methodname">public static &lt;T extends
          Configuration&lt;T&gt;, U extends ValidationProvider&lt;T&gt;&gt;
          ProviderSpecificBootstrap&lt;T&gt; byProvider(Class&lt;U&gt;
          providerType)</tt></p></li></ul></div><p>The bootstrap API is designed to allow complete portability
      amongst Bean Validation provider implementations. <span class="tck-testable">The bootstrap implementation must ensure it can
      bootstrap third party providers.</span></p><p class="tck-testable">When bootstrapping a Bean Validation provider,
      if the <tt class="classname">ValidationProviderResolver</tt> either fails or
      if the expected provider is not found, a
      <tt class="classname">ValidationException</tt> is raised.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml-config"></a>5.5.6.&nbsp;XML configuration: META-INF/validation.xml</h3></div></div><div></div></div><p><span class="tck-testable">Unless explicitly ignored by calling
      <tt class="classname">Configuration.ignoreXMLConfiguration()</tt>, a
      <tt class="classname">Configuration</tt> takes into account the
      configuration available in
      <tt class="filename">META-INF/validation.xml</tt>.</span> <span class="tck-testable">This configuration file is optional</span> but can
      be used by applications to refine some of the Bean Validation behavior.
      <span class="tck-not-testable">If more than one
      <tt class="filename">META-INF/validation.xml</tt> file is found in the
      classpath, a <tt class="classname">ValidationException</tt> is
      raised.</span></p><p class="tck-testable">Implementations supporting Bean Validation 1.1
      must properly parse deployment descriptors of Bean Validation 1.0 and
      1.1.</p><p><span class="tck-testable">Unless stated otherwise, XML based
      configuration settings are overridden by values explicitly set via the
      <tt class="classname">Configuration</tt> API.</span> For example, the
      <tt class="classname">MessageInterpolator</tt> defined via
      <tt class="methodname">Configuration.messageInterpolator(MessageInterpolator)</tt>
      has priority over the <tt class="literal">message-interpolator</tt>
      definition.</p><p><span class="tck-testable"><tt class="literal">default-provider</tt>:
      represents the class name of the provider specific
      <tt class="classname">ValidationProvider</tt> implementation class. If
      defined, the specific provider is used</span> (unless a specific
      provider has been chosen via the programmatic approach).</p><p class="tck-testable"><tt class="literal">message-interpolator</tt>:
      represents the fully qualified class name of the
      <tt class="classname">MessageInterpolator</tt> implementation. When defined
      in XML, the implementation must have a public no-arg constructor.</p><p class="tck-testable"><tt class="literal">traversable-resolver</tt>:
      represents the fully qualified class name of the
      <tt class="classname">TraversableResolver</tt> implementation. When defined
      in XML, the implementation must have a public no-arg constructor.</p><p class="tck-testable"><tt class="literal">constraint-validator-factory</tt>:
      represents the fully qualified class name of the
      <tt class="classname">ConstraintValidatorFactory</tt> implementation. When
      defined in XML, the implementation must have a public no-arg
      constructor.</p><p class="tck-testable"><tt class="literal">parameter-name-provider</tt>:
      represents the fully qualified class name of the
      <tt class="classname">ParameterNameProvider</tt> implementation. When
      defined in XML, the implementation must have a public no-arg
      constructor.</p><p class="tck-testable"><tt class="literal">executable-validation</tt>:
      allows to disable executable validation entirely via its attribute
      <tt class="code">enabled="false"</tt> and optionally contains
      <tt class="literal">default-validated-executable-types</tt>.
      <tt class="literal">enabled</tt> defaults to <tt class="literal">true</tt>.</p><p class="tck-testable"><tt class="literal">default-validated-executable-types</tt>:
      declared under <tt class="literal">executable-validation</tt>, contains the
      list of <tt class="literal">executable-type</tt> that are considered by
      default by the integration technology validating executables upon
      execution.</p><p><span class="tck-testable"><tt class="literal">constraint-mapping</tt>:
      represents the resource path of an XML mapping file.</span> <span class="tck-testable">More than one <tt class="literal">constraint-mapping</tt>
      element can be present.</span> <span class="tck-testable">Mappings
      provided via
      <tt class="methodname">Configuration.addMapping(InputStream)</tt> are added
      to the list of mappings described via
      <tt class="literal">constraint-mapping</tt>.</span></p><p><tt class="literal">property</tt>: represents a key/value pair property
      providing room to provider specific configurations. Vendors should use
      vendor namespaces for properties (e.g.,
      <tt class="literal">com.acme.validation.logging</tt>). Entries that make use
      of the namespace <tt class="literal">javax.validation</tt> and its
      subnamespaces must not be used for vendor-specific information. <span class="tck-not-testable">The namespace
      <tt class="literal">javax.validation</tt> is reserved for use by this
      specification.</span> <span class="tck-not-testable">Properties
      defined via <tt class="methodname">Configuration.addProperty(String,
      String)</tt> are added to the properties defined via
      <tt class="literal">property</tt>.</span> <span class="tck-not-testable">If
      a property with the same name are defined in both XML and via the
      programmatic API, the value provided via programmatic API has
      priority.</span></p><p class="tck-testable">All these top level elements are
      optional.</p><p class="tck-testable">If a public no-arg constructor is missing on
      any of the classes referenced by the relevant XML elements, a
      <tt class="classname">ValidationException</tt> is raised during the
      <tt class="methodname">Configuration.buildValidatorFactory()</tt>
      call.</p><div class="example"><a name="d0e8726"></a><p class="title"><b>Example&nbsp;5.35.&nbsp;Example of META-INF/validation.xml file</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;validation-config
        xmlns="http://jboss.org/xml/ns/javax/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/configuration validation-configuration-1.1.xsd"
        version="1.1"&gt;
    &lt;default-provider&gt;com.acme.ACMEProvider&lt;/default-provider&gt;
    &lt;message-interpolator&gt;com.acme.ACMEAwareMessageInterpolator&lt;/message-interpolator&gt;

    &lt;executable-validation&gt;
        &lt;default-validated-executable-types&gt;
            &lt;executable-type&gt;NONE&lt;/executable-type&gt;
        &lt;/default-validated-executable-types&gt;
    &lt;/executable-validation&gt;

    &lt;constraint-mapping&gt;META-INF/validation/order-constraints.xml&lt;/constraint-mapping&gt;
    &lt;constraint-mapping&gt;META-INF/validation/catalog-constraints.xml&lt;/constraint-mapping&gt;
    &lt;constraint-mapping&gt;META-INF/validation/customer-constraints.xml&lt;/constraint-mapping&gt;

    &lt;property name="com.acme.validation.logging"&gt;WARN&lt;/property&gt;
    &lt;property name="com.acme.validation.safetyChecking"&gt;failOnError&lt;/property&gt;

&lt;/validation-config&gt;</pre></div><p>The XML schema is described in <a href="#xml-config-xsd" title="8.2.&nbsp;Configuration schema">Section&nbsp;8.2, &#8220;Configuration schema&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="bootstrapping-usageandcontainerexpectation"></a>5.5.7.&nbsp;Bootstrapping considerations</h3></div></div><div></div></div><p>The Bean Validation bootstrap API can be used directly by any
      application or made available through a container or other framework. In
      all cases, the following rules apply:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-not-testable"><tt class="classname">ValidatorFactory</tt> is a
          thread-safe object that should be built once per deployment
          unit</p></li><li><p><tt class="classname">ValidatorFactory</tt> should be closed when
          it is no longer needed (e.g. when the unit is undeployed or the
          server stopped).</p></li><li><p class="tck-not-testable"><tt class="classname">Validator</tt> is a
          thread-safe and lightweight object which can be cached by the
          <tt class="classname">ValidatorFactory</tt> instance.</p></li></ul></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="constraintmetadata"></a>Chapter&nbsp;6.&nbsp;Constraint metadata request APIs</h2></div></div><div></div></div><p>The Bean Validation specification provides a way to query the
  constraint repository. This API is expected to be used for tooling support
  as well as integration with other frameworks, libraries and JSRs. The Bean
  Validation specification aims to provide both a validation engine and a
  metadata repository for object constraints. Frameworks (EE or SE) in need
  for constraint definition, validation and metadata will be able to rely on
  the Bean Validation specification for these services avoiding any
  unnecessary duplication work from an application and infrastructure point of
  view.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8764"></a>6.1.&nbsp;Validator</h2></div></div><div></div></div><p>The main API to access all metadata related to a given object is
    <tt class="classname">Validator</tt> (see <a href="#bootstrapping" title="5.5.&nbsp;Bootstrapping">Section&nbsp;5.5, &#8220;Bootstrapping&#8221;</a> for
    more information on how to retrieve a <tt class="classname">Validator</tt>
    instance).</p><p>A <tt class="classname">Validator</tt> instance hosts the method to
    access to the metadata repository for a given class. It is recommended to
    leave the caching of <tt class="classname">Validator</tt> instances to the
    <tt class="classname">ValidatorFactory</tt>. <tt class="classname">Validator</tt>
    implementations are thread-safe.</p><div class="example"><a name="d0e8791"></a><p class="title"><b>Example&nbsp;6.1.&nbsp;Validator interface (metadata request API)</b></p><pre class="programlisting">/**
 * Validates bean instances. Implementations of this interface must be thread-safe.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @author Gunnar Morling
 */
public interface Validator {

    [...] //See 5.1

    /**
     * Returns the descriptor object describing bean constraints.
     * &lt;p/&gt;
     * The returned object (and associated objects including
     * {@link ConstraintDescriptor}s) are immutable.
     *
     * @param clazz class or interface type evaluated
     * @return the bean descriptor for the specified class
     * @throws IllegalArgumentException if clazz is {@code null}
     * @throws ValidationException if a non recoverable error happens
     *         during the metadata discovery or if some
     *         constraints are invalid.
     */
    BeanDescriptor getConstraintsForClass(Class&lt;?&gt; clazz);
}</pre></div><p><span class="tck-testable"><tt class="methodname">getConstraintsForClass()</tt>
    returns a <tt class="classname">BeanDescriptor</tt> object describing the bean
    level constraints (see <a href="#constraintdeclarationvalidationprocess-requirements-object" title="4.1.1.&nbsp;Object validation">Section&nbsp;4.1.1, &#8220;Object validation&#8221;</a>)
    and providing access to the property level constraints metadata.
    </span><span class="tck-testable">An
    <tt class="classname">IllegalArgumentException</tt> is raised if the
    <tt class="varname">clazz</tt> parameter is null.</span></p><p><span class="tck-testable">If a constraint definition or
    declaration hosted by the requested class (or any of it's superclasses and
    interfaces according to the constraint propagation rules) is invalid, a
    <tt class="classname">ValidationException</tt> is raised.</span> This can be
    a subclass of <tt class="classname">ValidationException</tt> like
    <tt class="classname">ConstraintDefinitionException</tt>,
    <tt class="classname">ConstraintDeclarationException</tt> or
    <tt class="classname">UnexpectedTypeException</tt>.</p><p>All descriptor types accessible via
    <tt class="methodname">getConstraintsForClass()</tt> and introduced in the
    following sections are located in the package
    <tt class="classname">javax.validation.metadata</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintmetadata-elementdescriptor"></a>6.2.&nbsp;ElementDescriptor</h2></div></div><div></div></div><p><tt class="classname">ElementDescriptor</tt> is the root interface
    describing elements hosting constraints. It is used to describe the list
    of constraints for a given element (whether it be a class, property,
    method etc.).</p><div class="example"><a name="d0e8848"></a><p class="title"><b>Example&nbsp;6.2.&nbsp;ElementDescriptor interface</b></p><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes a validated element (class, property, method etc.).
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @author Gunnar Morling
 */
public interface ElementDescriptor {

    /**
     * @return returns {@code true} if at least one constraint declaration is present
     *         for this element in the class hierarchy, {@code false} otherwise
     */
    boolean hasConstraints();

    /**
     * @return the statically defined returned type
     */
    Class&lt;?&gt; getElementClass();

    /**
     * Returns all constraint descriptors for this element in the class hierarchy
     * or an empty {@code Set} if none are present.
     *
     * @return {@code Set} of constraint descriptors for this element
     */
    Set&lt;ConstraintDescriptor&lt;?&gt;&gt; getConstraintDescriptors();

    /**
     * Finds constraints and potentially restricts them to certain criteria.
     *
     * @return {@code ConstraintFinder} object
     */
    ConstraintFinder findConstraints();

    /**
     * Declares restrictions on retrieved constraints.
     * Restrictions are cumulative.
     * &lt;p/&gt;
     * A {@code ConstraintFinder} is not thread-safe. The set of matching
     * {@link ConstraintDescriptor} is.
     */
    interface ConstraintFinder {

        /**
         * Restricts to the constraints matching a given set of groups for this element.
         * &lt;p/&gt;
         * This method respects group conversion, group sequences
         * and group inheritance (including class-level {@link Default} group
         * overriding) but does not return {@link ConstraintDescriptor}s
         * in any particular order.
         * Specifically, ordering of the group sequence is not respected.
         *
         * @param groups groups targeted
         * @return {@code this} following the chaining method pattern
         */
        ConstraintFinder unorderedAndMatchingGroups(Class&lt;?&gt;... groups);

        /**
         * Restricts to the constraints matching the provided scope for this element.
         *
         * Defaults to {@link Scope#HIERARCHY}
         *
         * @param scope expected scope
         * @return {@code this} following the chaining method pattern
         */
        ConstraintFinder lookingAt(Scope scope);

        /**
         * Restricts to the constraints hosted on the listed {@code types}
         * for a given element.
         * &lt;p/&gt;
         * Defaults to all possible types of the element.
         * &lt;p/&gt;
         * Typically used to restrict to fields ({@code FIELD})
         * or getters ({@code METHOD}).
         *
         * @param types targeted types
         *
         * @return {@code this} following the chaining method pattern
         */
        ConstraintFinder declaredOn(ElementType... types);

        /**
         * Retrieves the constraint descriptors following the defined
         * restrictions and hosted on the element described by
         * {@link ElementDescriptor}.
         *
         * @return matching constraint descriptors
         */
        Set&lt;ConstraintDescriptor&lt;?&gt;&gt; getConstraintDescriptors();

        /**
         * Returns {@code true} if at least one constraint declaration
         * matching the restrictions is present on the element,
         * {@code false} otherwise.
         *
         * @return {@code true} if there is at least one constraint
         */
        boolean hasConstraints();
    }
}</pre></div><pre class="programlisting">package javax.validation.metadata;

/**
 * Scope looked at when discovering constraints.
 *
 * @author Emmanuel Bernard
 */
public enum Scope {

    /**
     * Look for constraints declared on the current class element
     * and ignore inheritance and elements with the same name in
     * the class hierarchy.
     */
    LOCAL_ELEMENT,

    /**
     * Look for constraints declared on all elements of the class hierarchy
     * with the same name.
     */
    HIERARCHY
}</pre><p class="tck-testable"><tt class="methodname">getElementClass()</tt>
    returns</p><div class="itemizedlist"><ul type="disc"><li><p>the object type when invoked on
          <tt class="classname">BeanDescriptor</tt>,</p></li><li><p>the type of a property or parameter when invoked on
          <tt class="classname">PropertyDescriptor</tt> or
          <tt class="classname">ParameterDescriptor</tt> respectively,</p></li><li><p><tt class="literal">Object[].class</tt> when invoked on
          <tt class="classname">CrossParameterDescriptor</tt>,</p></li><li><p>the return type when invoked on
          <tt class="classname">ConstructorDescriptor</tt>,
          <tt class="classname">MethodDescriptor</tt> or
          <tt class="classname">ReturnValueDescriptor</tt>.</p></li></ul></div><p class="tck-testable"><tt class="classname">getConstraintDescriptors()</tt>
    returns all the <tt class="classname">ConstraintDescriptor</tt>s (see <a href="#constraintmetadata-constraintdescriptor" title="6.11.&nbsp;ConstraintDescriptor">Section&nbsp;6.11, &#8220;ConstraintDescriptor&#8221;</a>) hosted on the given
    element in the class hierarchy, each
    <tt class="classname">ConstraintDescriptor</tt> describing one of the
    constraints declared on the given element.</p><p class="tck-testable"><tt class="methodname">hasConstraints()</tt>
    returns <tt class="literal">true</tt> if the given element in the class
    hierarchy holds at least one constraint declaration.</p><p class="tck-testable">If you need to query the metadata API in a more
    fine grained way for example by restricting the constraints to the one
    described on fields or on getters or by restricting to a given set of
    groups, you can use the <tt class="classname">ConstraintFinder</tt> fluent API
    by calling <tt class="methodname">findConstraints()</tt>.</p><p class="tck-testable"><tt class="classname">unorderedAndMatchingGroups()</tt>
    restricts the results to the <tt class="classname">ConstraintDescriptor</tt>s
    (see <a href="#constraintmetadata-constraintdescriptor" title="6.11.&nbsp;ConstraintDescriptor">Section&nbsp;6.11, &#8220;ConstraintDescriptor&#8221;</a>) matching
    the given groups. Order is not respected but group inheritance and
    inheritance via sequence (including the <tt class="classname">Default</tt>
    group overriding at the class level) are honored.</p><p><span class="tck-testable"><tt class="methodname">declaredOn()</tt>
    lets you restrict the list of element types constraints are hosted
    on.</span> This is particularly useful to retrieve property constraints
    only hosted on fields (<tt class="classname">ElementType.FIELD</tt>) or only
    hosted on getters (<tt class="classname">ElementType.METHOD</tt>).</p><p class="tck-testable"><tt class="methodname">lookingAt()</tt> lets you
    restrict which constraints are considered. Either constraints belonging to
    the element but hosted on the class represented by the given descriptor
    (<tt class="classname">Scope.LOCAL_ELEMENT</tt>), or constraints belonging to
    the element but hosted anywhere in the class hierarchy
    (<tt class="classname">Scope.HIERARCHY</tt>).</p><p>Here is an example restricting the list of constraints on getters,
    matching the default group and declared physically on the
    <tt class="literal">name</tt> getter of <tt class="classname">Customer</tt> (and not
    any of the getters on the super classes).</p><div class="example"><a name="d0e8964"></a><p class="title"><b>Example&nbsp;6.3.&nbsp;Using the fluent API to restrict matching constraints</b></p><pre class="programlisting">public class User {

    @Size(max=50) 
    String getName() {
        [...]
    }

    [...]
}

public class Customer extends User {

    @NotNull
    String getName() {
        [...]
    }
}

PropertyDescriptor pd = 
    validator.getConstraintsForClass(Customer.class).getConstraintsForProperty("name");
Set&lt;ConstraintDescriptor&lt;?&gt;&gt; constraints = 
    pd.findConstraints()
        .declaredOn(ElementType.METHOD)
        .unorderedAndMatchingGroups(Default.class)
        .lookingAt(Scope.LOCAL_ELEMENT)
        .getConstraintDescriptors();

assert 1 == constraints.size();

constraints = pd.getConstraintDescriptors();
//equivalent to pd.findConstraints().getConstraintDescriptors();
assert 2 == constraints.size();</pre></div><p>The following example shows how the fluent API is used to retrieve
    parameter, cross-parameter and return value constraints, taking into
    account locally declared constraints as well as constraints declared in
    the inheritance hierarchy.</p><div class="example"><a name="d0e8971"></a><p class="title"><b>Example&nbsp;6.4.&nbsp;Using the fluent API to select method and constructor
      constraints</b></p><pre class="programlisting">public class User {

    public User(@Size(max=50) String name) {
        [...]
    }

    @PasswordParametersMatch
    @NotNull
    public String resetPassword(
        @NotNull @Size(min=8) String password,
        @NotNull @Size(min=8) String confirmation) {
        [...]
    }
}

public class Customer extends User {

    public Customer(@NotNull String name) {
        [...]
    }

    @Size(min=8)
    public String resetPassword(String password, String confirmation) {
        [...]
    }
}

MethodDescriptor methodDescriptor = validator
    .getConstraintsForClass( Customer.class )
    .getConstraintsForMethod( "resetPassword", String.class, String.class );

//one cross-parameter constraint
assert 1 == methodDescriptor.getCrossParameterDescriptor().getConstraintDescriptors().size();

//one local return value constraint
assert 1 == methodDescriptor.getReturnValueDescriptor()
    .findConstraints()
    .lookingAt( Scope.LOCAL_ELEMENT )
    .getConstraintDescriptors()
    .size();

//two return value constraints in the complete hierarchy
assert 2 == methodDescriptor.getReturnValueDescriptor()
    .findConstraints()
    .lookingAt( Scope.HIERARCHY )
    .getConstraintDescriptors()
    .size();

//two parameter constraints, defined on overridden method
assert 2 == methodDescriptor.getParameterDescriptors()
    .get( 0 )
    .getConstraintDescriptors()
    .size();

ConstructorDescriptor constructorDescriptor = validator
    .getConstraintsForClass( Customer.class )
    .getConstraintsForConstructor( String.class );

//one parameter constraint; constraints from super constructor don't apply
assert 1 == constructorDescriptor.getParameterDescriptors()
    .get( 0 )
    .findConstraints()
    .lookingAt( Scope.HIERARCHY )
    .getConstraintDescriptors()
    .size();</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8976"></a>6.3.&nbsp;BeanDescriptor</h2></div></div><div></div></div><p>The <tt class="classname">BeanDescriptor</tt> interface describes a
    constrained Java Bean. This interface is returned by
    <tt class="methodname">Validator.getConstraintsForClass(Class&lt;?&gt;)</tt>.</p><div class="example"><a name="d0e8987"></a><p class="title"><b>Example&nbsp;6.5.&nbsp;BeanDescriptor interface</b></p><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes a constrained Java Bean and the constraints associated to it. All
 * objects returned by the methods of this descriptor (and associated objects
 * including {@link ConstraintDescriptor}s) are immutable.
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 */
public interface BeanDescriptor extends ElementDescriptor {

    /**
     * Returns {@code true} if the bean involves validation:
     * &lt;ul&gt;
     *     &lt;li&gt;a constraint is hosted on the bean itself&lt;/li&gt;
     *     &lt;li&gt;a constraint is hosted on one of the bean properties&lt;/li&gt;
     *     &lt;li&gt;or a bean property is marked for cascaded validation ({@link Valid})&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p/&gt;
     * Constrained methods and constructors are ignored.
     *
     * @return {@code true} if the bean involves validation, {@code false} otherwise
     */
    boolean isBeanConstrained();

    /**
     * Returns the property descriptor for a given property.
     * &lt;p/&gt;
     * Returns {@code null} if the property does not exist or has no
     * constraint nor is marked as cascaded (see {@link #getConstrainedProperties()})
     * Properties of super types are considered.
     *
     * @param propertyName property evaluated
     * @return the property descriptor for a given property
     * @throws IllegalArgumentException if {@code propertyName} is {@code null}
     */
    PropertyDescriptor getConstraintsForProperty(String propertyName);

    /**
     * Returns a set of property descriptors having at least one constraint defined
     * or marked as cascaded ({@link Valid}).
     * &lt;p/&gt;
     * If not property matches, an empty set is returned.
     * Properties of super types are considered.
     *
     * @return the set of {@link PropertyDescriptor}s for the constraint properties; if
     *         there are no constraint properties, the empty set is returned
     */
    Set&lt;PropertyDescriptor&gt; getConstrainedProperties();

    /**
     * Returns a method descriptor for the given method.
     * &lt;p/&gt;
     * Returns {@code null} if no method with the given name and parameter types
     * exists or the specified method neither has parameter or return value constraints nor a parameter
     * or return value marked for cascaded validation.
     * Methods of super types are considered.
     *
     * @param methodName the name of the method
     * @param parameterTypes the parameter types of the method
     * @return a method descriptor for the given method
     * @throws IllegalArgumentException if {@code methodName} is {@code null}
     *
     * @since 1.1
     */
    MethodDescriptor getConstraintsForMethod(String methodName, Class&lt;?&gt;... parameterTypes);

    /**
     * Returns a set with descriptors for the constrained methods of the bean
     * represented by this descriptor.
     * &lt;p/&gt;
     * Constrained methods have at least one parameter or return value constraint
     * or at least one parameter or return value marked for cascaded validation.
     * Methods of super types are considered.
     * &lt;p/&gt;
     * Only methods matching the given method type(s) are considered.
     *
     * @param methodType method type to consider
     * @param methodTypes remaining optional method types to consider
     * @return a set with descriptors for the constrained methods of this bean;
     *         will be empty if this bean has no constrained methods of the considered
     *         method type(s) but never {@code null}
     *
     * @since 1.1
     */
    Set&lt;MethodDescriptor&gt; getConstrainedMethods(MethodType methodType, MethodType... methodTypes);

    /**
     * Returns a constructor descriptor for the given constructor.
     * &lt;p/&gt;
     * Returns {@code null} if no constructor with the given parameter types
     * exists or the specified constructor neither has parameter or return value
     * constraints nor a parameter or return value marked for cascaded
     * validation.
     * Constructor of super types are considered.
     *
     * @param parameterTypes the parameter types of the constructor
     * @return a constructor descriptor for the given constructor
     *
     * @since 1.1
     */
    ConstructorDescriptor getConstraintsForConstructor(Class&lt;?&gt;... parameterTypes);

    /**
     * Returns a set with descriptors for the constrained constructors of the
     * bean represented by this descriptor.
     * &lt;p/&gt;
     * Constrained constructors have at least one parameter or return value constraint
     * or at least one parameter or return value marked for cascaded validation.
     *
     * @return a set with descriptors for the constrained constructor of this
     *         bean; will be empty if this bea has no constrained constructor
     *         but never {@code null}
     *
     * @since 1.1
     */
    Set&lt;ConstructorDescriptor&gt; getConstrainedConstructors();
}</pre></div><div class="example"><a name="d0e8992"></a><p class="title"><b>Example&nbsp;6.6.&nbsp;MethodType</b></p><pre class="programlisting">package javax.validation.metadata;

/**
 * Represents the type of a method: getter or non getter.
 *
 * @author Emmanuel Bernard &lt;emmanuel@hibernate.org&gt;
 * @since 1.1
 */
public enum MethodType {

    /**
     * A method following the getter pattern. A getter according to the
     * JavaBeans specification is a method whose:
     * &lt;ul&gt;
     *     &lt;li&gt;name starts with get, has a return type but no parameter&lt;/li&gt;
     *     &lt;li&gt;name starts with is, has a return type and is returning {@code boolean}.&lt;/li&gt;
     * &lt;/ul&gt;
     */
    GETTER,

    /**
     * A method that does not follow the getter pattern. A getter according to the
     * JavaBeans specification is a method whose:
     * &lt;ul&gt;
     *     &lt;li&gt;name starts with get, has a return type but no parameter&lt;/li&gt;
     *     &lt;li&gt;name starts with is, has a return type and is returning {@code boolean}.&lt;/li&gt;
     * &lt;/ul&gt;
     */
    NON_GETTER
}</pre></div><p><span class="tck-testable"><tt class="methodname">isBeanConstrained()</tt> returns
    <tt class="literal">true</tt> if the given class (and superclasses and
    interfaces) has at least one class-level or property-level constraint or
    validation cascade.</span> If the method returns false, the Bean
    Validation engine can safely ignore the bean as it will not be impacted by
    validation.</p><p><span class="tck-testable"><tt class="methodname">getConstraintsForProperty()</tt>
    returns a <tt class="classname">PropertyDescriptor</tt> object describing the
    property level constraints (See <a href="#constraintdeclarationvalidationprocess-requirements-property" title="4.1.2.&nbsp;Field and property validation">Section&nbsp;4.1.2, &#8220;Field and property validation&#8221;</a>).
    The property is uniquely identified by its name as per the JavaBeans
    convention: field level and getter level constraints of the given name are
    all returned. </span><span class="tck-testable">An
    <tt class="classname">IllegalArgumentException</tt> is raised if the
    <tt class="varname">propertyName</tt> parameter is null.</span></p><p class="tck-testable"><tt class="methodname">getConstrainedProperties()</tt>
    returns the <tt class="classname">PropertyDescriptor</tt>s of the bean
    properties having at least one constraint or being cascaded
    (<tt class="classname">@Valid</tt> annotation).</p><p class="tck-testable"><tt class="methodname">getConstraintsForMethod()</tt>
    returns a <tt class="classname">MethodDescriptor</tt> object describing the
    method constraints of the given method. The method is uniquely identified
    by its name and the types of its parameters.</p><p class="tck-testable"><tt class="methodname">getConstrainedMethods()</tt>
    returns the <tt class="classname">MethodDescriptor</tt>s of the methods
    matching the <tt class="classname">MethodType</tt>s provided as parameter and
    having at least one constraint or cascaded parameter or return
    value.</p><p class="tck-testable"><tt class="methodname">getConstraintsForConstructor()</tt>
    returns a <tt class="classname">ConstructorDescriptor</tt> object describing
    the method constraints of the given constructor. The constructor is
    uniquely identified by its name and the types of its parameters.</p><p class="tck-testable"><tt class="methodname">getConstrainedConstructors()</tt>
    returns the <tt class="classname">ConstructorDescriptor</tt>s of the
    constructors having at least one constraint or cascaded parameter or
    return value.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9065"></a>6.4.&nbsp;CascadableDescriptor</h2></div></div><div></div></div><p>The <tt class="classname">CascadableDescriptor</tt> interface describes
    a cascadable element, i.e. an element which can be marked with
    <tt class="classname">@Valid</tt> in order to perform a cascaded validation of
    the element as described in <a href="#constraintdeclarationvalidationprocess-requirements-graphvalidation" title="4.1.3.&nbsp;Graph validation">Section&nbsp;4.1.3, &#8220;Graph validation&#8221;</a>.</p><pre class="programlisting">package javax.validation.metadata;

/**
 * Represents a cascadable element.
 *
 * @author Gunnar Morling
 * @since 1.1
 */
public interface CascadableDescriptor {

    /**
     * Whether this element is marked for cascaded validation or not.
     *
     * @return {@code true}, if this element is marked for cascaded validation,
     *         {@code false} otherwise
     */
    boolean isCascaded();

    /**
     * Returns the group conversions configured for this element.
     *
     * @return a set containing this element's group conversions; an empty set
     *         may be returned if no conversions are configured but never
     *         {@code null}
     */
    Set&lt;GroupConversionDescriptor&gt; getGroupConversions();
}</pre><p class="tck-testable">The <tt class="methodname">isCascaded()</tt> method
    returns <tt class="literal">true</tt> if the element is marked for cascaded
    validation.</p><p class="tck-testable"><span class="tck-testable">The method
    <tt class="methodname">getGroupConversions()</tt> returns a set with the
    group conversions declared for the cascadable element.</span> <span class="tck-testable">An empty set will be returned if no group conversions
    are configured.</span></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9097"></a>6.5.&nbsp;GroupConversionDescriptor</h2></div></div><div></div></div><p>The <tt class="classname">GroupConversionDescriptor</tt> interface
    describes a group conversion rule configured for a cascadable element as
    described in <a href="#constraintdeclarationvalidationprocess-groupsequence-groupconversion" title="4.4.5.&nbsp;Group conversion">Section&nbsp;4.4.5, &#8220;Group conversion&#8221;</a>.
    It is returned by
    <tt class="methodname">CascadableDescriptor.getGroupConversions()</tt>.</p><pre class="programlisting">package javax.validation.metadata;

/**
 * A group conversion rule to be applied during cascaded validation. Two group
 * conversion descriptors are considered equal if they have the same
 * {@code from} and {@code to} group respectively.
 *
 * @author Gunnar Morling
 * @see ConvertGroup
 * @since 1.1
 */
public interface GroupConversionDescriptor {

    /**
     * Returns the source group of this conversion rule.
     *
     * @return the source group of this conversion rule
     */
    Class&lt;?&gt; getFrom();

    /**
     * Returns the target group of this conversion rule.
     *
     * @return the target group of this conversion rule
     */
    Class&lt;?&gt; getTo();
}</pre><p class="tck-testable">The <tt class="methodname">getFrom()</tt> method
    returns the source of a group conversion rule.</p><p class="tck-testable">The <tt class="methodname">getTo()</tt> method
    returns the target of a group conversion rule.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9122"></a>6.6.&nbsp;PropertyDescriptor</h2></div></div><div></div></div><p>The <tt class="classname">PropertyDescriptor</tt> interface describes a
    constrained property of a Java Bean.</p><p>This interface is returned by
    <tt class="methodname">BeanDescriptor.getConstraintsForProperty(String)</tt>
    or <tt class="methodname">BeanDescriptor.getConstrainedProperties()</tt>.
    Constraints declared on the attribute and the getter of the same name
    according to the JavaBeans rules are returned by this descriptor.</p><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes a Java Bean property hosting validation constraints.
 *
 * Constraints placed on the attribute and the getter of a given property
 * are all referenced.
 *
 * @author Emmanuel Bernard
 */
public interface PropertyDescriptor extends ElementDescriptor, CascadableDescriptor {

    /**
     * Name of the property according to the Java Bean specification.
     *
     * @return property name
     */
    String getPropertyName();
}</pre><p class="tck-testable"><tt class="methodname">getPropertyName()</tt>
    returns the property name as described in <a href="#validationapi-constraintviolation" title="5.2.&nbsp;ConstraintViolation">Section&nbsp;5.2, &#8220;ConstraintViolation&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9146"></a>6.7.&nbsp;ExecutableDescriptor, MethodDescriptor and
    ConstructorDescriptor</h2></div></div><div></div></div><p>The <tt class="classname">ExecutableDescriptor</tt> interface describes
    a constrained method or constructor of a Java type.</p><pre class="programlisting">package javax.validation.metadata;

/**
 * Provides the common functionality of {@link MethodDescriptor} and
 * {@link ConstructorDescriptor}.
 *
 * @author Gunnar Morling
 *
 * @since 1.1
 */
public interface ExecutableDescriptor extends ElementDescriptor {

    /**
     * Returns the method name in case this descriptor represents a method or
     * the non-qualified name of the declaring class in case this descriptor
     * represents a constructor.
     *
     * @return the name of the executable represented by this descriptor
     */
    String getName();

    /**
     * Returns a list of descriptors representing this executable's
     * parameters, in the order of their declaration, including synthetic
     * parameters.
     *
     * @return a list of descriptors representing this executable's
     *         parameters; an empty list will be returned if this executable has
     *         no parameters, but never {@code null}
     */
    List&lt;ParameterDescriptor&gt; getParameterDescriptors();

    /**
     * Returns a descriptor containing the cross-parameter constraints
     * of this executable.
     *
     * @return a descriptor containing the cross-parameter constraints of
     *         this executable
     */
    CrossParameterDescriptor getCrossParameterDescriptor();

    /**
     * Returns a descriptor for this executable's return value.
     * &lt;p/&gt;
     * An executable without return value will return a descriptor
     * representing {@code void}. This descriptor will have no constraint
     * associated.
     *
     * @return a descriptor for this executable's return value
     */
    ReturnValueDescriptor getReturnValueDescriptor();

    /**
     * Returns {@code true} if the executable parameters are constrained either:
     * &lt;ul&gt;
     *     &lt;li&gt;because of a constraint on at least one of the parameters&lt;/li&gt;
     *     &lt;li&gt;because of a cascade on at least one of the parameters (via
     *     {@link Valid})&lt;/li&gt;
     *     &lt;li&gt;because of at least one cross-parameter constraint&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p/&gt;
     * Also returns {@code false} if there is no parameter.
     *
     * @return {@code true} if the executable parameters are constrained
     */
    boolean hasConstrainedParameters();

    /**
     * Returns {@code true} if the executable return value is constrained
     * either:
     * &lt;ul&gt;
     *     &lt;li&gt;because of a constraint on the return value&lt;/li&gt;
     *     &lt;li&gt;because validation is cascaded on the return value (via
     *     {@link Valid})&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p/&gt;
     * Also returns {@code false} if there is no return value.
     *
     * @return {@code true} if the executable return value is constrained
     */
    boolean hasConstrainedReturnValue();

    /**
     * Returns {@code false}.
     * &lt;p/&gt;
     * An executable per se does not host constraints, use
     * {@link #getParameterDescriptors()}, {@link #getCrossParameterDescriptor()}
     * and {@link #getReturnValueDescriptor()} to discover constraints.
     *
     * @return {@code false}
     */
    @Override
    boolean hasConstraints();

    /**
     * Returns an empty {@code Set}.
     * &lt;p/&gt;
     * An executable per se does not host constraints, use
     * {@link #getParameterDescriptors()}, {@link #getCrossParameterDescriptor()}
     * and {@link #getReturnValueDescriptor()} to discover constraints.
     *
     * @return an empty {@code Set}
     */
    @Override
    Set&lt;ConstraintDescriptor&lt;?&gt;&gt; getConstraintDescriptors();

    /**
     * Returns a finder that will always return an empty {@code Set}.
     * &lt;p/&gt;
     * An executable per se does not host constraints, use
     * {@link #getParameterDescriptors()}, {@link #getCrossParameterDescriptor()}
     * and {@link #getReturnValueDescriptor()} to discover constraints.
     *
     * @return {@code ConstraintFinder} object
     */
    @Override
    ConstraintFinder findConstraints();
}</pre><p class="tck-testable"><tt class="methodname">getName()</tt> returns the
    name of the represented method (e.g. "placeOrder") respectively the
    non-qualified name of the declaring class of the represented constructor
    (e.g. "OrderService").</p><p class="tck-testable"><tt class="methodname">getParameterDescriptors()</tt>
    returns a list of <tt class="classname">ParameterDescriptor</tt>s representing
    the method's or constructor's parameters in order of their declaration,
    including synthetic parameters. An empty list will be returned in case the
    method or constructor has no parameters.</p><p class="tck-testable"><tt class="methodname">getCrossParameterDescriptor()</tt>
    returns a descriptor containing cross-parameter constraints of the method
    or constructor. If no cross-parameter constraint is present, the
    descriptor will return an empty set of constraint descriptors.</p><p class="tck-testable"><tt class="methodname">getReturnValueDescriptor()</tt>
    returns a descriptor for the method's or constructor's return value. A
    descriptor representing the special class <tt class="classname">void</tt>,
    without any constraint descriptors, will be returned for executables which
    have no return value.</p><p class="tck-testable"><tt class="classname">hasConstrainedParameters()</tt>
    returns <tt class="literal">true</tt> if any of the parameters is constrained or
    cascaded or if the represented executable has at least one cross-parameter
    constraint. Returns <tt class="literal">false</tt> if there is no
    parameter.</p><p class="tck-testable"><tt class="classname">hasConstrainedReturnValue()</tt>
    returns <tt class="literal">true</tt> if the return value is constrained or
    cascaded. Returns <tt class="literal">false</tt> if there is no return
    value.</p><p class="tck-testable">The methods
    <tt class="methodname">hasConstraints()</tt>,
    <tt class="methodname">getConstraintDescriptors()</tt> and
    <tt class="methodname">findConstraints()</tt> defined on
    <tt class="classname">ElementDescriptor</tt> are redefined to clarify that
    executables do not host constraints directly and thus will always return
    <tt class="literal">false</tt> or an empty set of constraints, respectively.
    Constraint descriptors for individual parameters can be obtained from the
    corresponding <tt class="classname">ParameterDescriptor</tt> object,
    constraint descriptors for cross-parameter constraints can be obtained
    from the corresponding <tt class="classname">CrossParameterDescriptor</tt>
    object and constraint descriptors for the return value can be obtained
    from <tt class="classname">ReturnValueDescriptor</tt>.</p><p>The interfaces <tt class="classname">MethodDescriptor</tt> and
    <tt class="classname">ConstructorDescriptor</tt> are derived from
    <tt class="classname">ExecutableDescriptor</tt> and allow to distinguish
    between descriptors representing methods and descriptors representing
    constructors.</p><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes a validated method.
 *
 * @author Gunnar Morling
 * @author Emmanuel Bernard
 * @since 1.1
 */
public interface MethodDescriptor extends ExecutableDescriptor {
}</pre><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes a validated constructor.
 *
 * @author Gunnar Morling
 * @author Emmanuel Bernard
 * @since 1.1
 */
public interface ConstructorDescriptor extends ExecutableDescriptor {
}</pre><p><tt class="classname">MethodDescriptor</tt> objects are returned by
    <tt class="methodname">BeanDescriptor.getConstraintsForMethod(String,
    Class&lt;?&gt;...)</tt> and
    <tt class="methodname">BeanDescriptor.getConstrainedMethods(MethodType,
    MethodType...)</tt>, while
    <tt class="classname">ConstructorDescriptor</tt> objects are returned by
    <tt class="methodname">BeanDescriptor.getConstraintsForConstructor(Class&lt;?&gt;...)</tt>
    and
    <tt class="methodname">BeanDescriptor.getConstrainedConstructors()</tt>.</p><p class="tck-testable">None of the metadata API methods honor the XML
    configuration around executable validation nor the presence of
    <tt class="classname">@ValidateOnExecution</tt>. In other words, all
    constrained methods and constructors will be returned by the metadata API
    regardless of these settings.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9263"></a>6.8.&nbsp;ParameterDescriptor</h2></div></div><div></div></div><p>The <tt class="classname">ParameterDescriptor</tt> interface describes a
    constrained parameter of a method or constructor.</p><p>This interface is returned by
    <tt class="methodname">MethodDescriptor.getParameterDescriptors()</tt> and
    <tt class="methodname">ConstructorDescriptor.getParameterDescriptors()</tt>.</p><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes a validated method or constructor parameter.
 *
 * @author Gunnar Morling
 * @since 1.1
 */
public interface ParameterDescriptor extends ElementDescriptor, CascadableDescriptor {

    /**
     * Returns this parameter's index within the parameter array of the method
     * or constructor holding it.
     *
     * @return this parameter's index
     */
    int getIndex();

    /**
     * Returns this parameter's name as retrieved by the current parameter name
     * resolver.
     *
     * @return this parameter's name
     */
    String getName();
}</pre><p class="tck-testable"><tt class="methodname">getIndex()</tt> returns the
    index of the represented parameter within the parameter array of the
    method or constructor holding it.</p><p class="tck-testable"><tt class="methodname">getName()</tt> returns the
    name of the represented parameter.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9289"></a>6.9.&nbsp;CrossParameterDescriptor</h2></div></div><div></div></div><p>The <tt class="classname">CrossParameterDescriptor</tt> interface
    describes a element containing all cross-parameter constraints of a method
    or constructor.</p><p>This interface is returned by
    <tt class="methodname">MethodDescriptor.getCrossParameterDescriptor()</tt>
    and
    <tt class="methodname">ConstructorDescriptor.getCrossParameterDescriptor()</tt>.</p><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes an element holding cross-parameter constraints of a method or constructor
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
public interface CrossParameterDescriptor extends ElementDescriptor {

    /**
     * @return {@code Object[].class} - the type of the parameter array
     */
    @Override
    Class&lt;?&gt; getElementClass();
}</pre><p class="tck-testable"><tt class="methodname">getElementClass()</tt>
    returns <tt class="classname">Object[]</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9314"></a>6.10.&nbsp;ReturnValueDescriptor</h2></div></div><div></div></div><p>The <tt class="classname">ReturnValueDescriptor</tt> interface describes
    the return value of a method or constructor.</p><p>This interface is returned by
    <tt class="methodname">MethodDescriptor.getReturnValueDescriptor()</tt> and
    <tt class="methodname">ConstructorDescriptor.getReturnValueDescriptor()</tt>.</p><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes a validated return value of a method or constructor.
 *
 * @author Gunnar Morling
 * @since 1.1
 */
public interface ReturnValueDescriptor extends ElementDescriptor, CascadableDescriptor {
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintmetadata-constraintdescriptor"></a>6.11.&nbsp;ConstraintDescriptor</h2></div></div><div></div></div><p>A <tt class="classname">ConstraintDescriptor</tt> object describes a
    given constraint declaration (i.e. a constraint annotation).</p><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes a single constraint and its composing constraints.
 * &lt;p/&gt;
 * {@code T} is the constraint's annotation type.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintDescriptor&lt;T extends Annotation&gt; {

    /**
     * Returns the annotation describing the constraint declaration.
     * If a composing constraint, attribute values are reflecting
     * the overridden attributes of the composing constraint
     *
     * @return the annotation for this constraint
     */
    T getAnnotation();

    /**
     * The non-interpolated error message
     *
     * @return the non-interpolated error message
     *
     * @since 1.1
     */
    String getMessageTemplate();

    /**
     * The set of groups the constraint is applied on.
     * If the constraint declares no group, a set with only the {@link Default}
     * group is returned.
     *
     * @return the groups the constraint is applied on
     */
    Set&lt;Class&lt;?&gt;&gt; getGroups();

    /**
     * The set of payload the constraint hosts.
     *
     * @return payload classes hosted on the constraint or an empty set if none
     */
    Set&lt;Class&lt;? extends Payload&gt;&gt; getPayload();

    /**
     * The {@link ConstraintTarget} value of {@code validationAppliesTo} if the constraint
     * hosts it or {@code null} otherwise.
     *
     * @return the {@code ConstraintTarget} value or {@code null}
     *
     * @since 1.1
     */
    ConstraintTarget getValidationAppliesTo();

    /**
     * List of the constraint validation implementation classes.
     *
     * @return list of the constraint validation implementation classes
     */
    List&lt;Class&lt;? extends ConstraintValidator&lt;T, ?&gt;&gt;&gt; getConstraintValidatorClasses();

    /**
     * Returns a map containing the annotation attribute names as keys and the
     * annotation attribute values as value.
     * &lt;p/&gt;
     * If this constraint is used as part of a composed constraint, attribute
     * values are reflecting the overridden attribute of the composing constraint.
     *
     * @return a map containing the annotation attribute names as keys
     *         and the annotation attribute values as value
     */
    Map&lt;String, Object&gt; getAttributes();

    /**
     * Return a set of composing {@link ConstraintDescriptor}s where each
     * descriptor describes a composing constraint. {@code ConstraintDescriptor}
     * instances of composing constraints reflect overridden attribute values in
     * {@link #getAttributes()}  and {@link #getAnnotation()}.
     *
     * @return a set of {@code ConstraintDescriptor} objects or an empty set
     *         in case there are no composing constraints
     */
    Set&lt;ConstraintDescriptor&lt;?&gt;&gt; getComposingConstraints();

    /**
     * @return {@code true} if the constraint is annotated with {@link ReportAsSingleViolation}
     */
    boolean isReportAsSingleViolation();
}</pre><p><span class="tck-testable"><tt class="methodname">getAnnotation()</tt>
    returns the annotation instance (or an annotation instance representing
    the given constraint declaration).</span> <span class="tck-testable">If
    <tt class="classname">ConstraintDescriptor</tt> represents a composing
    annotation (see <a href="#constraintsdefinitionimplementation-constraintcomposition" title="3.3.&nbsp;Constraint composition">Section&nbsp;3.3, &#8220;Constraint composition&#8221;</a>),
    the returned annotation must reflect parameter overriding.</span> In
    other words, the annotation parameter values are the overridden
    values.</p><p><span class="tck-testable"><tt class="methodname">getAttributes()</tt>
    returns a map containing the annotation attribute names as a key, and the
    annotation attribute values as a value</span> (this API is anticipated
    to be simpler to use by tools than reflection over the annotation
    instance). <span class="tck-testable">If
    <tt class="classname">ConstraintDescriptor()</tt> represents a composing
    annotation (see <a href="#constraintsdefinitionimplementation-constraintcomposition" title="3.3.&nbsp;Constraint composition">Section&nbsp;3.3, &#8220;Constraint composition&#8221;</a>),
    the returned <tt class="classname">Map</tt> must reflect attribute
    overriding.</span></p><p class="tck-testable"><tt class="methodname">getMessageTemplate()</tt>
    returns the non-interpolated error message.</p><p><span class="tck-testable"><tt class="methodname">getGroups()</tt>
    returns the groups the constraint is supposed to be applied upon.</span>
    <span class="tck-testable">If no group is set on the constraint
    declaration, the <tt class="classname">Default</tt> group is
    returned.</span> <span class="tck-testable">The groups of a composing
    constraint are the groups of the composed constraint.</span></p><p><span class="tck-testable"><tt class="literal">getPayload()</tt> returns
    the payloads associated to the constraint or an empty set if
    none.</span> <span class="tck-testable">The payload from the main
    constraint annotation is inherited by the composing annotations.</span>
    <span class="tck-testable">Any payload definition on a composing
    annotation is ignored.</span></p><p class="tck-testable"><tt class="methodname">getValidationAppliesTo()</tt>
    returns the <tt class="classname">ConstraintTarget</tt> returned by
    <tt class="methodname">validationAppliesTo</tt> if the constraint hosts the
    attribute or <tt class="literal">null</tt> otherwise. The constraint target from
    the main constraint annotation is inherited by the composing annotation.
    Any constraint target definition on a composing annotation is
    ignored.</p><p class="tck-testable"><tt class="methodname">isReportAsSingleViolation()</tt>
    returns <tt class="literal">true</tt> if the constraint is annotated with
    <tt class="classname">@ReportAsSingleViolation</tt>.</p><p class="tck-testable"><tt class="methodname">getComposingConstraints()</tt>
    return a set of composing <tt class="classname">ConstraintDescriptor</tt>s
    where each descriptor describes a composing constraint.</p><p class="tck-testable"><tt class="methodname">getConstraintValidatorClasses()</tt>
    returns the <tt class="classname">ConstraintValidator</tt> classes associated
    with the constraint.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9438"></a>6.12.&nbsp;Example</h2></div></div><div></div></div><p>Assuming the following constraint definitions</p><pre class="programlisting">package com.acme.constraint;

@Documented
@NotNull
@Size(min=1)
@ReportAsSingleViolation
@Constraint(validatedBy = NotEmpty.NotEmptyValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface NotEmpty {
    String message() default "{com.acme.constraint.NotEmpty.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default { };

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        NotEmpty[] value();
    }

    class NotEmptyValidator implements ConstraintValidator&lt;NotEmpty, String&gt; {
        @Override
        public void initialize(NotEmpty constraintAnnotation) {}

        @Override
        public boolean isValid(String value, ConstraintValidatorContext context) {
            return true;
        }
    }
}

@Documented
@Constraint(validatedBy = ValidInterval.Validator.class)
@Target({ METHOD, ANNOTATION_TYPE, CONSTRUCTOR })
@Retention(RUNTIME)
public @interface ValidInterval {
    String message() default "{com.acme.constraint.ValidInterval.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default { };
    int startParameter();
    int endParameter();

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        ValidInterval[] value();
    }

    @SupportedValidationTarget(PARAMETERS)
    class Validator implements ConstraintValidator&lt;ValidInterval, Object[]&gt; {
        
        private int start;
        private int end;

        @Override
        public void initialize(ValidInterval constraintAnnotation) {
            this.start = constraintAnnotation.startParameter();
            this.end = constraintAnnotation.endParameter();
        }

        @Override
        public boolean isValid(Object[] value, ConstraintValidatorContext context) {
            return Integer.parseInt( String.valueOf( value[start] ) ) &lt; 
                   Integer.parseInt( String.valueOf( value[end] ) );
        }
    }
}</pre><p>and the following class definitions</p><pre class="programlisting">public class Author {
    private String firstName;
    
    @NotEmpty(message="lastname must not be null")
    private String lastName;

    @Size(max=30)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}

public class Book {

    public interface FirstLevelCheck {}
    public interface SecondLevelCheck {}
    
    private String title;
    private String description;

    @Valid
    @NotNull
    private Author author;

    @Valid
    public Book(
            String title, 
            @Size(max=30) String description, 
            @Valid
            @ConvertGroup(from=Default.class, to=SecondLevelCheck.class)
            Author author) {
        [...]
    }
    
    public Book() {
        [...]
    }
     
    @NotEmpty(groups={FirstLevelCheck.class, Default.class})
    @Size(max=30)
    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }

    public String getDescription() {
        return description;
    }

    public void setAuthor(String description) {
        this.description = description;
    }
    
    @ValidInterval(startParameter=1, endParameter=2)
    public void addChapter(String title, int startPage, int endPage) {
        [...]
    }
}</pre><p>The following assertions are true.</p><pre class="programlisting">BeanDescriptor bookDescriptor = validator.getConstraintsForClass(Book.class);

assert ! bookDescriptor.hasConstraints();

assert bookDescriptor.isBeanConstrained();
assert bookDescriptor.getConstrainedMethods( MethodType.NON_GETTER ).size() &gt; 0;


assert bookDescriptor.getConstraintDescriptors().size() == 0; //no bean-level constraint

//more specifically "author" and "title"
assert bookDescriptor.getConstrainedProperties().size() == 2;

//not a property
assert bookDescriptor.getConstraintsForProperty("doesNotExist") == null; 

//property with no constraint
assert bookDescriptor.getConstraintsForProperty("description") == null; 

PropertyDescriptor propertyDescriptor = bookDescriptor.getConstraintsForProperty("title");
assert propertyDescriptor.getConstraintDescriptors().size() == 2;
assert "title".equals( propertyDescriptor.getPropertyName() );

//assuming the implementation returns the @NotEmpty constraint first
ConstraintDescriptor&lt;?&gt; constraintDescriptor = propertyDescriptor.getConstraintDescriptors()
                                                              .iterator().next();
assert constraintDescriptor.getAnnotation().annotationType().equals( NotEmpty.class );
assert constraintDescriptor.getGroups().size() == 2; //FirstLevelCheck and Default
assert constraintDescriptor.getComposingConstraints().size() == 2;
assert constraintDescriptor.isReportAsSingleViolation() == true;

//@NotEmpty cannot be null
boolean notNullPresence = false;
for ( ConstraintDescriptor&lt;?&gt; composingDescriptor : constraintDescriptor.getComposingConstraints() ) {
    if ( composingDescriptor.getAnnotation().annotationType().equals( NotNull.class ) ) {
        notNullPresence = true;
    }
}
assert notNullPresence; 

//assuming the implementation returns the Size constraint second
constraintDescriptor = propertyDescriptor.getConstraintDescriptors().iterator().next();
assert constraintDescriptor.getAnnotation().annotationType().equals( Size.class );
assert constraintDescriptor.getAttributes().get("max") == Integer.valueOf( 30 );
assert constraintDescriptor.getGroups().size() == 1;

propertyDescriptor = bookDescriptor.getConstraintsForProperty("author");
assert propertyDescriptor.getConstraintDescriptors().size() == 1;
assert propertyDescriptor.isCascaded();

//getTitle() and addChapter()
assert bookDescriptor.getConstrainedMethods( MethodType.GETTER, MethodType.NON_GETTER ).size() == 2;

//the constructor accepting title, description and author
assert bookDescriptor.getConstrainedConstructors().size() == 1;

ConstructorDescriptor constructorDescriptor = bookDescriptor.getConstraintsForConstructor(
    String.class, String.class, Author.class 
);
assert constructorDescriptor.getName().equals( "Book" );
assert constructorDescriptor.getElementClass() == Book.class;
assert constructorDescriptor.hasConstrainedParameters() == true;

//return value is marked for cascaded validation
assert constructorDescriptor.hasConstrainedReturnValue() == true;

//constraints are retrieved via the sub-descriptors for parameters etc.
assert constructorDescriptor.hasConstraints() == false;

//one descriptor for each parameter
assert constructorDescriptor.getParameterDescriptors().size() == 3;

//"description" parameter
ParameterDescriptor parameterDescriptor = constructorDescriptor.getParameterDescriptors().get( 1 );

//Assuming the default parameter name provider
assert parameterDescriptor.getName().equals( "arg1" );
assert parameterDescriptor.getElementClass() == String.class;
assert parameterDescriptor.getIndex() == 1;
assert parameterDescriptor.hasConstraints() == true;

Set&lt;ConstraintDescriptor&lt;?&gt;&gt; parameterConstraints = parameterDescriptor.getConstraintDescriptors();
assert parameterConstraints.iterator().next().getAnnotation().annotationType() == Size.class;

//"author" parameter
parameterDescriptor = constructorDescriptor.getParameterDescriptors().get( 2 );
assert parameterDescriptor.hasConstraints() == false;
assert parameterDescriptor.isCascaded() == true;

//group conversion on "author" parameter
GroupConversionDescriptor groupConversion =
    parameterDescriptor.getGroupConversions().iterator().next();
assert groupConversion.getFrom() == Default.class;
assert groupConversion.getTo() == SecondLevelCheck.class;

//constructor return value
ReturnValueDescriptor returnValueDescriptor = constructorDescriptor.getReturnValueDescriptor();
assert returnValueDescriptor.hasConstraints() == false;
assert returnValueDescriptor.isCascaded() == true;

//a getter is also a method which is constrained on its return value
MethodDescriptor methodDescriptor = bookDescriptor.getConstraintsForMethod( "getTitle" );
assert methodDescriptor.getName().equals( "getTitle" );
assert methodDescriptor.getElementClass() == String.class;
assert methodDescriptor.hasConstrainedParameters() == false;
assert methodDescriptor.hasConstrainedReturnValue() == true;
assert methodDescriptor.hasConstraints() == false;

returnValueDescriptor = methodDescriptor.getReturnValueDescriptor();
assert returnValueDescriptor.getElementClass() == String.class;
assert returnValueDescriptor.getConstraintDescriptors().size() == 2;
assert returnValueDescriptor.isCascaded() == false;

//void method which has a cross-parameter constraint
methodDescriptor = bookDescriptor.getConstraintsForMethod(
    "addChapter", String.class, int.class, int.class
);
assert methodDescriptor.getElementClass() == void.class;
assert methodDescriptor.hasConstrainedParameters() == true;
assert methodDescriptor.hasConstrainedReturnValue() == false;

//cross-parameter constraints accessible via separate descriptor
assert methodDescriptor.hasConstraints() == false;

assert methodDescriptor.getReturnValueDescriptor().getElementClass() == void.class;

//cross-parameter descriptor
CrossParameterDescriptor crossParameterDescriptor = methodDescriptor.getCrossParameterDescriptor();
assert crossParameterDescriptor.getElementClass() == Object[].class;
assert crossParameterDescriptor.hasConstraints() == true;

ConstraintDescriptor&lt;?&gt; crossParameterConstraint =
    crossParameterDescriptor.getConstraintDescriptors().iterator().next();
assert crossParameterConstraint.getAnnotation().annotationType() == ValidInterval.class;</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="builtinconstraints"></a>Chapter&nbsp;7.&nbsp;Built-in Constraint definitions</h2></div></div><div></div></div><p>The specification defines a small set of built-in constraints. Their
  usage is encouraged both in regular constraint declarations and as composing
  constraints. Using this set of constraints will enhance portability of your
  constraints across constraint-consuming frameworks relying on the metadata
  API (such as client side validation frameworks or database schema generation
  frameworks).</p><p>Built-in annotations are annotated with an empty
  <tt class="classname">@Constraint</tt> annotation to avoid any dependency
  between the specification API and a specific implementation. <span class="tck-testable">Each Bean Validation provider must recognize built-in
  constraint annotations as valid constraint definitions and provide compliant
  constraint implementations for each.</span> <span class="tck-testable">The built-in constraint validation implementation is
  having a lower priority than an XML mapping definition.</span> In other
  words <tt class="classname">ConstraintValidator</tt> implementations for
  built-in constraints can be overridden by using the XML mapping (see <a href="#xml-mapping-constraintdefinition" title="8.1.2.&nbsp;Overriding constraint definitions in XML">Section&nbsp;8.1.2, &#8220;Overriding constraint definitions in XML&#8221;</a>).</p><p>All built-in constraints are in the
  <tt class="classname">javax.validation.constraints</tt> package. Here is the
  list of constraints and their declaration.</p><div class="example"><a name="d0e9479"></a><p class="title"><b>Example&nbsp;7.1.&nbsp;@Null constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be {@code null}.
 * Accepts any type.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface Null {

    String message() default "{javax.validation.constraints.Null.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * Defines several {@link Null} annotations on the same element.
     *
     * @see javax.validation.constraints.Null
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        Null[] value();
    }
}</pre></div><div class="example"><a name="d0e9484"></a><p class="title"><b>Example&nbsp;7.2.&nbsp;@NotNull constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must not be {@code null}.
 * Accepts any type.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface NotNull {

    String message() default "{javax.validation.constraints.NotNull.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * Defines several {@link NotNull} annotations on the same element.
     *
     * @see javax.validation.constraints.NotNull
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        NotNull[] value();
    }
}</pre></div><div class="example"><a name="d0e9489"></a><p class="title"><b>Example&nbsp;7.3.&nbsp;@AssertTrue constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be true.
 * Supported types are {@code boolean} and {@code Boolean}.
 * &lt;p/&gt;
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface AssertTrue {

    String message() default "{javax.validation.constraints.AssertTrue.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * Defines several {@link AssertTrue} annotations on the same element.
     *
     * @see AssertTrue
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        AssertTrue[] value();
    }
}</pre></div><div class="example"><a name="d0e9494"></a><p class="title"><b>Example&nbsp;7.4.&nbsp;@AssertFalse constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be false.
 * Supported types are {@code boolean} and {@code Boolean}.
 * &lt;p/&gt;
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface AssertFalse {

    String message() default "{javax.validation.constraints.AssertFalse.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * Defines several {@link AssertFalse} annotations on the same element.
     *
     * @see javax.validation.constraints.AssertFalse
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        AssertFalse[] value();
    }
}</pre></div><div class="example"><a name="d0e9499"></a><p class="title"><b>Example&nbsp;7.5.&nbsp;@Min constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a number whose value must be higher or
 * equal to the specified minimum.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 *     &lt;li&gt;{@code BigDecimal}&lt;/li&gt;
 *     &lt;li&gt;{@code BigInteger}&lt;/li&gt;
 *     &lt;li&gt;{@code byte}, {@code short}, {@code int}, {@code long}, and their respective
 *     wrappers&lt;/li&gt;
 * &lt;/ul&gt;
 * Note that {@code double} and {@code float} are not supported due to rounding errors
 * (some providers might provide some approximative support).
 * &lt;p/&gt;
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface Min {

    String message() default "{javax.validation.constraints.Min.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * @return value the element must be higher or equal to
     */
    long value();

    /**
     * Defines several {@link Min} annotations on the same element.
     *
     * @see Min
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        Min[] value();
    }
}</pre></div><div class="example"><a name="d0e9504"></a><p class="title"><b>Example&nbsp;7.6.&nbsp;@Max constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a number whose value must be lower or
 * equal to the specified maximum.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 *     &lt;li&gt;{@code BigDecimal}&lt;/li&gt;
 *     &lt;li&gt;{@code BigInteger}&lt;/li&gt;
 *     &lt;li&gt;{@code byte}, {@code short}, {@code int}, {@code long}, and their respective
 *     wrappers&lt;/li&gt;
 * &lt;/ul&gt;
 * Note that {@code double} and {@code float} are not supported due to rounding errors
 * (some providers might provide some approximative support).
 * &lt;p/&gt;
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface Max {

    String message() default "{javax.validation.constraints.Max.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * @return value the element must be lower or equal to
     */
    long value();

    /**
     * Defines several {@link Max} annotations on the same element.
     *
     * @see Max
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        Max[] value();
    }
}</pre></div><div class="example"><a name="d0e9509"></a><p class="title"><b>Example&nbsp;7.7.&nbsp;@DecimalMin constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a number whose value must be higher or
 * equal to the specified minimum.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 *     &lt;li&gt;{@code BigDecimal}&lt;/li&gt;
 *     &lt;li&gt;{@code BigInteger}&lt;/li&gt;
 *     &lt;li&gt;{@code CharSequence}&lt;/li&gt;
 *     &lt;li&gt;{@code byte}, {@code short}, {@code int}, {@code long}, and their respective
 *     wrappers&lt;/li&gt;
 * &lt;/ul&gt;
 * Note that {@code double} and {@code float} are not supported due to rounding errors
 * (some providers might provide some approximative support).
 * &lt;p/&gt;
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface DecimalMin {

    String message() default "{javax.validation.constraints.DecimalMin.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * The {@code String} representation of the min value according to the
     * {@code BigDecimal} string representation.
     *
     * @return value the element must be higher or equal to
     */
    String value();

    /**
     * Specifies whether the specified minimum is inclusive or exclusive.
     * By default, it is inclusive.
     *
     * @return {@code true} if the value must be higher or equal to the specified minimum,
     *         {@code false} if the value must be higher
     *
     * @since 1.1
     */
    boolean inclusive() default true;

    /**
     * Defines several {@link DecimalMin} annotations on the same element.
     *
     * @see DecimalMin
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        DecimalMin[] value();
    }
}</pre></div><div class="example"><a name="d0e9514"></a><p class="title"><b>Example&nbsp;7.8.&nbsp;@DecimalMax constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a number whose value must be lower or
 * equal to the specified maximum.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 *     &lt;li&gt;{@code BigDecimal}&lt;/li&gt;
 *     &lt;li&gt;{@code BigInteger}&lt;/li&gt;
 *     &lt;li&gt;{@code CharSequence}&lt;/li&gt;
 *     &lt;li&gt;{@code byte}, {@code short}, {@code int}, {@code long}, and their respective
 *     wrappers&lt;/li&gt;
 * &lt;/ul&gt;
 * Note that {@code double} and {@code float} are not supported due to rounding errors
 * (some providers might provide some approximative support).
 * &lt;p/&gt;
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface DecimalMax {

    String message() default "{javax.validation.constraints.DecimalMax.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * The {@code String} representation of the max value according to the
     * {@code BigDecimal} string representation.
     *
     * @return value the element must be lower or equal to
     */
    String value();

    /**
     * Specifies whether the specified maximum is inclusive or exclusive.
     * By default, it is inclusive.
     *
     * @return {@code true} if the value must be lower or equal to the specified maximum,
     *         {@code false} if the value must be lower
     *
     * @since 1.1
     */
    boolean inclusive() default true;

    /**
     * Defines several {@link DecimalMax} annotations on the same element.
     *
     * @see DecimalMax
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        DecimalMax[] value();
    }
}</pre></div><div class="example"><a name="d0e9519"></a><p class="title"><b>Example&nbsp;7.9.&nbsp;@Size constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element size must be between the specified boundaries (included).
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 *     &lt;li&gt;{@code CharSequence} (length of character sequence is evaluated)&lt;/li&gt;
 *     &lt;li&gt;{@code Collection} (collection size is evaluated)&lt;/li&gt;
 *     &lt;li&gt;{@code Map} (map size is evaluated)&lt;/li&gt;
 *     &lt;li&gt;Array (array length is evaluated)&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface Size {

    String message() default "{javax.validation.constraints.Size.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * @return size the element must be higher or equal to
     */
    int min() default 0;

    /**
     * @return size the element must be lower or equal to
     */
    int max() default Integer.MAX_VALUE;

    /**
     * Defines several {@link Size} annotations on the same element.
     *
     * @see Size
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        Size[] value();
    }
}</pre></div><div class="example"><a name="d0e9524"></a><p class="title"><b>Example&nbsp;7.10.&nbsp;@Digits constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a number within accepted range
 * Supported types are:
 * &lt;ul&gt;
 *     &lt;li&gt;{@code BigDecimal}&lt;/li&gt;
 *     &lt;li&gt;{@code BigInteger}&lt;/li&gt;
 *     &lt;li&gt;{@code CharSequence}&lt;/li&gt;
 *     &lt;li&gt;{@code byte}, {@code short}, {@code int}, {@code long}, and their respective
 *     wrapper types&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface Digits {

    String message() default "{javax.validation.constraints.Digits.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * @return maximum number of integral digits accepted for this number
     */
    int integer();

    /**
     * @return maximum number of fractional digits accepted for this number
     */
    int fraction();

    /**
     * Defines several {@link Digits} annotations on the same element.
     *
     * @see Digits
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        Digits[] value();
    }
}</pre></div><div class="example"><a name="d0e9529"></a><p class="title"><b>Example&nbsp;7.11.&nbsp;@Past constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a date in the past.
 * Now is defined as the current time according to the virtual machine.
 * &lt;p/&gt;
 * The calendar used if the compared type is of type {@code Calendar}
 * is the calendar based on the current timezone and the current locale.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 *     &lt;li&gt;{@code java.util.Date}&lt;/li&gt;
 *     &lt;li&gt;{@code java.util.Calendar}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface Past {

    String message() default "{javax.validation.constraints.Past.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * Defines several {@link Past} annotations on the same element.
     *
     * @see Past
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        Past[] value();
    }
}</pre></div><div class="example"><a name="d0e9534"></a><p class="title"><b>Example&nbsp;7.12.&nbsp;@Future constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a date in the future.
 * Now is defined as the current time according to the virtual machine
 * The calendar used if the compared type is of type {@code Calendar}
 * is the calendar based on the current timezone and the current locale.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 *     &lt;li&gt;{@code java.util.Date}&lt;/li&gt;
 *     &lt;li&gt;{@code java.util.Calendar}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface Future {

    String message() default "{javax.validation.constraints.Future.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * Defines several {@link Future} annotations on the same element.
     *
     * @see Future
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        Future[] value();
    }
}</pre></div><div class="example"><a name="d0e9539"></a><p class="title"><b>Example&nbsp;7.13.&nbsp;@Pattern constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated {@code CharSequence} must match the specified regular expression.
 * The regular expression follows the Java regular expression conventions
 * see {@link java.util.regex.Pattern}.
 * &lt;p/&gt;
 * Accepts {@code CharSequence}. {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface Pattern {

    /**
     * @return the regular expression to match
     */
    String regexp();

    /**
     * @return array of {@code Flag}s considered when resolving the regular expression
     */
    Flag[] flags() default { };

    /**
     * @return the error message template
     */
    String message() default "{javax.validation.constraints.Pattern.message}";

    /**
     * @return the groups the constraint belongs to
     */
    Class&lt;?&gt;[] groups() default { };

    /**
     * @return the payload associated to the constraint
     */
    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * Possible Regexp flags.
     */
    public static enum Flag {

        /**
         * Enables Unix lines mode.
         *
         * @see java.util.regex.Pattern#UNIX_LINES
         */
        UNIX_LINES( java.util.regex.Pattern.UNIX_LINES ),

        /**
         * Enables case-insensitive matching.
         *
         * @see java.util.regex.Pattern#CASE_INSENSITIVE
         */
        CASE_INSENSITIVE( java.util.regex.Pattern.CASE_INSENSITIVE ),

        /**
         * Permits whitespace and comments in pattern.
         *
         * @see java.util.regex.Pattern#COMMENTS
         */
        COMMENTS( java.util.regex.Pattern.COMMENTS ),

        /**
         * Enables multiline mode.
         *
         * @see java.util.regex.Pattern#MULTILINE
         */
        MULTILINE( java.util.regex.Pattern.MULTILINE ),

        /**
         * Enables dotall mode.
         *
         * @see java.util.regex.Pattern#DOTALL
         */
        DOTALL( java.util.regex.Pattern.DOTALL ),

        /**
         * Enables Unicode-aware case folding.
         *
         * @see java.util.regex.Pattern#UNICODE_CASE
         */
        UNICODE_CASE( java.util.regex.Pattern.UNICODE_CASE ),

        /**
         * Enables canonical equivalence.
         *
         * @see java.util.regex.Pattern#CANON_EQ
         */
        CANON_EQ( java.util.regex.Pattern.CANON_EQ );

        //JDK flag value
        private final int value;

        private Flag(int value) {
            this.value = value;
        }

        /**
         * @return flag value as defined in {@link java.util.regex.Pattern}
         */
        public int getValue() {
            return value;
        }
    }

    /**
     * Defines several {@link Pattern} annotations on the same element.
     *
     * @see Pattern
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        Pattern[] value();
    }
}</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="xml"></a>Chapter&nbsp;8.&nbsp;XML deployment descriptor</h2></div></div><div></div></div><p>Two kinds of XML descriptors are used by Bean Validation. The first
  one describes the Bean Validation configuration provided as
  <tt class="filename">META-INF/validation.xml</tt>. The second one describes
  constraints declarations and closely matches the annotations declaration
  approach. <span class="tck-testable">If an XML descriptor does not validate
  against the corresponding XSD file, a
  <tt class="classname">ValidationException</tt> is raised.</span></p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml-mapping"></a>8.1.&nbsp;Constraint definition and declaration</h2></div></div><div></div></div><p>Bean Validation lets you declare constraints via XML rather than
    annotations. You can either ignore constraints declared via annotations or
    consider XML as adding additional constraints on top of annotation
    constraints. While it is not possible to define a new constraint via XML,
    you can redefine the list of <tt class="classname">ConstraintValidator</tt>
    classes associated to a given constraint definition.</p><p>There is no distinction between an annotation based constraint
    declaration and an XML based constraint declaration: they are considered
    equivalent and should be treated as such by the Bean Validation provider.
    The rest of the specification only refers to annotations as validation
    metadata: it should be read as annotation or their XML descriptor
    equivalent.</p><p><span class="tck-testable">Specifically when exploring metadata,
    the Bean Validation provider must ensure that an annotation instance
    corresponding to the XML declaration is provided via
    <tt class="classname">ConstraintDescriptor.getAnnnotation()</tt>.</span> The
    annotation elements as well as
    <tt class="methodname">ConstraintValidator.getAttributes()</tt> must reflect
    the values described in the XML declaration (see <a href="#xml-mapping-typeconversion" title="8.1.3.&nbsp;Converting the string representation of a value">Section&nbsp;8.1.3, &#8220;Converting the string representation of a value&#8221;</a>). Likewise,
    <tt class="methodname">ConstraintDescriptor.getConstraintValidatorClasses()</tt>
    must reflect XML based constraint definition overriding (see <a href="#xml-mapping-constraintdefinition" title="8.1.2.&nbsp;Overriding constraint definitions in XML">Section&nbsp;8.1.2, &#8220;Overriding constraint definitions in XML&#8221;</a>).</p><p><span class="tck-testable">A given class must not be described more
    than once amongst all the XML mapping descriptors.</span> <span class="tck-testable">A given field or getter must not be described more
    than once on a given class description.</span> <span class="tck-testable">A given constraint definition must not be overridden
    more than once amongst all the XML mapping descriptors.</span> <span class="tck-testable">If any of these rule is violated in a given validation
    deployment, a <tt class="classname">ValidationException</tt> is raised during
    the creation of the
    <tt class="classname">ValidatorFactory</tt>.</span></p><p>The schema is provided in <a href="#xml-mapping-xsd" title="8.1.4.&nbsp;XML Schema">Section&nbsp;8.1.4, &#8220;XML Schema&#8221;</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9606"></a>8.1.1.&nbsp;Constraint declaration in XML</h3></div></div><div></div></div><p class="tck-testable">If <tt class="literal">default-package</tt> is set,
      all unqualified class names (including annotations) are considered part
      of the package described by <tt class="literal">default-package</tt>.</p><p><span class="tck-testable">A given JavaBean is described by the
      <tt class="classname">bean</tt> element.</span> <span class="tck-testable">The name of the class is mandatory.</span> <span class="tck-testable">By default, all constraint declarations expressed
      via annotation are ignored for classes described in XML.</span>
      <span class="tck-testable">You can force Bean Validation to consider
      both annotations and XML constraint declarations by using
      <tt class="literal">ignore-annotations="false"</tt> on
      <tt class="literal">bean</tt>.</span></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <tt class="literal">ignore-annotations</tt> setting is not
        inherited from nor by the class hierarchy. In other words, it only
        applies to the current bean only.</p></div><p class="tck-testable">If the name of the class does refer to a class
      not present in the classpath, a
      <tt class="classname">ValidationException</tt> is raised.</p><div class="example"><a name="d0e9649"></a><p class="title"><b>Example&nbsp;8.1.&nbsp;Example of bean XML declaration</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.1.xsd"
        version="1.1"&gt;

    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;

    &lt;bean class="Customer" ignore-annotations="false"&gt;
        [...]
    &lt;/bean&gt;
    &lt;bean class="com.acme.common.model.Address"&gt;
        [...]
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9654"></a>8.1.1.1.&nbsp;Class-level overriding</h4></div></div><div></div></div><p>Class level annotations are described via the
        <tt class="literal">class</tt> element. <span class="tck-testable">If
        <tt class="literal">ignore-annotations</tt> is declared, Bean Validation
        must honor the explicit value for this element.</span> <span class="tck-testable">If not declared, the default value defined in the
        encapsulating <tt class="classname">bean</tt> element is
        considered.</span></p><p><span class="tck-testable">When
        <tt class="literal">ignore-annotations</tt> is true, class-level Bean
        Validation annotations are ignored for this class (including the
        <tt class="classname">@GroupSequence</tt>).</span> When
        <tt class="literal">ignore-annotations</tt> is false:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable">Constraints declared in XML and
            constraints declared in annotations are added and form the list of
            class-level declared constraints.</p></li><li><p class="tck-testable"><tt class="classname">@GroupSequence</tt> is
            considered unless <tt class="literal">group-sequence</tt> element is
            explicitly used.</p></li></ul></div><div class="example"><a name="d0e9698"></a><p class="title"><b>Example&nbsp;8.2.&nbsp;Example of class-level declaration</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.1.xsd"
        version="1.1"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;
        &lt;class ignore-annotations="true"&gt;
            [...]
        &lt;/class&gt;
    &lt;/bean&gt;
    &lt;bean class="com.acme.common.model.Address"&gt;
        &lt;class&gt;
            [...]
        &lt;/class&gt;
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9703"></a>8.1.1.2.&nbsp;Field-level overriding</h4></div></div><div></div></div><p>Field level annotations are described via the
        <tt class="literal">field</tt> element. The <tt class="literal">name</tt>
        attribute corresponds to the name of the field considered. <span class="tck-testable">If <tt class="literal">ignore-annotations</tt> is
        declared, Bean Validation must honor the explicit value for this
        element.</span> <span class="tck-testable">If not declared, the
        default value defined in the encapsulating <tt class="classname">bean</tt>
        element is considered.</span></p><p><span class="tck-testable">When
        <tt class="literal">ignore-annotations</tt> is true, field-level Bean
        Validation annotations on the targeted field are ignored (including
        <tt class="classname">@Valid</tt> and
        <tt class="classname">@ConvertGroup</tt>).</span> When
        <tt class="literal">ignore-annotations</tt> is false:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable">Constraints declared in XML and
            constraints declared in annotations are added and form the list of
            field-level declared constraints.</p></li><li><p><span class="tck-testable"><tt class="classname">@Valid</tt> is
            considered unless the <tt class="literal">valid</tt> element is
            explicitly used.</span> <span class="tck-ignore">Note that the
            only way to disable cascading on a field marked as
            <tt class="classname">@Valid</tt> is to use
            <tt class="literal">ignore-annotations=true</tt>.</span></p></li><li><p><span class="tck-testable">Group conversions declared in
            XML and via the <tt class="classname">@ConvertGroup</tt> annotation
            are added and form the list of applied conversions.</span> Note
            that the rules for the declaration of group conversions as
            outlined in <a href="#constraintdeclarationvalidationprocess-groupsequence-groupconversion" title="4.4.5.&nbsp;Group conversion">Section&nbsp;4.4.5, &#8220;Group conversion&#8221;</a>
            apply, in particular it is not legal to declare several
            conversions for the same source group.</p></li></ul></div><p class="tck-testable">If the name of the field does not correspond
        to a field in the given bean a
        <tt class="classname">ValidationException</tt> is raised.</p><div class="example"><a name="d0e9778"></a><p class="title"><b>Example&nbsp;8.3.&nbsp;Field-level declaration</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.1.xsd"
        version="1.1"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;
        &lt;field name="firstName"&gt;
            [...]
        &lt;/field&gt;
        &lt;field name="orders"&gt;
            &lt;valid/&gt;
            [...]
        &lt;/field&gt;
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9783"></a>8.1.1.3.&nbsp;Property-level overriding</h4></div></div><div></div></div><p>Property-level annotations are described via the
        <tt class="literal">getter</tt> element. <span class="tck-testable">The
        <tt class="literal">name</tt> attribute corresponds to the name of the
        property considered as defined in <a href="#constraintdeclarationvalidationprocess-requirements-property" title="4.1.2.&nbsp;Field and property validation">Section&nbsp;4.1.2, &#8220;Field and property validation&#8221;</a>
        (for example a getter <tt class="literal">String getAge()</tt> would have
        <tt class="literal">&lt;getter name="age"/&gt;</tt> as a corresponding
        descriptor). If <tt class="literal">ignore-annotations</tt> is declared,
        Bean Validation must honor the explicit value for this
        element.</span> <span class="tck-testable">If not declared, the
        default value defined in the encapsulating <tt class="classname">bean</tt>
        element is considered.</span></p><p><span class="tck-testable">When
        <tt class="literal">ignore-annotations</tt> is true, property-level Bean
        Validation annotations on the targeted property are ignored (including
        <tt class="classname">@Valid</tt> and
        <tt class="classname">@ConvertGroup</tt>).</span> When
        <tt class="literal">ignore-annotations</tt> is false:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable">Constraints declared in XML and
            constraints declared in annotations are added and form the list of
            property-level declared constraints.</p></li><li><p><span class="tck-testable"><tt class="classname">@Valid</tt> is
            considered unless the <tt class="literal">valid</tt> element is
            explicitly used.</span> <span>Note that the only way to
            disable cascading on a property marked as
            <tt class="classname">@Valid</tt> is to use
            <tt class="literal">ignore-annotations=true</tt>.</span></p></li><li><p><span class="tck-testable">Group conversions declared in
            XML and via the <tt class="classname">@ConvertGroup</tt> annotation
            are added and form the list of applied conversions.</span> Note
            that the rules for the declaration of group conversions as
            outlined in <a href="#constraintdeclarationvalidationprocess-groupsequence-groupconversion" title="4.4.5.&nbsp;Group conversion">Section&nbsp;4.4.5, &#8220;Group conversion&#8221;</a>
            apply, in particular it is not legal to declare several
            conversions for the same source group.</p></li></ul></div><p class="tck-testable">If the name of the property does not
        correspond to a property in the given bean a
        <tt class="classname">ValidationException</tt> is raised.</p><div class="example"><a name="d0e9866"></a><p class="title"><b>Example&nbsp;8.4.&nbsp;Property-level declaration</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.1.xsd"
        version="1.1"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;
        &lt;getter name="firstName"&gt;
            [...]
        &lt;/getter&gt;
        &lt;getter name="orders"&gt;
            &lt;valid/&gt;
            [...]
        &lt;/getter&gt;
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml-mapping-constraintdeclarationinxml-constructorleveloverriding"></a>8.1.1.4.&nbsp;Constructor-level overriding</h4></div></div><div></div></div><p>Constructor-level annotations are described via the
        <tt class="literal">constructor</tt> element.</p><p class="tck-testable">To identify a constructor
        to be configured, zero or more parameter elements are used, matching
        the number and types of parameters of the configured constructor. When
        configuring the default constructor, no parameter element is to be
        used. The parameter types are specified using their fully qualified
        name using the syntax described in the documentation of
        <tt class="methodname">java.lang.Class.getName()</tt>.</p><p>Let's look at some examples:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">"java.lang.String"</tt> must be specified for
            a parameter of type <tt class="classname">java.lang.String</tt></p></li><li><p><tt class="literal">"long"</tt> must be specified for a parameter
            of type <tt class="classname">long</tt></p></li><li><p><tt class="literal">"[Ljava.lang.Object;"</tt> must be specified
            for a parameter of type
            <tt class="classname">java.lang.Object[]</tt></p></li></ul></div><p class="tck-testable">Varargs parameters are specified using the
        corresponding array type, e.g. a parameter
        <tt class="literal">String...</tt> must be specified as
        <tt class="literal">"[Ljava.lang.String;"</tt>.</p><p class="tck-testable">If the <tt class="literal">default-package</tt>
        element is configured for the mapping file, any unqualified class
        names will be resolved using the given default package.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>You must declare all parameters even if they are not
            reconfigured to ensure the right constructor is identified.</p></div><p class="tck-testable">If no constructor with the specified
        parameter types exists in the given bean a
        <tt class="classname">ValidationException</tt> is raised.</p><p class="tck-testable">The optional <tt class="literal">return-value</tt>
        element is used to change the configuration of a constructor's return
        value if required.</p><p class="tck-testable">The optional
        <tt class="literal">cross-parameter</tt> element is used to change the
        configuration of a constructor's cross-parameter constraints if
        required.</p><p><span class="tck-testable">The constraints applying for a
        constructor's parameters and its return value are specified by adding
        <tt class="literal">constraint</tt> elements to the
        <tt class="literal">parameter</tt> and <tt class="literal">return-value</tt>
        elements respectively.</span> <span class="tck-testable">Whether or
        not to perform cascaded validation is controlled using the
        <tt class="literal">valid</tt> element</span>.<span class="tck-testable">
        Group conversion rules for cascaded validation are specified using the
        <tt class="literal">convert-group</tt> element. </span></p><p><span class="tck-testable">The cross-parameter
        constraints applied on a constructor parameter list are specified by
        adding <tt class="literal">constraint</tt> elements to the
        <tt class="literal">cross-parameter</tt> element.</span></p><p class="tck-testable">If
        <tt class="literal">ignore-annotations</tt> is declared on the parameter,
        cross-parameter element or return value level, Bean Validation must
        honor the explicit value for this element. Otherwise, if
        <tt class="literal">ignore-annotations</tt> is declared for the
        <tt class="literal">constructor</tt> element, Bean Validation must honor
        this value. Otherwise, the default value declared in the encapsulating
        <tt class="literal">bean</tt> element is considered.</p><p><span class="tck-testable">When
        <tt class="literal">ignore-annotations</tt> is true, Bean Validation
        annotations on the targeted constructor or parameter are ignored
        (including <tt class="classname">@Valid</tt> and
        <tt class="classname">@ConvertGroup</tt>).</span> When
        <tt class="literal">ignore-annotations</tt> is false:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable">Constraints declared in XML and
            constraints declared in annotations are added and form the list of
            declared parameter, cross-parameter or return value constraints
            respectively.</p></li><li><p><span class="tck-testable"><tt class="classname">@Valid</tt> is
            considered unless the <tt class="literal">valid</tt> element is
            explicitly used.</span> <span class="tck-ignore">Note that the
            only way to disable cascading on a constructor parameter or return
            value marked as <tt class="classname">@Valid</tt> is to use
            <tt class="literal">ignore-annotations=true</tt>. This does not apply to
            cross-parameter elements as cascading does not make sense in this
            situation.</span></p></li><li><p><span class="tck-testable">Group conversions declared in
            XML and via the <tt class="classname">@ConvertGroup</tt> annotation
            are added and form the list of applied conversions.</span> Note
            that the rules for the declaration of group conversions as
            outlined in <a href="#constraintdeclarationvalidationprocess-groupsequence-groupconversion" title="4.4.5.&nbsp;Group conversion">Section&nbsp;4.4.5, &#8220;Group conversion&#8221;</a>
            apply, in particular it is not legal to declare several
            conversions for the same source group. This does not apply to
            cross-parameter elements as cascading does not make sense in this
            situation.</p></li></ul></div><div class="example"><a name="d0e10036"></a><p class="title"><b>Example&nbsp;8.5.&nbsp;Constructor-level declaration</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.1.xsd"
        version="1.1"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;
        &lt;constructor ignore-annotations="true"&gt;
            &lt;parameter type="java.lang.String"&gt;
                [...]
            &lt;/parameter&gt;
            &lt;parameter type="int"&gt;
                &lt;valid/&gt;
                [...]
            &lt;/parameter&gt;
            &lt;parameter type="long" ignore-annotations="false"/&gt;
            &lt;cross-parameter ignore-annotations="false"&gt;
                [...]
            &lt;/cross-parameter&gt;
            &lt;return-value&gt;
                &lt;valid/&gt;
                [...]
            &lt;/return-value&gt;
            [...]
        &lt;/constructor&gt;

    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml-mapping-constraintdeclarationinxml-methodleveloverriding"></a>8.1.1.5.&nbsp;Method-level overriding</h4></div></div><div></div></div><p>Method-level annotations are described via the
        <tt class="literal">method</tt> element.</p><p class="tck-testable">To identify a method to be
        configured, zero or more parameter elements are used, matching the
        number and types of parameters of the configured method. The parameter
        types are specified using their fully qualified name using the syntax
        described in the documentation of
        <tt class="methodname">java.lang.Class.getName()</tt>.</p><p>Let's look at some examples:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">"java.lang.String"</tt> must be specified for
            a parameter of type <tt class="classname">java.lang.String</tt></p></li><li><p><tt class="literal">"long"</tt> must be specified for a parameter
            of type <tt class="classname">long</tt></p></li><li><p><tt class="literal">"[Ljava.lang.Object;"</tt> must be specified
            for a parameter of type
            <tt class="classname">java.lang.Object[]</tt></p></li></ul></div><p class="tck-testable">Varargs parameters are specified using the
        corresponding array type, e.g. a parameter
        <tt class="literal">String...</tt> must be specified as
        <tt class="literal">"[Ljava.lang.String;"</tt>.</p><p class="tck-testable">If the <tt class="literal">default-package</tt>
        element is configured for the mapping file, any unqualified class
        names will be resolved using the given default package.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>You must declare all parameters even if they are not
            reconfigured to ensure the right method is identified.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A given getter method representing a JavaBeans property may
            either be configured using the <tt class="literal">getter</tt> or the
            <tt class="literal">method</tt> element, but not both. If a
            <tt class="literal">getter</tt> element and a <tt class="literal">method</tt>
            element referring to the same method are detected by the Bean
            Validation provider, a <tt class="classname">ValidationException</tt>
            is raised.</p></div><p class="tck-testable">If no method with the specified name and
        parameter types exists in the given bean a
        <tt class="classname">ValidationException</tt> is raised.</p><p class="tck-testable">The optional <tt class="literal">return-value</tt>
        element is used to change the configuration of a method's return value
        if required.</p><p class="tck-testable">The optional
        <tt class="literal">cross-parameter</tt> element is used to change the
        configuration of a method's cross-parameter constraints if
        required.</p><p><span class="tck-testable">The constraints applying for a
        method's parameters and its return value are specified by adding
        <tt class="literal">constraint</tt> elements to the
        <tt class="literal">parameter</tt> and <tt class="literal">return-value</tt>
        elements respectively.</span> <span class="tck-testable">Whether or
        not to perform cascaded validation is controlled using the
        <tt class="literal">valid</tt> element.</span><span class="tck-testable">
        Group conversion rules for cascaded validation are specified using the
        <tt class="literal">convert-group</tt> element. </span></p><p><span class="tck-testable">The cross-parameter
        constraints applied on a method parameter list are specified by adding
        <tt class="literal">constraint</tt> elements to the
        <tt class="literal">cross-parameter</tt> element.</span></p><p class="tck-testable">If
        <tt class="literal">ignore-annotations</tt> is declared on the parameter,
        cross-parameter element or return value level, Bean Validation must
        honor the explicit value for this element. Otherwise, if
        <tt class="literal">ignore-annotations</tt> is declared for the
        <tt class="literal">method</tt> element, Bean Validation must honor this
        value. Otherwise, the default value declared in the encapsulating
        <tt class="literal">bean</tt> element is considered.</p><p><span class="tck-testable">When
        <tt class="literal">ignore-annotations</tt> is true, Bean Validation
        annotations on the targeted method or parameter are ignored (including
        <tt class="classname">@Valid</tt> and
        <tt class="classname">@ConvertGroup</tt>).</span> When
        <tt class="literal">ignore-annotations</tt> is false:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable">Constraints declared in XML and
            constraints declared in annotations are added and form the list of
            declared parameter, cross-parameter or return value constraints
            respectively.</p></li><li><p><span class="tck-testable"><tt class="classname">@Valid</tt> is
            considered unless the <tt class="literal">valid</tt> element is
            explicitly used.</span> <span class="tck-ignore">Note that the
            only way to disable cascading on a method parameter or return
            value marked as <tt class="classname">@Valid</tt> is to use
            <tt class="literal">ignore-annotations=true</tt>. This does not apply to
            cross-parameter elements as cascading does not make sense in this
            situation.</span></p></li><li><p><span class="tck-testable">Group conversions declared in
            XML and via the <tt class="classname">@ConvertGroup</tt> annotation
            are added and form the list of applied conversions.</span> Note
            that the rules for the declaration of group conversions as
            outlined in <a href="#constraintdeclarationvalidationprocess-groupsequence-groupconversion" title="4.4.5.&nbsp;Group conversion">Section&nbsp;4.4.5, &#8220;Group conversion&#8221;</a>
            apply, in particular it is not legal to declare several
            conversions for the same source group. This does not apply to
            cross-parameter elements as cascading does not make sense in this
            situation.</p></li></ul></div><div class="example"><a name="d0e10223"></a><p class="title"><b>Example&nbsp;8.6.&nbsp;Method-level declaration</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.1.xsd"
        version="1.1"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;
        &lt;method name="update" ignore-annotations="true"&gt;
            &lt;parameter type="java.lang.String"&gt;
                [...]
            &lt;/parameter&gt;
            &lt;parameter type="int"&gt;
                &lt;valid/&gt;
                [...]
            &lt;/parameter&gt;
            &lt;parameter type="long" ignore-annotations="false"/&gt;
            &lt;cross-parameter ignore-annotations="false"&gt;
                [...]
            &lt;/cross-parameter&gt;
            &lt;return-value&gt;
                &lt;valid/&gt;
                [...]
            &lt;/return-value&gt;
            [...]
        &lt;/method&gt;

    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e10228"></a>8.1.1.6.&nbsp;Constraint declaration</h4></div></div><div></div></div><p>New constraint declarations are represented by the
        <tt class="literal">constraint</tt> element. <span class="tck-testable">The
        <tt class="literal">annotation</tt> attribute is the class name of the
        annotation representing the constraint. Message, groups and payload
        are defined respectively by the <tt class="literal">message</tt>,
        <tt class="literal">groups</tt> and <tt class="literal">payload</tt>
        elements.</span></p><p>Other custom elements of an annotation are represented by
        <tt class="literal">element</tt>. <span class="tck-testable">The
        <tt class="literal">name</tt> attribute is mandatory and represents the name
        of the element in the constraint declaration.</span> <span class="tck-testable">&#8220;<span class="quote">message</span>&#8221;,
        &#8220;<span class="quote">groups</span>&#8221; and &#8220;<span class="quote">payload</span>&#8221; are not permitted
        names, use the <tt class="literal">message</tt>, <tt class="literal">groups</tt>
        or <tt class="literal">payload</tt> elements instead. Otherwise a
        <tt class="classname">ValidationException</tt> is raised.</span></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><tt class="literal">validationAppliesTo</tt> (see <a href="#constraintsdefinitionimplementation-constraintdefinition-validationappliesto" title="3.1.1.4.&nbsp;validationAppliesTo">Section&nbsp;3.1.1.4, &#8220;validationAppliesTo&#8221;</a>)
          is not necessary as cross-parameter constraints and return value
          constraints are declared in different XML elements, respectively
          <tt class="literal">cross-parameter</tt> and
          <tt class="literal">return-value</tt>.</p></div><p><span class="tck-testable">If the element represents a
        primitive type, a class or an enum, the string representation of its
        value is placed in the element itself.</span> See <a href="#xml-mapping-typeconversion" title="8.1.3.&nbsp;Converting the string representation of a value">Section&nbsp;8.1.3, &#8220;Converting the string representation of a value&#8221;</a> for a detailed explanation of
        the conversion rules from string to the type.</p><p class="tck-testable">If the element represents a primitive type
        array, a class array or an enum array, the string representation of
        each value is placed in a <tt class="literal">value</tt> element placed
        under the element itself.</p><p><span class="tck-testable">If the element represents an
        annotation, the <tt class="literal">annotation</tt> element is used to
        represent the annotation and placed under
        <tt class="literal">element</tt>.</span> An <tt class="literal">annotation</tt>
        element contains <tt class="literal">element</tt> elements.</p><p class="tck-testable">If the element represents an array of
        annotations, one or more <tt class="literal">annotation</tt> elements are
        placed under <tt class="literal">element</tt>.</p><p><span class="tck-testable">Elements with default values in the
        annotation definition do not have to be represented in XML: the
        default value will be used in this case.</span> <span class="tck-testable">If an XML constraint declaration is missing
        mandatory elements, or if it contains elements not part of the
        constraint definition, a <tt class="classname">ValidationException</tt> is
        raised.</span></p><div class="example"><a name="d0e10340"></a><p class="title"><b>Example&nbsp;8.7.&nbsp;Constraint declaration</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.1.xsd"
        version="1.1"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;

        &lt;field name="firstName"&gt;


            &lt;!-- @LooksLike(patterns={
                      @Pattern(value="myRegExp", flag=PatternFlag.INSENSITIVE),
                      @Pattern(value="my2ndRegExp")}
                  )
             --&gt;
            &lt;constraint annotation="com.acme.app.constraint.LooksLike"&gt;
                &lt;element name="patterns"&gt;
                    &lt;annotation&gt;
                        &lt;element name="value"&gt;myRegExp&lt;/element&gt;
                        &lt;element name="flag"&gt;
                            &lt;value&gt;INSENSITIVE&lt;/value&gt;
                        &lt;/element&gt;
                    &lt;/annotation&gt;
                    &lt;annotation&gt;
                        &lt;element name="value"&gt;my2ndRegExp&lt;/element&gt;
                    &lt;/annotation&gt;
                &lt;/element&gt;
            &lt;/constraint&gt;


        &lt;/field&gt;
        &lt;field name="orders"&gt;
            &lt;valid/&gt;


            &lt;!-- @DiscreteSize(value={ 0, 20 } )
             --&gt;
            &lt;constraint annotation="com.acme.app.constraint.DiscreteSize"&gt;
                &lt;element name="value"&gt;
                    &lt;value&gt;0&lt;/value&gt;
                    &lt;value&gt;20&lt;/value&gt;
                &lt;/element&gt;
            &lt;/constraint&gt;


        &lt;/field&gt;

        &lt;getter name="orders"&gt;
            &lt;valid/&gt;


            &lt;!-- @Size(message="Size is limited",
                       groups={Default.class, LightValidation.class},
                       max=30
                 )
            --&gt;
            &lt;constraint annotation="javax.validation.constraints.Size"&gt;
                &lt;message&gt;Size is limited&lt;/message&gt;
                &lt;groups&gt;
                    &lt;value&gt;com.acme.app.model.LightValidation&lt;/value&gt;
                    &lt;value&gt;javax.persistence.Default&lt;/value&gt;
                &lt;/groups&gt;
                &lt;payload&gt;
                    &lt;value&gt;com.acme.app.model.WARN&lt;/value&gt;
                &lt;/payload&gt;
                &lt;element name="max"&gt;30&lt;/element&gt;
            &lt;/constraint&gt;


        &lt;/getter&gt;

        &lt;constructor ignore-annotations="true"&gt;
            &lt;parameter type="java.lang.String"&gt;

                &lt;!-- @DiscreteSize(value={ 0, 20 } ) --&gt;
                &lt;constraint annotation="com.acme.app.constraint.DiscreteSize"&gt;
                    &lt;element name="value"&gt;
                        &lt;value&gt;0&lt;/value&gt;
                        &lt;value&gt;20&lt;/value&gt;
                    &lt;/element&gt;
                &lt;/constraint&gt;
            &lt;/parameter&gt;
        &lt;/constructor&gt;

        &lt;method name="update" ignore-annotations="true"&gt;
            &lt;parameter type="java.lang.String"&gt;

                &lt;!-- @DiscreteSize(value={ 0, 20 } ) --&gt;
                &lt;constraint annotation="com.acme.app.constraint.DiscreteSize"&gt;
                    &lt;element name="value"&gt;
                        &lt;value&gt;0&lt;/value&gt;
                        &lt;value&gt;20&lt;/value&gt;
                    &lt;/element&gt;
                &lt;/constraint&gt;
            &lt;/parameter&gt;

            &lt;return-value&gt;

                &lt;!-- @ValidCustomer --&gt;
                &lt;constraint annotation="com.acme.app.constraint.ValidCustomer"/&gt;
            &lt;/return-value&gt;
        &lt;/method&gt;

        &lt;method name="resetPassword" ignore-annotations="false"&gt;
            &lt;parameter type="java.lang.String"/&gt;
            &lt;parameter type="java.lang.String"/&gt;

            &lt;cross-parameter&gt;
                &lt;!-- @ValidResetPasswordParameters --&gt;
                &lt;constraint annotation="com.acme.app.constraint.ValidResetPasswordParameters"/&gt;
            &lt;/cross-parameter&gt;
        &lt;/method&gt;
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e10345"></a>8.1.1.7.&nbsp;Declaration of group conversions</h4></div></div><div></div></div><p class="tck-testable">Group conversion rules are declared by
        specifying one or more <tt class="literal">convert-group</tt> elements
        within the <tt class="literal">field</tt>, <tt class="literal">getter</tt>,
        <tt class="literal">parameter</tt> and <tt class="literal">return-value</tt>
        elements.</p><p class="tck-testable">Source and target group of a conversion rule
        are given by specifying their fully-qualified names within the
        <tt class="literal">from</tt> and <tt class="literal">to</tt> attribute
        respectively. If the <tt class="literal">default-package</tt> element is
        configured for the mapping file, any unqualified class names will be
        resolved using the given default package.</p><div class="example"><a name="d0e10376"></a><p class="title"><b>Example&nbsp;8.8.&nbsp;Declaration of group conversions</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.1.xsd"
        version="1.1"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;

        &lt;field name="firstName"&gt;
            &lt;valid/&gt;
            &lt;convert-group from="javax.validation.groups.Default" to="com.acme.CustomerBasic"/&gt;
            &lt;convert-group from="com.acmenote.Advanced" to="com.acme.CustomerComplex"/&gt;
        &lt;/field&gt;

        &lt;getter name="orders"&gt;
            &lt;valid/&gt;
            &lt;convert-group from="javax.validation.groups.Default" to="com.acme.CustomerBasic"/&gt;
        &lt;/getter&gt;

        &lt;constructor&gt;
            &lt;parameter type="java.lang.String"&gt;
                &lt;valid/&gt;
                &lt;convert-group from="javax.validation.groups.Default" to="com.acme.CustomerBasic"/&gt;
            &lt;/parameter&gt;
            &lt;return-value&gt;
                &lt;valid/&gt;
                &lt;convert-group from="javax.validation.groups.Default" to="com.acme.CustomerBasic"/&gt;
            &lt;/return-value&gt;
        &lt;/constructor&gt;

        &lt;method name="update"&gt;
            &lt;parameter type="java.lang.String"&gt;
                &lt;valid/&gt;
                &lt;convert-group from="javax.validation.groups.Default" to="com.acme.CustomerBasic"/&gt;
            &lt;/parameter&gt;
            &lt;return-value&gt;
                &lt;valid/&gt;
                &lt;convert-group from="javax.validation.groups.Default" to="com.acme.CustomerBasic"/&gt;
            &lt;/return-value&gt;
        &lt;/constructor&gt;
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml-mapping-constraintdefinition"></a>8.1.2.&nbsp;Overriding constraint definitions in XML</h3></div></div><div></div></div><p>A constraint definition (i.e. the annotation representing a
      constraint), cannot be fully expressed in XML but the list of
      <tt class="classname">ConstraintValidator</tt>s associated to a given
      constraint can be altered.</p><p><span class="tck-testable">A constraint definition is represented
      by a <tt class="literal">constraint-definition</tt> element.</span> The
      <tt class="literal">annotation</tt> attribute represents the constraint
      annotation being altered. The <tt class="literal">validated-by</tt> elements
      represent the (ordered) list of
      <tt class="classname">ConstraintValidator</tt> implementations associated to
      the constraint.</p><p><span class="tck-testable">If
      <tt class="literal">include-existing-validator</tt> is set to false,
      <tt class="classname">ConstraintValidator</tt> defined on the constraint
      annotation are ignored.</span> <span class="tck-testable">If set to
      true, the list of <tt class="classname">ConstraintValidator</tt>s described
      in XML are concatenated to the list of
      <tt class="classname">ConstraintValidator</tt> described on the annotation
      to form a new array of <tt class="classname">ConstraintValidator</tt>
      evaluated.</span> <span class="tck-testable">Annotation based
      <tt class="classname">ConstraintValidator</tt> come before XML based
      <tt class="classname">ConstraintValidator</tt>s in the array.</span>
      <span class="tck-testable">The new list is returned by
      <tt class="methodname">ConstraintDescriptor.getConstraintValidatorClasses()</tt>.</span></p><div class="example"><a name="d0e10441"></a><p class="title"><b>Example&nbsp;8.9.&nbsp;Overriding constraint definitions</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.1.xsd"
        version="1.1"&gt;
   &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
   &lt;bean class="com.acme.common.model.Address"&gt;
       [...]
    &lt;/bean&gt;

    &lt;constraint-definition annotation="javax.validation.constraints.Size"&gt;
        &lt;validated-by include-existing-validators="true"&gt;
            &lt;value&gt;com.acme.app.constraint.SizeValidatorForDictionary&lt;/value&gt;
        &lt;/validated-by&gt;
    &lt;/constraint-definition&gt;
    &lt;constraint-definition annotation="AcmeOrderNumber"&gt;
        [...]
    &lt;/constraint-definition&gt;
&lt;/constraint-mappings&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml-mapping-typeconversion"></a>8.1.3.&nbsp;Converting the string representation of a value</h3></div></div><div></div></div><p class="tck-testable">Primitive types, <tt class="classname">Class</tt>
      and <tt class="classname">Enum</tt> are represented as strings in the XML
      descriptor. Elements of an array are represented by the
      <tt class="literal">value</tt> element.</p><p class="tck-testable"><tt class="classname">byte</tt> are represented
      according to the rules defined in
      <tt class="methodname">Byte.parseByte(String)</tt>.</p><p class="tck-testable"><tt class="classname">short</tt> are represented
      according to the rules defined in
      <tt class="methodname">Short.parseShort(String)</tt>.</p><p class="tck-testable"><tt class="classname">int</tt> are represented
      according to the rules defined in
      <tt class="methodname">Integer.parseInt(String)</tt>.</p><p class="tck-testable"><tt class="classname">long</tt> are represented
      according to the rules defined in
      <tt class="methodname">Long.parseLong(String)</tt>.</p><p class="tck-testable"><tt class="classname">float</tt> are represented
      according to the rules defined in
      <tt class="methodname">Float.parseFloat(String)</tt>.</p><p class="tck-testable"><tt class="classname">double</tt> are represented
      according to the rules defined in
      <tt class="methodname">Double.parseDouble(String)</tt>.</p><p class="tck-testable"><tt class="classname">boolean</tt> are represented
      according to the rules defined in
      <tt class="methodname">Boolean.parseBoolean(String)</tt>.</p><p class="tck-testable"><tt class="classname">char</tt> are represented
      according to the following rules: </p><div class="itemizedlist"><ul type="disc"><li><p>the string must be of one character long</p></li><li><p>the character extracted from the string is the returned
            <tt class="classname">char</tt></p></li></ul></div><p class="tck-testable">A <tt class="classname">Class</tt> is represented
      by the fully qualified class name of the class or more precisely
      according to the syntax described in the documentation of
      <tt class="methodname">java.lang.Class.getName()</tt>. Note that if the raw
      string is unqualified, default package is taken into account.</p><p class="tck-testable">An enum is represented by its
      <tt class="literal">enum.name()</tt> value.</p><p class="tck-testable">If any of the string representation does not
      match its type counterpart, a <tt class="classname">ValidationException</tt>
      is raised.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml-mapping-xsd"></a>8.1.4.&nbsp;XML Schema</h3></div></div><div></div></div><p>This section contains the XML schema used for constraint mapping
      descriptors.</p><p>From Bean Validation revision 1.1 onwards, mapping authors must
      specify the used version of the schema within the
      <tt class="literal">version</tt> attribute of the
      <tt class="literal">constraint-mappings</tt> element. <span class="tck-testable">Implementations supporting Bean Validation 1.1 must
      properly parse mapping descriptors of Bean Validation 1.0 and
      1.1.</span> <span class="tck-not-testable">If the
      <tt class="literal">version</tt> attribute attribute is not given, schema
      version 1.0 is to be assumed by the Bean Validation
      Provider.</span></p><p class="tck-testable">In case an unknown version is given (e.g. if a
      mapping descriptor adhering to a future schema version is parsed by a
      Bean Validation 1.1 provider) a
      <tt class="classname">ValidationException</tt> is raised.</p><div class="example"><a name="d0e10566"></a><p class="title"><b>Example&nbsp;8.10.&nbsp;XML schema for constraint mapping descriptors</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema attributeFormDefault="unqualified"
           elementFormDefault="qualified"
           targetNamespace="http://jboss.org/xml/ns/javax/validation/mapping"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"
           version="1.1"&gt;

    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;&lt;![CDATA[
            This is the XML Schema for Bean Validation constraint mapping files.

            Bean Validation constraint mapping files must indicate the Bean Validation
            XML schema by using the constraint mapping namespace:

            http://jboss.org/xml/ns/javax/validation/mapping

            and indicate the version of the schema by using the version attribute
            as shown below:

            &lt;constraint-mappings
                xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="
                    http://jboss.org/xml/ns/javax/validation/mapping
                    validation-mapping-1.1.xsd"
                version="1.1"&gt;
                [...]
            &lt;/constraint-mappings&gt;
        ]]&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;

    &lt;xs:element name="constraint-mappings" type="map:constraint-mappingsType"/&gt;

    &lt;xs:complexType name="payloadType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="groupsType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="groupSequenceType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="groupConversionType"&gt;
        &lt;xs:attribute type="xs:string" name="from" use="required"/&gt;
        &lt;xs:attribute type="xs:string" name="to" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="constraint-mappingsType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="default-package" minOccurs="0"/&gt;
            &lt;xs:element type="map:beanType"
                        name="bean"
                        maxOccurs="unbounded"
                        minOccurs="0"/&gt;
            &lt;xs:element type="map:constraint-definitionType"
                        name="constraint-definition"
                        maxOccurs="unbounded"
                        minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="version" type="map:versionType" fixed="1.1" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:simpleType name="versionType"&gt;
        &lt;xs:restriction base="xs:token"&gt;
            &lt;xs:pattern value="[0-9]+(\.[0-9]+)*"/&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
    &lt;xs:complexType name="validated-byType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:boolean" name="include-existing-validators" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="constraintType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="message" minOccurs="0"/&gt;
            &lt;xs:element type="map:groupsType"
                        name="groups"
                        minOccurs="0"/&gt;
            &lt;xs:element type="map:payloadType"
                        name="payload"
                        minOccurs="0"/&gt;
            &lt;xs:element type="map:elementType"
                        name="element"
                        maxOccurs="unbounded"
                        minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="annotation" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="elementType" mixed="true"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
            &lt;xs:element type="map:annotationType"
                        name="annotation"
                        maxOccurs="unbounded"
                        minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="name" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="classType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="map:groupSequenceType"
                        name="group-sequence"
                        minOccurs="0"/&gt;
            &lt;xs:element type="map:constraintType"
                        name="constraint"
                        maxOccurs="unbounded"
                        minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="beanType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="map:classType"
                        name="class"
                        minOccurs="0"&gt;
            &lt;/xs:element&gt;
            &lt;xs:element type="map:fieldType"
                        name="field"
                        minOccurs="0"
                        maxOccurs="unbounded"/&gt;
            &lt;xs:element type="map:getterType"
                        name="getter"
                        minOccurs="0"
                        maxOccurs="unbounded"/&gt;
            &lt;xs:element type="map:constructorType"
                        name="constructor"
                        minOccurs="0"
                        maxOccurs="unbounded"/&gt;
            &lt;xs:element type="map:methodType"
                        name="method"
                        minOccurs="0"
                        maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="class" use="required"/&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="annotationType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="map:elementType"
                        name="element"
                        maxOccurs="unbounded"
                        minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="getterType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="valid" minOccurs="0" fixed=""/&gt;
            &lt;xs:element type="map:groupConversionType"
                        name="convert-group"
                        minOccurs="0"
                        maxOccurs="unbounded"/&gt;
            &lt;xs:element type="map:constraintType"
                        name="constraint"
                        minOccurs="0"
                        maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="name" use="required"/&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="methodType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="map:parameterType"
                        name="parameter"
                        minOccurs="0"
                        maxOccurs="unbounded"/&gt;
            &lt;xs:element type="map:crossParameterType"
                        name="cross-parameter"
                        minOccurs="0"
                        maxOccurs="1"/&gt;
            &lt;xs:element type="map:returnValueType"
                        name="return-value"
                        minOccurs="0"
                        maxOccurs="1"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="name" use="required"/&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="constructorType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="map:parameterType"
                        name="parameter"
                        minOccurs="0"
                        maxOccurs="unbounded"/&gt;
            &lt;xs:element type="map:crossParameterType"
                        name="cross-parameter"
                        minOccurs="0"
                        maxOccurs="1"/&gt;
            &lt;xs:element type="map:returnValueType"
                        name="return-value"
                        minOccurs="0"
                        maxOccurs="1"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="parameterType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="valid" minOccurs="0" fixed=""/&gt;
            &lt;xs:element type="map:groupConversionType"
                        name="convert-group"
                        minOccurs="0"
                        maxOccurs="unbounded"/&gt;
            &lt;xs:element type="map:constraintType"
                        name="constraint"
                        minOccurs="0"
                        maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="type" use="required"/&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="returnValueType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="valid" minOccurs="0" fixed=""/&gt;
            &lt;xs:element type="map:groupConversionType"
                        name="convert-group"
                        minOccurs="0"
                        maxOccurs="unbounded"/&gt;
            &lt;xs:element type="map:constraintType"
                        name="constraint"
                        minOccurs="0"
                        maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="crossParameterType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="map:constraintType"
                        name="constraint"
                        minOccurs="0"
                        maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="constraint-definitionType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="map:validated-byType"
                        name="validated-by"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="annotation" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="fieldType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="valid" minOccurs="0" fixed=""/&gt;
            &lt;xs:element type="map:groupConversionType"
                        name="convert-group"
                        minOccurs="0"
                        maxOccurs="unbounded"/&gt;
            &lt;xs:element type="map:constraintType"
                        name="constraint"
                        minOccurs="0"
                        maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="name" use="required"/&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml-config-xsd"></a>8.2.&nbsp;Configuration schema</h2></div></div><div></div></div><p>XML Configuration is set in
    <tt class="filename">META-INF/validation.xml</tt>. The file is optional. The
    XML schema followed by the configuration file is as followed.</p><div class="example"><a name="d0e10579"></a><p class="title"><b>Example&nbsp;8.11.&nbsp;XML configuration XSD</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema attributeFormDefault="unqualified"
           elementFormDefault="qualified"
           targetNamespace="http://jboss.org/xml/ns/javax/validation/configuration"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:config="http://jboss.org/xml/ns/javax/validation/configuration"
           version="1.1"&gt;

    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;&lt;![CDATA[
            This is the XML Schema for the Bean Validation configuration file.
            The configuration file must be named "META-INF/validation.xml".

            Bean Validation configuration files must indicate the Bean Validation
            XML schema by using the validation namespace:

            http://jboss.org/xml/ns/javax/validation/configuration

            and indicate the version of the schema by using the version attribute
            as shown below:

            &lt;validation-config
                xmlns="http://jboss.org/xml/ns/javax/validation/configuration"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="
                    http://jboss.org/xml/ns/javax/validation/configuration
                    validation-configuration-1.1.xsd"
                version="1.1"&gt;
                [...]
            &lt;/validation-config&gt;
        ]]&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;

    &lt;xs:element name="validation-config" type="config:validation-configType"/&gt;
    &lt;xs:complexType name="validation-configType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="default-provider" minOccurs="0"/&gt;
            &lt;xs:element type="xs:string" name="message-interpolator" minOccurs="0"/&gt;
            &lt;xs:element type="xs:string" name="traversable-resolver" minOccurs="0"/&gt;
            &lt;xs:element type="xs:string" name="constraint-validator-factory" minOccurs="0"/&gt;
            &lt;xs:element type="xs:string" name="parameter-name-provider" minOccurs="0"/&gt;
            &lt;xs:element type="config:executable-validationType" name="executable-validation" minOccurs="0"/&gt;
            &lt;xs:element type="xs:string" name="constraint-mapping" maxOccurs="unbounded" minOccurs="0"/&gt;
            &lt;xs:element type="config:propertyType" name="property" maxOccurs="unbounded" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="version" type="config:versionType" fixed="1.1" use="required"/&gt;
    &lt;/xs:complexType&gt;

    &lt;xs:complexType name="executable-validationType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="config:default-validated-executable-typesType" name="default-validated-executable-types" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="enabled" use="optional" type="xs:boolean" default="true"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="default-validated-executable-typesType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="executable-type" maxOccurs="unbounded" minOccurs="1"&gt;
                &lt;xs:simpleType&gt;
                    &lt;xs:restriction base="xs:string"&gt;
                        &lt;xs:enumeration value="NONE"/&gt;
                        &lt;xs:enumeration value="CONSTRUCTORS"/&gt;
                        &lt;xs:enumeration value="NON_GETTER_METHODS"/&gt;
                        &lt;xs:enumeration value="GETTER_METHODS"/&gt;
                        &lt;xs:enumeration value="ALL"/&gt;
                    &lt;/xs:restriction&gt;
                &lt;/xs:simpleType&gt;
            &lt;/xs:element&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="propertyType"&gt;
        &lt;xs:simpleContent&gt;
            &lt;xs:extension base="xs:string"&gt;
                &lt;xs:attribute name="name" use="required" type="xs:string"/&gt;
            &lt;/xs:extension&gt;
        &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:simpleType name="versionType"&gt;
        &lt;xs:restriction base="xs:token"&gt;
            &lt;xs:pattern value="[0-9]+(\.[0-9]+)*" /&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
&lt;/xs:schema&gt;</pre></div><p>From Bean Validation revision 1.1 onwards, the used version of the
    schema must be specified within the <tt class="literal">version</tt> attribute
    of the <tt class="literal">validation-config</tt> element. <span class="tck-testable">Implementations supporting Bean Validation 1.1 must
    properly parse configuration descriptors of Bean Validation 1.0 and
    1.1.</span> <span class="tck-not-testable">If the
    <tt class="literal">version</tt> attribute attribute is not given, schema
    version 1.0 is to be assumed by the Bean Validation
    Provider.</span></p><p class="tck-testable">In case an unknown version is given a
    <tt class="classname">ValidationException</tt> is raised.</p><p>See <a href="#xml-config" title="5.5.6.&nbsp;XML configuration: META-INF/validation.xml">Section&nbsp;5.5.6, &#8220;XML configuration: META-INF/validation.xml&#8221;</a> for more information on XML based
    configuration.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="exception"></a>Chapter&nbsp;9.&nbsp;Exception model</h2></div></div><div></div></div><p>Illegal arguments passed to the Bean Validation APIs generally lead to
  an <tt class="classname">IllegalArgumentException</tt> (see the JavaDoc for
  specific details). Other exceptions raised by Bean Validation are or inherit
  from the runtime exception
  <tt class="classname">javax.validation.ValidationException</tt>. Exception cases
  are described in their respective sections but include (non exhaustive
  list):</p><div class="itemizedlist"><ul type="disc"><li><p>invalid constraint definitions (missing mandatory elements,
      illegal composition cycle, illegal attribute overriding, etc)</p></li><li><p>invalid constraint declarations
      (<tt class="classname">ConstraintValidator</tt> implementation matching
      failure, etc)</p></li><li><p>invalid group definition (circularity)</p></li><li><p>invalid <tt class="classname">Default</tt> group redefinition for
      classes (missing class group etc)</p></li><li><p>invalid group conversion definitions</p></li><li><p>error when retrieving, initializing, executing
      <tt class="classname">ConstraintValidator</tt>s</p></li><li><p>error when parsing the XML configuration or mappings</p></li><li><p>multiple XML configuration files found</p></li><li><p>missing expected provider or no default provider found</p></li><li><p>missing no-arg constructor on extension implementations described
      in XML configuration files</p></li><li><p>same entity described more than once across the XML mapping
      files</p></li><li><p>same property or field described more than once for a given entity
      in the XML mapping files</p></li><li><p>class, field or getter declared in XML mapping files but not
      found</p></li><li><p>illegal XML constraint definition</p></li><li><p>illegal XML constraint declaration</p></li><li><p>exception raised either at initialization time or execution time
      by any of the extension interfaces</p></li></ul></div><p>Each of these error cases lead to a
  <tt class="classname">ValidationException</tt> or a subclass of
  <tt class="classname">ValidationException</tt> (see following
  subsections).</p><p class="tck-testable">Every (runtime) exception raised either at
  initialization time or execution time by any of the extension interfaces
  (<tt class="classname">ConstraintValidator</tt>,
  <tt class="classname">ConstraintValidatorFactory</tt>,
  <tt class="classname">MessageInterpolator</tt>,
  <tt class="classname">TraversableResolver</tt>,
  <tt class="classname">ValidationProviderResolver</tt>,
  <tt class="classname">ParameterNameProvider</tt>) is wrapped in a
  <tt class="classname">ValidationException</tt>.</p><p>If a constraint definition or constraint declaration is invalid for a
  given class, the metadata API should raise the according exception.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10711"></a>9.1.&nbsp;Error report:
    <tt class="classname">ConstraintViolationException</tt></h2></div></div><div></div></div><p>Some frameworks or applications need to convey the result of a
    validation by raising an exception if the validation returns constraint
    violations.</p><p>Bean Validation provides a reference exception for such cases.
    Frameworks and applications are encouraged to use
    <tt class="classname">ConstraintViolationException</tt> as opposed to a custom
    exception to increase consistency of the Java platform. The exception can
    be raised directly or wrapped into the framework or application specific
    parent exception.</p><div class="example"><a name="d0e10723"></a><p class="title"><b>Example&nbsp;9.1.&nbsp;ConstraintViolationException</b></p><pre class="programlisting">/**
 * Reports the result of constraint violations.
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 */
public class ConstraintViolationException extends ValidationException {
    [...]

    /**
     * Creates a constraint violation report.
     *
     * @param message error message
     * @param constraintViolations {@code Set} of {@link ConstraintViolation}
     */
    public ConstraintViolationException(String message,
                                        Set&lt;? extends ConstraintViolation&lt;?&gt;&gt; constraintViolations) {
        [...]
    }

    /**
     * Creates a constraint violation report.
     *
     * @param constraintViolations {@code Set} of {@link ConstraintViolation}
     */
    public ConstraintViolationException(Set&lt;? extends ConstraintViolation&lt;?&gt;&gt; constraintViolations) {
        [...]
    }

    /**
     * Set of constraint violations reported during a validation.
     *
     * @return {@code Set} of {@link ConstraintViolation}
     */
    public Set&lt;ConstraintViolation&lt;?&gt;&gt; getConstraintViolations() {
        [...]
    }
}</pre></div><p>The <tt class="classname">ConstraintViolationException</tt> carries a
    <tt class="classname">Set</tt> of
    <tt class="classname">ConstraintViolation</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Bean Validation never raises this exception itself. Other
      frameworks like Java Persistence 2 or interception framework wiring
      method validation do.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If this exception is meant to be send remotely,
      <tt class="classname">ConstraintViolation</tt> objects should be
      <tt class="classname">Serializable</tt> as defined an explained in <a href="#validationapi-constraintviolation" title="5.2.&nbsp;ConstraintViolation">Section&nbsp;5.2, &#8220;ConstraintViolation&#8221;</a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10753"></a>9.2.&nbsp;Constraint definition:
    <tt class="classname">ConstraintDefinitionException</tt></h2></div></div><div></div></div><p><span class="tck-testable">If a constraint definition does not
    respect the Bean Validation rules or is inconsistent, a
    <tt class="classname">ConstraintDefinitionException</tt> is raised.</span>
    <tt class="classname">ConstraintDefinitionException</tt> is a subclass of
    <tt class="classname">ValidationException</tt>.</p><p>This exception can be raised during validation or when the metadata
    model for the class hosting this constraint is requested.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>These exception cases can be determined at compile time by a tool
      such as an annotation processor.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10776"></a>9.3.&nbsp;Constraint declaration:
    <tt class="classname">ConstraintDeclarationException</tt> and
    <tt class="classname">UnexpectedTypeException</tt></h2></div></div><div></div></div><p><span class="tck-not-testable">When a constraint declaration is
    illegal, <tt class="classname">ConstraintDeclarationException</tt> is
    raised.</span> This includes amongst other things incorrect group
    conversion rules (definition or positioning) and illegal method constraint
    declarations (e.g. inheritance rules, cross-parameter constraint used in
    an illegal situation, improper use of
    <tt class="methodname">validationAppliesTo</tt>).</p><p><tt class="classname">ConstraintDeclarationException</tt> is a subclass
    of <tt class="classname">ValidationException</tt>.</p><p><span class="tck-testable">When the return type of a property
    cannot be processed for a given constraint an
    <tt class="classname">UnexpectedTypeException</tt> is raised.</span> This
    problem typically arise when either no
    <tt class="classname">ConstraintValidator</tt> or too many
    <tt class="classname">ConstraintValidator</tt>s match the return type (see
    <a href="#typevalidatorresolution" title="4.6.4.&nbsp;ConstraintValidator resolution algorithm">Section&nbsp;4.6.4, &#8220;ConstraintValidator resolution algorithm&#8221;</a>).</p><p><tt class="classname">UnexpectedTypeException</tt> is a subclass of
    <tt class="classname">ConstraintDeclarationException</tt>.</p><p>This exception can be raised during validation or when the metadata
    model for the class hosting this constraint is requested.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>These exception cases can be determined at compile time by a tool
      such as an annotation processor.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10828"></a>9.4.&nbsp;Group definition:
    <tt class="classname">GroupDefinitionException</tt></h2></div></div><div></div></div><p><span class="tck-testable">When a group definition is illegal,
    <tt class="classname">GroupDefinitionException</tt> is raised.</span> This
    typically arises when a cyclic group dependency is discovered, an illegal
    attribute overriding is defined etc.</p><p><tt class="classname">GroupDefinitionException</tt> is a subclass of
    <tt class="classname">ValidationException</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>These exception cases can be determined at compile time by a tool
      such as an annotation processor.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="integration"></a>Chapter&nbsp;10.&nbsp;Integration</h2></div></div><div></div></div><p>In this chapter, integration points between Bean Validation and other
  technologies are discussed. We first address the integration in generic
  terms applying to all integrations and we then detail how integration with
  various Java EE specifications is handled more specifically.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="integration-general"></a>10.1.&nbsp;General requirements</h2></div></div><div></div></div><p>This section covers general requirements that should be followed by
    any container and interception technology integrating Bean
    Validation.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10860"></a>10.1.1.&nbsp;Objects lifecycle</h3></div></div><div></div></div><p>Generally speaking, containers and frameworks controlling the life
      cycle of objects (such as Java EE, dependency injection frameworks or
      component frameworks) should:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable">build and bootstrap the
          <tt class="classname">ValidatorFactory</tt> instance for an
          application.</p></li><li><p class="tck-testable">provide access to the
          <tt class="classname">ValidatorFactory</tt> instance as well as
          <tt class="classname">Validator</tt> instances in their default
          configuration using the paradigm of the container: for example, such
          instances would be injectable in other objects via a dependency
          injection framework.</p></li><li><p class="tck-testable">configure
          <tt class="classname">ValidatorFactory</tt> with a custom
          <tt class="classname">ConstraintValidatorFactory</tt> instance that
          returns managed <tt class="classname">ConstraintValidator</tt>
          instances, unless a custom
          <tt class="classname">ConstraintValidatorFactory</tt> is requested by
          the user. The scope of <tt class="classname">ConstraintValidator</tt>
          instances is still fully controlled by the Bean Validation provider
          as described in <a href="#constraintsdefinitionimplementation-constraintfactory" title="3.5.&nbsp;The ConstraintValidatorFactory">Section&nbsp;3.5, &#8220;The ConstraintValidatorFactory&#8221;</a>,
          but as managed beans they can receive expected services like
          injection of other objects.</p></li><li><p class="tck-testable">configure
          <tt class="classname">ValidatorFactory</tt> with managed instances of
          <tt class="classname">ConstraintValidatorFactory</tt>,
          <tt class="classname">MessageInterpolator</tt>,
          <tt class="classname">ParameterNameProvider</tt> and
          <tt class="classname">TraversableResolver</tt>, if such instances are
          defined in the XML deployment descriptor. Services provided by the
          container (like dependency injection) should thus be available to
          these instances.</p></li><li><p class="tck-not-testable">invoke
          <tt class="methodname">ValidatorFactory.close()</tt> when the
          <tt class="classname">ValidatorFactory</tt> instance is no longer
          needed.</p></li><li><p class="tck-not-testable">dispose of managed instances provided
          to the Bean Validation bootstrap process after
          <tt class="methodname">ValidatorFactory.close()</tt> has been
          invoked.</p></li></ul></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>In this context, a default
        <tt class="classname">ValidatorFactory</tt> is a factory configured like
        the factory returned by
        <tt class="classname">Validation.buildDefaultValidatorFactory</tt> (see
        also <a href="#boostrapping-validation" title="5.5.5.&nbsp;Validation">Section&nbsp;5.5.5, &#8220;Validation&#8221;</a>) except for the
        enhancements described above. A default
        <tt class="classname">Validator</tt> instance is a
        <tt class="classname">Validator</tt> instance retrieved via
        <tt class="methodname">getValidator()</tt> from the default
        <tt class="classname">ValidatorFactory</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="integration-general-executable"></a>10.1.2.&nbsp;Method and constructor validation</h3></div></div><div></div></div><p>This section expresses the behavior that integration with
      interception frameworks should follow. Any deviation should be
      considered with care as it will surprise Bean Validation users.</p><p><span class="tck-testable">Method interception frameworks (such
      as AOP or interceptor frameworks) enable interception of constrained
      methods following the steps defined in <a href="#validationapi-triggeringmethodvalidation" title="5.4.&nbsp;Triggering method validation">Section&nbsp;5.4, &#8220;Triggering method validation&#8221;</a>.</span> <span class="tck-testable">Method validation execution is implicit for any
      method or constructor annotated with constraints.</span></p><p><span class="tck-testable">By default, method validation is
      applied to all constrained methods or constructors provided the
      integration technology can intercept the call. By default, getters (as
      defined in <a href="#constraintdeclarationvalidationprocess-requirements" title="4.1.&nbsp;Requirements on classes to be validated">Section&nbsp;4.1, &#8220;Requirements on classes to be validated&#8221;</a>) are not
      considered constrained methods.</span> <span class="tck-not-testable">Static methods are ignored by validation.
      Putting constraints on a static method is not portable.</span></p><p>Bean Validation - via the interception technology - offers a way
      to customize whether or not a constructor, method or getter is validated
      when executed. This is achieved:</p><div class="itemizedlist"><ul type="disc"><li><p>via the <tt class="classname">@ValidateOnExecution</tt> annotation
          on the executable (see <a href="#example-validateonexecution" title="Example&nbsp;10.1.&nbsp;@ValidateOnExecution annotation">Example&nbsp;10.1, &#8220;@ValidateOnExecution annotation&#8221;</a>)</p></li><li><p>via the <tt class="classname">@ValidateOnExecution</tt> annotation
          on the type declaring the executable</p></li><li><p>via a global configuration defined in
          <tt class="filename">validation.xml</tt>:
          <tt class="literal">executable-validation</tt> and
          <tt class="literal">default-validated-executable-types</tt>. See <a href="#xml-config" title="5.5.6.&nbsp;XML configuration: META-INF/validation.xml">Section&nbsp;5.5.6, &#8220;XML configuration: META-INF/validation.xml&#8221;</a> for more details.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Integration layers can read the list of validated executable
        types defined in the global configuration as well as read whether or
        not executable validation is disabled via the
        <tt class="classname">Configuration</tt> object:
        <tt class="code">configuration.getBootstrapConfiguration().getDefaultValidatedExecutableTypes()</tt>
        and
        <tt class="code">configuration.getBootstrapConfiguration().isExecutableValidationEnabled()</tt>
        respectively. This list is extracted from
        <tt class="filename">validation.xml</tt>.</p></div><p>More formally, a given executable (constructor or method) is
      validated upon execution according to the following rules in decreasing
      order:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable tcck-needs-update">the executable is
          validated if it is annotated with
          <tt class="classname">@ValidateOnExecution</tt> and the
          <tt class="methodname">type</tt> attribute contains the executable type
          or <tt class="literal">IMPLICIT</tt>. If the <tt class="methodname">type</tt>
          attribute does neither contain the executable type nor
          <tt class="literal">IMPLICIT</tt>, the executable is not validated.</p></li><li><p class="tck-testable">otherwise the executable is validated if
          the type (class, interface) on which it is declared is annotated
          with <tt class="classname">@ValidateOnExecution</tt> and the
          <tt class="methodname">type</tt> attribute contains the executable
          type. If the <tt class="literal">type</tt> attribute contains
          <tt class="literal">IMPLICIT</tt>, then this rule is ignored and the
          behavior is equivalent to
          <tt class="classname">@ValidateOnExecution</tt> not being present. If
          the <tt class="methodname">type</tt> attribute does not contain the
          executable type, the executable is not validated.</p></li><li><p class="tck-testable">otherwise the executable is validated if
          the global executable validation setting contains the executable
          type. If the global setting does not contain the executable type,
          the executable is not validated.</p></li><li><p class="tck-testable">The rules above do not apply to methods
          overriding a superclass method or implementing an interface method.
          In this case, the method inherits the behavior of the method it
          overrides / implements. Out of the box, a conforming implementation
          raises a <tt class="classname">ValidationException</tt> if the
          overriding / implementing method hosts the
          <tt class="classname">@ValidateOnExecution</tt> annotation.</p></li></ul></div><p>The last point is present to enforce the Liskov substitution
      principle (more info at <a href="#constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance" title="4.5.5.&nbsp;Method constraints in inheritance hierarchies">Section&nbsp;4.5.5, &#8220;Method constraints in inheritance hierarchies&#8221;</a>)
      In addition, providers may implement alternative, potentially more
      liberal, approaches for handling validated methods in inheritance
      hierarchies. Possible means for activating such alternative behavior
      include provider-specific configuration properties or annotations. Note
      that client code relying on such alternative behavior is not
      portable.</p><p>The following executable types are available:</p><div class="itemizedlist"><ul type="disc"><li><p class="tck-testable"><tt class="literal">NONE</tt>: parameters and
          return values are not validated upon execution. This option is
          equivalent to an empty list of executable types and is present to
          improve readability. A list containing <tt class="literal">NONE</tt> and
          other types of executables is equivalent to a list containing the
          types of executables without <tt class="literal">NONE</tt>.</p></li><li><p class="tck-testable"><tt class="literal">CONSTRUCTORS</tt>:
          parameters and return values are validated provided the executable
          is a constructor.</p></li><li><p class="tck-testable"><tt class="literal">NON_GETTER_METHODS</tt>:
          parameters and return values are validated provided the executable
          is a method but not a getter.</p></li><li><p class="tck-testable"><tt class="literal">GETTER_METHODS</tt>: return
          values are validated provided the executable is a getter
          method.</p></li><li><p class="tck-testable"><tt class="literal">ALL</tt>: parameters and
          return values are validated for all executables (getters, non
          getters and constructors). This option is equivalent to a list of
          all executable types and is present to improve readability. A list
          containing <tt class="literal">ALL</tt> and other types of executables is
          equivalent to a list containing only <tt class="literal">ALL</tt>.</p></li><li><p class="tck-testable"><tt class="literal">IMPLICIT</tt>: if
          <tt class="classname">@ValidateOnExecution</tt> is on a type (class or
          interface), then it is equivalent to
          <tt class="classname">@ValidateOnExecution</tt> not being present; if
          <tt class="classname">@ValidateOnExecution</tt> is on a an executable,
          the following applies:</p><div class="itemizedlist"><ul type="circle"><li><p>if on a constructor, it is equivalent to
                <tt class="literal">CONSTRUCTORS</tt>.</p></li><li><p>if on a non-getter method, it is equivalent to
                <tt class="literal">NON_GETTER_METHODS</tt>.</p></li><li><p>if on a getter, it is equivalent to
                <tt class="literal">GETTER_METHODS</tt>.</p></li></ul></div></li></ul></div><p class="tck-not-testable">Mixing <tt class="literal">IMPLICIT</tt> and
      other executable types is illegal.</p><div class="example"><a name="example-validateonexecution"></a><p class="title"><b>Example&nbsp;10.1.&nbsp;@ValidateOnExecution annotation</b></p><pre class="programlisting">package javax.validation.executable;

/**
 * Expresses which executables (methods or constructors) should have their parameters
 * and return value validated upon execution. Can be on executable (method, constructor)
 * or type level (with the former taking precedence).
 * &lt;p/&gt;
 * If not present for a given executable, the default configuration from
 * {@code META-INF/validation.xml} and finally the implicit default
 * validated executable types (constructors and non-getters) are taken into account to determine
 * whether a given executable is validated upon execution or not.
 * &lt;p/&gt;
 * The following describes the formal rules for deciding whether an executable is validated.
 * They are applied in decreasing order:
 * &lt;ul&gt;
 *     &lt;li&gt;the executable is validated if it is annotated with {@code @ValidateOnExecution} and
 *     the {@code type} attribute contains the executable type or {@link ExecutableType#IMPLICIT}.
 *     If the {@code type} attribute does neither contain the executable type nor {@code IMPLICIT},
 *     the executable is not validated.&lt;/li&gt;
 *     &lt;li&gt;otherwise the executable is validated if the type (class, interface) on which it is
 *     declared is annotated with {@code @ValidateOnExecution} and the {@code type} attribute
 *     contains the executable type. If the {@code type} attribute contains
 *     {@code IMPLICIT}, then this rule is ignored and the behavior is
 *     equivalent to {@code ValidateOnExecution} not being present. If the
 *     {@code type} attribute does not contain the executable type, the executable is not
 *     validated.&lt;/li&gt;
 *     &lt;li&gt;otherwise the executable is validated if the global executable validation setting
 *     contains the executable type. If the global setting does not contain the executable type,
 *     the executable is not validated.&lt;/li&gt;
 *     &lt;li&gt;The rules above do not apply to methods overriding a superclass method or
 *     implementing an interface method. In this case, the method inherits the behavior
 *     of the method it overrides or implements. Out of the box, a conforming implementation
 *     raises a {@link ValidationException} if the overriding / implementing method hosts
 *     the {@code ValidateOnExecution} annotation.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * Note that you can exclude an executable from validation by making sure the rules above do not match
 * or by annotating the executable with {@code @ValidateOnExecution(NONE)}.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
@Target({ CONSTRUCTOR, METHOD, TYPE, PACKAGE })
@Retention(RUNTIME)
public @interface ValidateOnExecution {

    /**
     * List of executable types to be validated when called.
     * Defaults to the types discovered implicitly (see {@link ExecutableType#IMPLICIT}).
     */
    ExecutableType[] type() default {ExecutableType.IMPLICIT};
}</pre><pre class="programlisting">package javax.validation.executable;

/**
 * Defines the types of executables targeted by an operation.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
public enum ExecutableType {

    /**
     * If the annotation using {@code ExecutableType} is on a type (class or interface),
     * the behavior is equivalent to the annotation not being present.
     * &lt;p/&gt;
     * If on a constructor, it is equivalent to {@link #CONSTRUCTORS}.
     * &lt;p/&gt;
     * If on a non-getter method, it is equivalent to {@link #NON_GETTER_METHODS}.
     * &lt;p/&gt;
     * If on a getter method, it is equivalent to {@link #GETTER_METHODS}.
     */
    IMPLICIT,

    /**
     * None of the executables.
     * &lt;p/&gt;
     * Note that this option is equivalent to an empty list of executable types
     * and is present to improve readability. If {@code NONE} and other types of executables
     * are present in a list, {@code NONE} is ignored.
     */
    NONE,

    /**
     * All constructors.
     */
    CONSTRUCTORS,

    /**
     * All methods except the ones following the getter pattern. A getter according to the
     * JavaBeans specification is a method whose:
     * &lt;ul&gt;
     *     &lt;li&gt;name starts with get, has a return type but no parameter&lt;/li&gt;
     *     &lt;li&gt;name starts with is, has a return type and is returning {@code boolean}.&lt;/li&gt;
     * &lt;/ul&gt;
     */
    NON_GETTER_METHODS,

    /**
    /**
     * All methods following the getter pattern. A getter according to the
     * JavaBeans specification is a method whose:
     * &lt;ul&gt;
     *     &lt;li&gt;name starts with get, has a return type but no parameter&lt;/li&gt;
     *     &lt;li&gt;name starts with is, has a return type and is returning {@code boolean}.&lt;/li&gt;
     * &lt;/ul&gt;
     */
    GETTER_METHODS,

    /**
     * All executables (constructors and methods).
     */
    ALL
}</pre></div><p><span class="tck-not-testable">If a sub type overrides/implements
      a method originally defined in several parallel types of the hierarchy
      (e.g. two interfaces not extending each other, or a class and an
      interface not implemented by said class),
      <tt class="classname">@ValidateOnExecution</tt> cannot be placed in the
      parallel types of the hierarchy.</span> This is to avoid an unexpected
      altering of the post conditions to be guaranteed to the caller.</p><p class="tck-testable">You can globally disable executable validation
      by using <tt class="code">&lt;executable-validation enabled="false"/&gt;</tt>, in
      this case, <tt class="code">&lt;default-validated-executable-types/&gt;</tt> and
      <tt class="classname">@ValidateOnExecution</tt> are ignored.</p><div class="example"><a name="d0e11185"></a><p class="title"><b>Example&nbsp;10.2.&nbsp;validation.xml disabling executable validation</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;validation-config
        xmlns="http://jboss.org/xml/ns/javax/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/configuration validation-configuration-1.1.xsd"
        version="1.1"&gt;
    &lt;default-provider&gt;com.acme.ACMEProvider&lt;/default-provider&gt;
    &lt;message-interpolator&gt;com.acme.ACMEAwareMessageInterpolator&lt;/message-interpolator&gt;

    &lt;executable-validation enabled="false"/&gt;

    &lt;constraint-mapping&gt;META-INF/validation/order-constraints.xml&lt;/constraint-mapping&gt;
    &lt;constraint-mapping&gt;META-INF/validation/catalog-constraints.xml&lt;/constraint-mapping&gt;
    &lt;constraint-mapping&gt;META-INF/validation/customer-constraints.xml&lt;/constraint-mapping&gt;

    &lt;property name="com.acme.validation.logging"&gt;WARN&lt;/property&gt;
    &lt;property name="com.acme.validation.safetyChecking"&gt;failOnError&lt;/property&gt;

&lt;/validation-config&gt;</pre></div><p><tt class="code">@ValidateOnExecution(type=IMPLICIT)</tt> on a type (class
      or interface) is useful to mark a class as being involved in executable
      validation without affecting the behavior. This is used when the
      integration technology needs a little help to find the classes and
      interfaces involved.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The proper selection of the validated executables is the
        responsibility of the integration between the interception technology
        and Bean Validation. Bean Validation engines ignore the XML
        configuration around executable validation and
        <tt class="classname">@ValidateOnExecution</tt> when validating
        executables and when providing metadata.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e11200"></a>10.1.2.1.&nbsp;Examples</h4></div></div><div></div></div><p>The following example shows some of the way you can refine
        executable validation with
        <tt class="classname">@ValidateOnExecution</tt>.</p><div class="example"><a name="d0e11208"></a><p class="title"><b>Example&nbsp;10.3.&nbsp;Method validation configurations</b></p><pre class="programlisting">//optional: @ValidateOnExecution
public class OrderService {

    boolean isValidCustomer(@NotNull String customerCode) { [...] }

    @ValidateOnExecution
    @Min(0)
    Integer getBacklog() { [...] }

    @ValidateOnExecution(type=NONE)
    Order placeOrder(@NotNull String customerCode, @Valid Item item, int quantity) { [...] }

}

@ValidateOnExecution(type={GETTER_METHODS, NON_GETTER_METHODS})
public class SimpleOrderService extends OrderService {

    public SimpleOrderService(@NotNull ServiceProvider provider) { [...] }

    @Overrides
    Order placeOrder(String customerCode, Item item, int quantity) { [...] }

}

//optional: @ValidateOnExecution
public class ComplexOrderService extends SimpleOrderService {
    public ComplexOrderService(@NotNull ServiceProvider provider) { [...] }
}</pre></div><p>All constructors and non-getter methods of
        <tt class="classname">OrderService</tt> are validated upon execution as
        this is the default setting.
        <tt class="methodname">isValidCustomer()</tt> is validated as this method
        is not a getter (it has a parameter).
        <tt class="methodname">getBacklog()</tt> is a getter but is validated
        thanks to <tt class="classname">@ValidateOnExecution</tt> defaulting to
        <tt class="literal">GETTER_METHODS</tt>.
        <tt class="methodname">placeOrder()</tt> is not validated as
        <tt class="classname">@ValidateOnExecution</tt> is set to
        <tt class="literal">NONE</tt>.</p><p>All getter and non-getter methods of
        <tt class="classname">SimpleOrderService</tt> are validated upon execution
        by default due to the presence of
        <tt class="classname">@ValidateOnExecution</tt> on the class. The
        <tt class="classname">SimpleOrderService</tt> constructor is thus not
        validated. <tt class="classname">SimpleOrderService.placeOrder()</tt> is
        not validated either because it overrides
        <tt class="classname">OrderService.placeOrder()</tt> and thus inherits its
        settings.</p><p>All constructors and non-getter methods of
        <tt class="classname">ComplexOrderService</tt> are validated upon
        execution as this is the default settings - the type level settings of
        <tt class="classname">SimpleOrderService</tt> are not inherited. This
        means that the <tt class="classname">ComplexOrderService</tt> constructor
        is validated.</p><p><tt class="classname">@ValidateOnExecution</tt> can be optionally
        set on <tt class="classname">OrderService</tt> and
        <tt class="classname">ComplexOrderService</tt> without altering the
        semantic. This marker is necessary for some integration technology in
        some situations.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="integration-javaee"></a>10.2.&nbsp;Java EE</h2></div></div><div></div></div><p class="tck-testable">Java EE must obey the rules defined above and
    make the following instances available under JNDI: </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">ValidatorFactory</tt> under
          <tt class="constant">java:comp/ValidatorFactory</tt></p></li><li><p><tt class="classname">Validator</tt> under
          <tt class="constant">java:comp/Validator</tt></p></li></ul></div><p class="tck-testable">Instead of looking the instances up via JNDI,
    the user can request them to be injected via the
    <tt class="classname">Resource</tt> annotation:</p><pre class="programlisting">@Resource ValidatorFactory validatorFactory;
@Resource Validator validator;</pre><p><span class="tck-testable">When the application is CDI enabled, the
    <tt class="classname">ValidatorFactory</tt> and
    <tt class="classname">Validator</tt> instances returned by JNDI or
    <tt class="classname">@Resource</tt> injection are CDI enhanced as defined in
    <a href="#integration-cdi" title="10.3.&nbsp;Context and Dependency Injection (CDI) integration">Section&nbsp;10.3, &#8220;Context and Dependency Injection (CDI) integration&#8221;</a>.</span> In particular, dependency
    injection is available to Bean Validation components.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="integration-cdi"></a>10.3.&nbsp;Context and Dependency Injection (CDI) integration</h2></div></div><div></div></div><p>There are several integrations points between Bean Validation and
    CDI. If a Bean Validation provider integrates with CDI, it must follow the
    rules laid out in this section. In a Java EE container, a <span class="tck-testable">Bean Validation provider must integrate with
    CDI</span>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11327"></a>10.3.1.&nbsp;<tt class="classname">ValidatorFactory</tt> and
      <tt class="classname">Validator</tt></h3></div></div><div></div></div><p class="tck-testable">Similar to the Java EE integration via
      <tt class="classname">@Resource</tt> (see <a href="#integration-javaee" title="10.2.&nbsp;Java EE">Section&nbsp;10.2, &#8220;Java EE&#8221;</a>), a CDI container must support injection
      of built-in default <tt class="classname">ValidatorFactory</tt> and
      <tt class="classname">Validator</tt> beans via
      <tt class="classname">@Inject</tt>. These default beans are injectable via
      the <tt class="classname">@Default</tt> qualifier.</p><pre class="programlisting">@Inject ValidatorFactory;
@Inject Validator;</pre><p>Optionally, the CDI container can support injection of provider
      specific - as defined by <tt class="code">Validation.byProvider()</tt> -
      <tt class="classname">ValidatorFactory</tt> and
      <tt class="classname">Validator</tt> beans via
      <tt class="classname">@Inject</tt>. These beans must be registered with a
      custom qualifier, for example <tt class="classname">@ACME</tt>. Using the
      product name or brand for the qualifier is considered good
      practice.</p><pre class="programlisting">@Inject @ACME ValidatorFactory;
@Inject @ACME Validator;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Discussion on possible implementations</h3><p>Registration of the built-in default beans and the provider
        specific beans may be achieved using the CDI portable extension SPI or
        a vendor specific SPI.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11379"></a>10.3.2.&nbsp;<tt class="classname">ConstraintValidatorFactory</tt>,
      <tt class="classname">MessageInterpolator</tt>,
      <tt class="classname">ParameterNameProvider</tt> and
      <tt class="classname">TraversableResolver</tt></h3></div></div><div></div></div><p class="tck-testable">If a custom
      <tt class="classname">ConstraintValidatorFactory</tt>,
      <tt class="classname">MessageInterpolator</tt>,
      <tt class="classname">ParameterNameProvider</tt> or
      <tt class="classname">TraversableResolver</tt> class is defined in the XML
      deployment descriptor (see <a href="#xml-config" title="5.5.6.&nbsp;XML configuration: META-INF/validation.xml">Section&nbsp;5.5.6, &#8220;XML configuration: META-INF/validation.xml&#8221;</a>), the
      <tt class="classname">ValidatorFactory</tt> must be configured with CDI
      managed beans representing the requested classes. Services like
      dependency injection, interception and decoration must thus be made
      available to these instances by the container.</p><p class="tck-testable">If no custom
      <tt class="classname">ConstraintValidatorFactory</tt> is requested by the
      user, the <tt class="classname">ValidatorFactory</tt> must be configured
      with a custom <tt class="classname">ConstraintValidatorFactory</tt> instance
      that returns CDI managed beans representing the requested
      <tt class="classname">ConstraintValidator</tt> types. The factory
      </p><div class="itemizedlist"><ul type="disc"><li><p>creates non-contextual
            <tt class="classname">ConstraintValidator</tt> instances for each
            <tt class="methodname">ConstraintValidatorFactory.getInstance()</tt>
            call. To inject dependencies into the
            <tt class="classname">ConstraintValidator</tt> instance, the CDI
            <tt class="classname">InjectionTarget</tt> API should be used. Before
            returning the instance the following calls should be made:
            <tt class="classname">InjectionTarget.produce()</tt>,
            <tt class="classname">InjectionTarget.inject()</tt> and
            <tt class="classname">InjectionTarget.postConstruct()</tt>.</p></li><li><p>calls <tt class="classname">InjectionTarget.preDestroy()</tt>
            and <tt class="classname">InjectionTarget.dispose()</tt> upon
            <tt class="classname">ConstraintValidatorFactory.releaseInstance</tt>
            (see also <a href="#constraintsdefinitionimplementation-constraintfactory" title="3.5.&nbsp;The ConstraintValidatorFactory">Section&nbsp;3.5, &#8220;The ConstraintValidatorFactory&#8221;</a>
            for more information about the life cycle of a
            <tt class="classname">ConstraintValidator</tt>).</p></li></ul></div><p class="tck-not-testable">Using directly or indirectly a JPA
      <tt class="classname">EntityManager</tt> that might call back Bean
      Validation for validation is not allowed in the Bean Validation
      extension points and in <tt class="classname">ConstraintValidator</tt>
      instances. This would lead to infinite flush or unexpected
      behavior.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11475"></a>10.3.3.&nbsp;Method and constructor validation</h3></div></div><div></div></div><p class="tck-testable">Bean Validation requires that CDI beans
      support constructor and method validation as defined in <a href="#integration-general-executable" title="10.1.2.&nbsp;Method and constructor validation">Section&nbsp;10.1.2, &#8220;Method and constructor validation&#8221;</a>. Validation must happen at
      the equivalent time an interceptor occurs when having priority
      <tt class="code">Interceptor.Priority.PLATFORM_AFTER+800</tt>, in other words
      priority of <tt class="literal">4800</tt>.</p><p class="tck-not-testable">For maximum portability, it is recommended
      to mark CDI bean interfaces and classes involved in executable
      validation with <tt class="classname">@ValidateOnExecution</tt> (defaults to
      <tt class="literal">IMPLICIT</tt>). This helps some implementations to be more
      efficient. Most CDI - Bean Validation integration implementations do not
      need such marker. In particular this marker should not be needed on
      validated beans annotated with constraint annotations,
      <tt class="classname">@Valid</tt> or
      <tt class="classname">@ValidateOnExecution</tt> anywhere in the class. Such
      limitation will be removed in a future version of this
      specification.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Discussion on possible implementations</h3><p>The CDI interceptor binding facility does not directly support
        this, but the effect may be achieved using the CDI portable extension
        SPI, or vendor specific SPIs. For example, an interceptor with the
        expected priority can be programmatically bound to the constructors
        and methods expected to be validated according to the rules at <a href="#integration-general-executable" title="10.1.2.&nbsp;Method and constructor validation">Section&nbsp;10.1.2, &#8220;Method and constructor validation&#8221;</a>.</p><p>It is recommended to only intercept methods and constructors
        that are both constrained and validated according to the rules defined
        at <a href="#integration-general-executable" title="10.1.2.&nbsp;Method and constructor validation">Section&nbsp;10.1.2, &#8220;Method and constructor validation&#8221;</a>. <a href="#validationapi-triggeringmethodvalidation" title="5.4.&nbsp;Triggering method validation">Section&nbsp;5.4, &#8220;Triggering method validation&#8221;</a> gives examples
        how the metadata API can be used to determine whether or not a method
        is constrained (regardless of the filtering rules of
        <tt class="classname">@ValidateOnExecution</tt>).</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11518"></a>10.4.&nbsp;Java Persistence 2.0 integration</h2></div></div><div></div></div><p>Integration with Java Persistence is described in the Java
    Persistence 2 specification (<a href="http://jcp.org/en/jsr/detail?id=317" target="_top">JSR-317</a> and later <a href="http://jcp.org/en/jsr/detail?id=338" target="_top">JSR-338</a>). Persistence
    frameworks are encouraged to mimic the integration work done with Java
    Persistence.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11529"></a>10.5.&nbsp;Java Server Faces 2.0 integration</h2></div></div><div></div></div><p>Integration with Java Server Faces is described in the Java Server
    Faces 2 specification (<a href="http://jcp.org/en/jsr/detail?id=314" target="_top">JSR-314</a> and later <a href="http://jcp.org/en/jsr/detail?id=338" target="_top">JSR-344</a>). Presentation
    frameworks are encouraged to study the integration work done with JSF
    2.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11540"></a>10.6.&nbsp;JAX-RS 2 integration</h2></div></div><div></div></div><p>Integration with JAX-RS is described in the JAX-RS 2 specification
    (<a href="http://jcp.org/en/jsr/detail?id=339" target="_top">JSR-339</a>).</p></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="terminology"></a>Appendix&nbsp;A.&nbsp;Terminology</h2></div></div><div></div></div><p>This appendix aims at giving an overview on the different key terms
  used through this specification. They are not to be considered formal
  definitions. Formal definitions are to be inferred from the core
  specification.</p><div class="table"><a name="d0e11553"></a><p class="title"><b>Table&nbsp;A.1.&nbsp;terminology</b></p><table summary="terminology" border="1"><colgroup><col><col></colgroup><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody><tr><td>Constraint</td><td>A restriction on a bean instance, the value of a field or the
          value of a JavaBean property</td></tr><tr><td>Constraint declaration</td><td>Assignment of a constraint to a target (bean, field,
          property) for a specific class. Typically by declaring an annotation
          on the target but can also be done through a XML deployment
          descriptor</td></tr><tr><td>Validation routine</td><td><p>Sequence of operations executed by the Bean Validation
          provider to validate a given object graph</p></td></tr><tr><td>Constraint definition</td><td>Defines a type of constraint, its attributes and the actual
          constraint validation implementations. Done through annotations. The
          list of constraint validation implementations can be provided via
          XML</td></tr><tr><td>group</td><td>Constraints can belong to one or more group or context.
          Useful to apply a subset of the constraints for a given use case. By
          default, the <tt class="literal">Default</tt> group is used.</td></tr><tr><td>group sequence</td><td>Defines a group ordering in the validation process. If a
          given group in the sequence contains one or more failure, the
          following groups in the sequence must be ignored.</td></tr><tr><td>Constraint validation</td><td>Constraint logic algorithm used to determine whether a given
          value passes a constraint or not.</td></tr><tr><td>Constraint validation implementation</td><td>Class implementing the constraint logic and used to determine
          whether a given value pass a constraint or not.</td></tr><tr><td>Bean validation provider</td><td>Product implementing this specification</td></tr><tr><td>Message interpolator</td><td>Algorithm used to build the end user message associated to a
          constraint failure. Typically useful for i18n</td></tr><tr><td>Constraint metadata API</td><td>API exposing the constraints applied to a given bean type.
          Also considered one of the integration points with other JSR or
          frameworks.</td></tr><tr><td>Bootstrap API</td><td>Bootstrapping part of the Bean Validation API producing a
          <tt class="classname">ValidatorFactory</tt>.</td></tr><tr><td>javax.validation.ConstraintValidator</td><td>Interface implemented by a constraint validation
          implementation</td></tr><tr><td>Composing constraint</td><td>Constraint declared on another constraint definition. When
          the main constraint is validated, the composing constraints are
          validated too.</td></tr><tr><td>javax.validation.Validator</td><td>Main API. Holds contracts to validate object graphs</td></tr><tr><td>javax.validation.ConstraintViolation</td><td>Interface describing a given constraint failure on a given
          bean</td></tr><tr><td>Getter</td><td><p>Method whose:</p><div class="itemizedlist"><ul type="disc"><li><p>name starts with <tt class="literal">get</tt> and has a return
                type but no parameter</p></li><li><p>name starts with <tt class="literal">is</tt>, has no parameter
                and is returning <tt class="classname">boolean</tt></p></li></ul></div></td></tr></tbody></table></div><p></p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="standard-resolver-messages"></a>Appendix&nbsp;B.&nbsp;Standard ResourceBundle messages</h2></div></div><div></div></div><p>The properties listed below are resolved by the default message
  interpolator.</p><pre class="programlisting">javax.validation.constraints.AssertFalse.message=must be false
javax.validation.constraints.AssertTrue.message=must be true
javax.validation.constraints.DecimalMax.message=\
    must be less than ${inclusive == true ? 'or equal to ' : ''}{value}
javax.validation.constraints.DecimalMin.message=\
    must be greater than ${inclusive == true ? 'or equal to ' : ''}{value}
javax.validation.constraints.Digits.message=\
    numeric value out of bounds (&lt;{integer} digits&gt;.&lt;{fraction} digits&gt; expected)
javax.validation.constraints.Future.message=must be a future date
javax.validation.constraints.Max.message=must be less than or equal to {value}
javax.validation.constraints.Min.message=must be greater than or equal to {value}
javax.validation.constraints.NotNull.message=must not be null
javax.validation.constraints.Null.message=must be null
javax.validation.constraints.Past.message=must be a past date
javax.validation.constraints.Pattern.message=\
    must match the following regular expression: {regexp}
javax.validation.constraints.Size.message=size must be between {min} and {max}</pre></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-jpa"></a>Appendix&nbsp;C.&nbsp;Java Persistence 2.0 and schema generation</h2></div></div><div></div></div><p>While not specified by this specification or the Java Persistence 2.0
  specification, Persistence Providers are encouraged to make use of Bean
  Validation constraint metadata when generating DDL schemas. The proposal is
  as followed.</p><pre class="programlisting">Ideas explored and not standardized

Java Persistence consumes Bean Validation (BV) metadata to enhance persistence property 
metadata.

A Persistence provider must use the BV metadata of a given list of groups. 
The default group evaluated is Default (default BV group). Groups evaluated 
can be overridden by a property. 
This property contains the comma separated groups (fully qualified class name).

For each entity, apply the following algorithm. 
For each persistent property in a given entity: 
 - extract the list of BV constraints (including the composing constraints) 
 - determine the subset of applicable constraints 
    (i.e. constraints understood by the persistence provider)
 - apply these constraints on the persistent property metadata 
 - if the property type is an embeddable object or a collection 
of embeddable objects, apply the algorithm on the embeddable object properties

The list of constraints that must be understood by persistence providers are
as followed:
 - @NotNull should be considered equivalent to @Column(nullable=false) / 
     @JoinColumn(nullable=false)
 - @Size.max should be considered equivalent to @Column.length 
     for String properties 
 - @Digits (which contains integer and fraction) should be considered 
     equivalent to @Column.precision = integer+fraction, 
     @Column.scale = fraction for decimal columns

The BV annotation metadata should have priority over JPA metadata 
(JPA has no sensible "unset" values on their annotations).

Question: should we add @Unique that would map to @Column(unique=true)? 
@Unique cannot be tested at the Java level reliably but could generate
a database unique constraint generation. @Unique is not part 
of the BV spec today.

Persistence Provider should optionally recognize and try to apply the 
following constraints as well:
 - @Min / @Max on numeric columns (TODO String too?)
 - @Future / @Past on temporal columns
 - @Size for collections and array (not sure it is feasible).

Persistence Providers can also apply non standard constraints to their metadata model. 
For example, provider ACME might recognize and understand @com.acme.validation.Email 
and apply it to the database model.

While most high level constraints will not be recognize, the BV built-in constraints 
will be the common language spoken by Persistence Providers. Any high level constraint 
can be composed of more modular constraints (constraint composition).

* additional proposal
In case of a constraint violation report detected and generated by the database 
(not null, etc), the Java persistence provider catches this report and translates 
it into a BV error report. From the perspective of the application, constraint 
errors are viewed through a unified layer. BV must provide some API to create a 
constraint violation error (constraintDescriptor.createConstraintViolation(...)).

While this proposal has a lot of value-add, I wonder how difficult it can be to 
implement this in persistence providers.

Provide a way to disable BV metadata use by a persistence provider (property based).</pre><p>This is not an endorsement of the Java Persistence expert group or the
  Bean Validation expert group. Such approach may nor may not be standardized
  in the future. Such integration should not be considered portable.</p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="changelog"></a>Appendix&nbsp;D.&nbsp;Changelog</h2></div></div><div></div></div><div class="example"><a name="d0e11693"></a><p class="title"><b>Example&nbsp;D.1.&nbsp;Changelog</b></p><pre class="programlisting">1.1.0.Final (2013-04-10)
------------------------

** Improvement
    * [BVAL-452] - Remove @Deprecate annotation from addNode() method


1.1.0.CR3 (2013-03-20)
----------------------

** Bug
    * [BVAL-444] - Remove revisionflags from specification
    * [BVAL-445] - Do not consider arrays of primitives equivalent to arrays of wrappers in ConstraintValidation resolution

** Improvement
    * [BVAL-448] - Mention "boolean" instead of "Boolean" in getter definition
    * [BVAL-450] - Make @ValidateOnExecutable for @Override methods raise an exception

** Task
    * [BVAL-449] - Remove tck-needs-update


1.1.0.CR2 (2013-03-14)
----------------------

** Bug
    * [BVAL-431] - Typo in EL expression exemple
    * [BVAL-435] - Rename element &lt;validated-executables/&gt; to &lt;default-validated-executable-types/&gt;
    * [BVAL-436] - Offer global switch to disable executable validation altogether
    * [BVAL-437] - Redesign @ValidateExecutable into @ValidateOnExecution and as CDI marker for portability

** Improvement
    * [BVAL-420] - Add missing @since in metadata package
    * [BVAL-421] - Clarify whether or not getters are provided by the metadata API
    * [BVAL-422] - Update TCK markers
    * [BVAL-423] - Clarify behavior of ConstraintViolation#getLeafBean() for validateValue()
    * [BVAL-424] - Refer to @SupportedValidationTarget in ConstraintValidation JavaDoc
    * [BVAL-429] - Throw a ConstraintDefinitionException if there a several cross-parameter validators
    * [BVAL-432] - Rename areParametersConstrained to hasConstrainedParameters and isReturnValueConstrained to hasConstrainedReturnValue on ExecutableDescriptor
    * [BVAL-433] - Forbid @ValidatedExecutable on methods of parallel hierarchies
    * [BVAL-434] - Clarify exception type if cross-parameter validator support neither Object nor Object[]
    * [BVAL-440] - Improve description of ExecutableType.GETTER_METHODS
    * [BVAL-442] - Make getConstrainedMethods(MethodType methodType, MethodType... methodTypes) to be less error-prone

** New Feature
    * [BVAL-441] - Allow for identical configuration in subtypes

** Task
    * [BVAL-425] - Raise IllegalArgumentException when validateParameters and validateReturnValue are passed parameters that do not match
    * [BVAL-428] - Map remaining assertions for BV 1.1
    * [BVAL-438] - Integration chapter should not mention that the boostrap API can be used to create additional ValidationFactory
    * [BVAL-439] - Clarify that EE validator factory supports CDI services


1.1.0.CR1 (proposed final draft) (2013-02-20)
---------------------------------------------

** Bug
    * [BVAL-322] - Formatting and style improvements
    * [BVAL-369] - Specify copyright year correctly in license headers
    * [BVAL-391] - Use @SupportValidationTarget instead of @CrossParameterConstraint for cross-parameter constraint validators
    * [BVAL-397] - Align the JavaDoc on temps (return vs returns, define vs defines)
    * [BVAL-401] - validateReturnValue should not throw an exception if the method has no return value
    * [BVAL-402] - Remove notion of "reachable" parameters in method validation routine
    * [BVAL-403] - Add example on method validation to 4.6.3. ("Traversable property")
    * [BVAL-407] - ConstraintViolation.unwrap parameterized type hides ConstraintViolation parameterized type

** Improvement
    * [BVAL-275] - Align on style for referencing methods in spec text
    * [BVAL-277] - Align on style for author names in JavaDoc
    * [BVAL-285] - ValidatorFactory#close should clearly state post conditions 
    * [BVAL-350] - Add more examples on how to use methods for validating method and constructor constraints
    * [BVAL-362] - Reference the various specs (JPA, JSF, CDI, JavaBeans)
    * [BVAL-400] - Add xml and exception chapters to the list in "How this document is organized"
    * [BVAL-404] - Path examples in table 5.2 are missing node specific attributes like parameterIndex
    * [BVAL-405] - Clarify what isBeanConstrained does and add hasExecutableConstrained
    * [BVAL-406] - Add ConstraintDescriptor.getValidationAppliesTo() and getMessageTemplate()
    * [BVAL-409] - Make ParameterNameProvider use List instead of arrays
    * [BVAL-410] - Make node creation suppress the cross-param and bean-level node in case of subnode creation
    * [BVAL-412] - Make &lt;convert-group/&gt; follow &lt;valid/&gt; and precede &lt;constraint/&gt; in the mapping XSD
    * [BVAL-413] - Fix method validation and ConstraintViolation example 
    * [BVAL-414] - Add example for metadata API with executables
    * [BVAL-415] - Make sure maven plugins are set in beanvalidation-api
    * [BVAL-417] - Mention "validationAppliesTo" in docs of @SupportedValidationTarget
    * [BVAL-419] - Clarify that using a cross-parameter constraint on a method without parameter is illegal


1.1.0.Beta4 (2013-02-15)
------------------------

** Sub-task
    * [BVAL-316] - Decide on whether to allow validation of static methods or not
    * [BVAL-330] - Refinements around metadata API

** Bug
    * [BVAL-221] - The constraint violation builder cannot put constraint on a top level map key
    * [BVAL-283] - Clarify that ConstraintValidator instances must be destroyed after each method validation call if the ConstraintValidatorFactory is provided to the Validator
    * [BVAL-284] - Clarify that ConstraintValidator instances passed to CVF.releaseInstance must be coming from the CVF creating them
    * [BVAL-326] - Fix metadata and error reports for cross-parameter validation
    * [BVAL-328] - Add recommendation that @Inherited shouldn't be added to constraint annotation types
    * [BVAL-337] - Clarifications around ConstraintViolation for method validation
    * [BVAL-370] - Re-consider how cross-parameter constraints are represented in metadata API and XML descriptors
    * [BVAL-375] - Add dedicated "validationAppliesTo" element to schema type representing constraints
    * [BVAL-378] - Mismatch between enum ExecutableType and corresponding schema type
    * [BVAL-380] - Remove improper sentence around constraint being validated once globally in validation routine
    * [BVAL-381] - Specify which path is pathed to traversable resolvers in case of cascaded method validation
    * [BVAL-388] - Create sub-types of Node instead of Node#getElementDescriptor() and remove ElementDescriptor.getKind()
    * [BVAL-389] - @ValidateExecutable.type should default to ALL and NONE should be renamed OFF
    * [BVAL-390] - Clarify syntax for specifying parameter types in XML
    * [BVAL-393] - Revert "intersection type trick"

** Improvement
    * [BVAL-191] - Introduce a addBeanNode() method to the fluent node builder API
    * [BVAL-269] - Polish support for dependency injection after draft feedback
    * [BVAL-336] - Decide what to do about element descriptor when using constraint violation builder API
    * [BVAL-344] - Improve wording around CDI integration
    * [BVAL-368] - Return constant value from Node#getName() for return value nodes
    * [BVAL-372] - Consider moving ExecutableValidator to the executable subpackage
    * [BVAL-379] - Clarify that modifications to BootstrapConfiguration have no effect
    * [BVAL-384] - Add example for ElementDescriptor#findConstraints() for methods
    * [BVAL-385] - Return void ReturnValueDescriptor from ExecutableDescriptor#getReturnValueDescriptor() for void methods
    * [BVAL-386] - Clarify that CDI integration is mandatory under Java EE only
    * [BVAL-398] - Make validateReturnValue raise ValidationException if the method has no return value

** New Feature
    * [BVAL-329] - Method validation support (III)
    * [BVAL-383] - Add a  unwrap method in ConstraintViolation
    * [BVAL-387] - Add ability to add a node corresponding to a parameter in ConstraintViolationBuilder

** Task
    * [BVAL-394] - Verify that we don't need a spec defined API to expose classes hosting constrained methods or constructor defined in XML


1.1.0.Beta3 (2013-02-01)
------------------------

** Sub-task
    * [BVAL-273] - Extend the XML descriptor schema to represent method-level constraints
    * [BVAL-314] - Provide ability to disable validation for method/constructor validation 

** Bug
    * [BVAL-327] - Provide way to change the executable validation (ie accept getters)
    * [BVAL-342] - Clarify that validateProperty / validateValue does not support property paths 
    * [BVAL-343] - "Provider org.hibernate.validator.HibernateValidator not a subtype" error during service discovery
    * [BVAL-345] - List of messages in the standard resource bundle is incomplete
    * [BVAL-346] - Clarify that getters must have no parameter
    * [BVAL-347] - Add implicit assumptions from TCK to spec text
    * [BVAL-351] - Clarify that EntityManager cannot be injected if validating from JPA
    * [BVAL-361] - Expose group conversions via meta-data API
    * [BVAL-363] - Clarify that super method constraints are considered in the validation routine but not constructors
    * [BVAL-366] - Fix typo on ConfigurationState JavaDoc
    * [BVAL-371] - Add package level javadoc (package-info.java)
    * [BVAL-377] - Provide MessageInterpolator.Context#unwrap to allow for custom extensions 

** Improvement
    * [BVAL-192] - Add 'exclusive' boolean attribute to @DecimalMin/@DecimalMax constraints
    * [BVAL-332] - Specify semantics of @ConvertGroup when given several times at overridden property
    * [BVAL-340] - Denote method parameter constraints at declaration site (vs. at definition site)
    * [BVAL-352] - Clarify what managed means in the integration chapter in particular for CDI
    * [BVAL-359] - Relax contract of ExecutableDescriptor#getParameterDescriptors()
    * [BVAL-360] - Describe IllegalArgumentException for ExecutableValidator methods
    * [BVAL-364] - Clarify whether or not the metadata API ignore the method enable/disable settings
    * [BVAL-365] - Clarifications around group conversion in hierarchies
    * [BVAL-367] - Make clear whether methods/properties inherited from super types are reflected by the meta-data API
    * [BVAL-373] - Move ConvertGroup to the groups subpackage

** New Feature
    * [BVAL-219] - Add support for interpolating the value in error messages
    * [BVAL-223] - Add formatter syntax for interpolated messages via EL expression support
    * [BVAL-249] - Add unwrap method to ConstraintValidatorContext for provider extension
    * [BVAL-333] - Enable configuration of group conversions via XML

** Task
    * [BVAL-338] - Clarify lifecycle of managed objects created by BV povider
    * [BVAL-348] - Add example for illegal group conversion on a return value in an inheritance hierarchy
    * [BVAL-349] - Mark spec sentences as TCK-relevant (1.0 assertions)
    * [BVAL-353] - Mark spec sentences as TCK-relevant (1.1 assertions)
    * [BVAL-354] - Describe tagging of TCK-relevant sentences in README.md
    * [BVAL-355] - Rename Validator#forMethods() to forExecutables()
    * [BVAL-357] - Clarify that traversable resolver is not used on parameter and return values during method validation
    * [BVAL-358] - Make ExecutableDescriptor#validateConstructorParameters() and validateConstructorReturnValue() more usable
    * [BVAL-374] - Clarify exceptional case in section 5.5.5 bootstrapping 
    * [BVAL-376] - Remove @MethodValidated as it is not adding value to the CDI integration


1.1.0.Beta2 (2012-11-27)
------------------------

** Sub-task
    * [BVAL-331] - Establish common super-interface for MethodDescriptor and ConstructorDescriptor


** Bug
    * [BVAL-335] - @ConvertGroup.List is missing target types and retention policy



** Improvement
    * [BVAL-198] - Simplify creation of ConstraintViolationExceptions
    * [BVAL-334] - Refer to CDI provided beans as "built-in" beans


1.1.0.Beta1 (public review draft 1) (2012-10-19)
------------------------------------------------

** Sub-task
    * [BVAL-232] - Support cross-parameter constraints
    * [BVAL-274] - Extend the meta-data API with required convenience methods for method validation
    * [BVAL-290] - Mark new method with @since annotation
    * [BVAL-300] - Clarify behavior of constructor validation in class hierachies 
    * [BVAL-308] - Settle on approach for constraint refinement in sub-types
    * [BVAL-309] - Specify logic to be implemented by method validation interceptors
    * [BVAL-310] - Move methods related to method validation to delegate interface
    * [BVAL-317] - Rename 'method-level validation' with 'method validation'


** Bug
    * [BVAL-296] - Example using ConstraintValidatorContext is incorrect
    * [BVAL-298] - DefaultValidationProviderResolver should check context and current class loader for service file
    * [BVAL-304] - Add OSGi headers in the reference implementation
    * [BVAL-306] - Clarify interceptor order in method validation triggering



** Improvement
    * [BVAL-208] - Support groups translation during cascaded validations 
    * [BVAL-226] - Make clear whether the static or the runtime type should be considered when creating property paths in case of cascaded validations
    * [BVAL-230] - Add support for validating CharSequence types instead of just Strings
    * [BVAL-259] - Evaluation of composed constraints should stops on first validation error in case of @ReportAsSingleViolation
    * [BVAL-281] - Improve message when building a ValidatorFactory but no provider is available in the classpath
    * [BVAL-292] - Clarify the behavior of ConfigurationSource methods when no configuration file is present
    * [BVAL-299] - Add note on required Java version

** New Feature
    * [BVAL-272] - Method validation support (II)
    * [BVAL-295] - Should validation-configuration and validation-mapping xsds define a version attribute


** Task
    * [BVAL-280] - Decide whether DefaultValidationProviderResolver should not throw an exception when a specified provider cannot be loaded
    * [BVAL-307] - Decide how CDI and Bean Validation is integrated


1.1.0.Alpha1 (early draft 1) (2012-03-13)
-----------------------------------------

** Sub-task
    * [BVAL-242] - Extend the meta-data API to represent method-level constraints
    * [BVAL-243] - Provide a means for specifying method parameter names
    * [BVAL-244] - Extend Validator API with methods for method validation
    * [BVAL-245] - Define how method constraints are declared at parameters and return values


** Bug
    * [BVAL-194] - Invalid license info
    * [BVAL-196] - Missing &lt;/code&gt; element in Javadocs for ConstraintValidatorContext.ConstraintViolationBuilder.NodeContextBuilder
    * [BVAL-212] - Wrong closing &lt;/code&gt; element in javadocs of BeanDescriptor
    * [BVAL-236] - Fails to load META-INF/services provider configuration files on non-ASCII platforms 


** Improvement
    * [BVAL-201] - Fix typo in spec, chapter 4.4.3
    * [BVAL-270] - Specify that Bean Validation 1.1 providers must support deployment descriptors version 1.0

** New Feature
    * [BVAL-238] - Support for container injection in ConstraintValidator
    * [BVAL-241] - Support for method validation
    * [BVAL-258] - Clean introduction section to reflect Bean Validation 1.1
    * [BVAL-263] - Add a close() method to ValidatorFactory
    * [BVAL-265] - Expose settings defined in XML in the Configuration API (for ConstraintValidatorFactory, MessageInterpolator etc)


** Task
    * [BVAL-206] - Update pom to use the new distributationManagement information
    * [BVAL-228] - Prepare specification document and Git repository for public eyes
    * [BVAL-279] - Update POM file for Bean Validation API to use latest Git repo urls and generally be ready for a release


1.0.0 final (2009-10-12)
------------------------

** Bug
    * [BVAL-181] - Fix some namespace issues in validation-configuration-1.0.xsd


** Improvement
    * [BVAL-182] - Add getDefaultTraversableResolver and getDefaultConstraintValidatorFactory to Configuration
    * [BVAL-183] - Add getTraversableResolver and getConstraintValidatorFactory to ValidatorFactory
    * [BVAL-184] - Replace Red Hat Middleware LLC to Red Hat, Inc. and/or its affiliates
    * [BVAL-186] - Clarify method names on the constraint violation builder DSL of ConstraintValidatorContext
    * [BVAL-187] - Imply that ConstraintViolation is serializable if entities are serializable

** New Feature
    * [BVAL-185] - Allow overriding of ConstraintValidatorFactory when creating a Validator
    * [BVAL-190] - Add methods to filter ConstraintDescriptor per groups, target and scope


** Task
    * [BVAL-132] - Define behaviour for BeanDescriptor.getConstraintsForProperty(null)



1.0.CR5 (2009-08-27)
--------------------

** Bug
    * [BVAL-173] - Fix typo getUnorderdConstraintDescriptorsMatchingGroups =&gt; getUnorderedConstraintDescriptorsMatchingGroups
    * [BVAL-177] - Payload of composed constraints are ignored, the main constraint payload is propagated
    * [BVAL-178] - Add payload to the XML schema
    * [BVAL-180] - ConstraintDescriptor.getPayload() should return Set&lt;Class&lt;? extends Payload&gt;&gt; not Set&lt;Class&lt;Payload&gt;&gt;


** Improvement
    * [BVAL-174] - clearer default message for assertTrue and assertFalse
    * [BVAL-179] - Rename ConstraintPayload to Payload



1.0.CR4 Unpublished release
---------------------------



1.0.CR3 Proposed Final Draft 2 (2009-07-08)
-------------------------------------------

** Bug
    * [BVAL-144] - validation-configuration.xsd property element does not extend basic string type preventing Oxygen to be happy
    * [BVAL-159] - Fix example 3.8 on object graph validation 


** Improvement
    * [BVAL-143] - Describe path with an object model
    * [BVAL-147] - Support for unbounded wildcards in ConstraintValidator
    * [BVAL-148] - Built-in constraints annotations now annotated with @Constraint(validatedBy={})
    * [BVAL-151] - TraversableResolver#isTraversable can receive null traversableObject when valudateValue is called
    * [BVAL-152] - TraversableResolver should differentiate reachability and cascadability
    * [BVAL-153] - Generify ConstraintValidatorException
    * [BVAL-154] - Iterable is a superclass of all collection, clarify it's interaction with @Valid
    * [BVAL-155] - ignore-annotation is not inherited hierarchically: make that explicit
    * [BVAL-156] - Pattern.Flag takes the JDK flag int at construction time
    * [BVAL-157] - Add [] to non-indexed iterable path 
    * [BVAL-158] - Clarify that @Valid is orthogonal to the idea of group
    * [BVAL-160] - rename message template key as [f.q.c.n of the constraint].message
    * [BVAL-162] - Move metadata classes to the metadata package (BeanDescriptor, ElementDescriptor, PropertyDescriptor, ConstraintDescriptor)
    * [BVAL-164] - Validation.byProvider now accept the provider implementation class
    * [BVAL-166] - IllegalArgumentException raised on BeanDescriptor.getConstraintsForProperty and Validator.getConstraintsForClass
    * [BVAL-167] - Recommend f.q.c.n.message for resource bundle keys and migrate examples
    * [BVAL-169] - Rename ElementDescriptor.getType to getElementClass
    * [BVAL-170] - Let built-in annotations to support ElementType.PARAMETER and ElementType.CONSTRUCTOR

** New Feature
    * [BVAL-149] - Provide access to the ValidationProviderResolver via BootstrapState
    * [BVAL-150] - Add ConstraintViolation.getRootBeanClass
    * [BVAL-161] - Add unwrap methods to ValidatorFactory and Validator
    * [BVAL-163] - Add support for constraint payload
    * [BVAL-168] - Return the list of matching ConstraintDescriptor for a given set of groups
    * [BVAL-172] - Provide ConstraintDescriptor#getPayload



1.0.CR2 Unpublished release
---------------------------



1.0.CR1 Proposed Final Draft (2009-03-16)
-----------------------------------------


** Bug
    * [BVAL-118] - ConstraintDescriptor.getGroups() returns Default if no group is declared on the constraint
    * [BVAL-125] - @Size.min default value should be 0


** Improvement
    * [BVAL-32] - Describe what is happening when a composition is not consistent
    * [BVAL-50] - Be consistent in the spec, use @author or not
    * [BVAL-54] - Specify that constraints on non getter methods are ignored (if BVAL-36 is not accepted)
    * [BVAL-72] - Validating an object multiple times if in a different branch of the graph
    * [BVAL-86] - Default TraversableResolver is JPA aware
    * [BVAL-88] - Improvement on MessageInterpolator
    * [BVAL-91] - Rename Constraint related classes to improve readability
    * [BVAL-95] - @Size should support Map
    * [BVAL-96] - Support byte in @Min/@Max
    * [BVAL-106] - Constraintdescriptor.getConstraintValidatorClasses() should return a List, not an array
    * [BVAL-114] - Relax property names in ConstraintValidatorContext
    * [BVAL-120] - Rename ConstraintViolation getRawMessage=&gt;getMessageTemplate, getInterpolatedMessage=&gt;getMessage
    * [BVAL-122] - Rename @GroupSequence.sequence to @GroupSequence.value
    * [BVAL-126] - Define group sequence logic more formally and eliminate corner cases
    * [BVAL-129] - Clarify ConstraintValidatorContext propertyPath generation
    * [BVAL-130] - Make ConstraintDescriptor generic: ConstraintDescriptor&lt;T extends Annotation&gt;
    * [BVAL-131] - Provide object graph navigation determinism
    * [BVAL-134] - @Valid accepts objects implementing Iterable 
    * [BVAL-135] - Remove DefaultValidationProviderResolver from the public API
    * [BVAL-136] - Add Context object for MessageInterpolator
    * [BVAL-137] - prefix for message template key is constraint. instead of validator.
    * [BVAL-138] - Rename OverridesParameter to OverridesAttribute
    * [BVAL-139] - Remove @OverridesParameters and use the inner class mode (OverridesAttribute.LIst)
    * [BVAL-140] - BeanDescriptor.getConstrainedProperties() returns Set&lt;PropertyDescriptor&gt;
    * [BVAL-141] - Rename ConstraintDescriptor.getParameters() to getAttributes()

** New Feature
    * [BVAL-52] - Define the exception hierarchy and rules
    * [BVAL-55] - Exception policy
    * [BVAL-65] - Additional built-in constraints
    * [BVAL-98] - Type-safe ConstraintValidator
    * [BVAL-100] - Support XML mapping overriding
    * [BVAL-102] - Support META-INF/validation.xml
    * [BVAL-119] - Introduce @Pattern for regexp
    * [BVAL-121] - Define built-in constraints plural forms
    * [BVAL-123] - Add ConstraintViolationException
    * [BVAL-124] - Introduce backslash as escaping character
    * [BVAL-142] - @Min/@max no longer accept float/double and introduce @DecimalMin/@DecimalMax


** Task
    * [BVAL-24] - What should be done when multiple META-INF/validation.xml are found?
    * [BVAL-117] - Specify behaviour of ConstraintValidator.initalize in the case of inconsistent values in constraint parameters
    * [BVAL-127] - Remove ConstraintViolation.getGroups()
    * [BVAL-128] - Clarify invalid cases for validateProperty / validateValue on proeprtyName being empty or null
    * [BVAL-133] - Remove JPA and JSF integration proposals




1.0.Beta2 Public Draft (2008-12-15)
-----------------------------------


** Bug
    * [BVAL-6] - Wrong example in validation methods section
    * [BVAL-17] - Validator&lt;A&gt;.validate(b) where b:B and B extends A should validate B. Metadata APIs are specific to A
    * [BVAL-42] - Names of message keys in spec inconsistent
    * [BVAL-45] - Typo at ConstraintDescriptor.getContstraintClass()


** Improvement
    * [BVAL-29] - Types should be determined at runtime
    * [BVAL-33] - Should ConstraintDescriptor.getConstraintImplementation() replaced by .getConstraintImplementationClass()?
    * [BVAL-40] - Rename InvalidConstraint to ConstraintViolation
    * [BVAL-48] - Add a way to access the default message resolver
    * [BVAL-49] - Mark metadata classes as immutable
    * [BVAL-59] - Rethink the group sequence inheritance rules
    * [BVAL-60] - ConstraintViolation points to the corresponding ConstraintDescriptor
    * [BVAL-68] - Specify that static methods and fields are not validated
    * [BVAL-73] - Rename ConstraintViolation.getBeanClass() to CV. getRootClass() or simply remove it
    * [BVAL-78] - Forbid a Validation implementation to modify the state of the object being validated

** New Feature
    * [BVAL-30] - Define validation Context to be passed to constraint implementation calls
    * [BVAL-36] - Validation of method parameters and returned values
    * [BVAL-67] - Allow MessageResolver to be Localizable
    * [BVAL-71] - Should we have group aggregation?
    * [BVAL-76] - Expose the raw message to ConstraintViolation
    * [BVAL-79] - Groups are now Type based rather than String based
    * [BVAL-81] - Provide a TraversableResolver contract


** Task
    * [BVAL-1] - Remove references to 'beancheck' in the spec
    * [BVAL-3] - Replace array return types with Sets
    * [BVAL-4] - Return value for @NotEmpty for null values
    * [BVAL-5] - Change order of exmaple classes in Book/Author example
    * [BVAL-7] - Use of example in ConstraintFactory section (2.4)
    * [BVAL-8] - StandardConstraint description (2.5)
    * [BVAL-23] - Make Validator&lt;T&gt; thread-safe</pre></div></div></div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-24703879-1', 'auto');
  ga('send', 'pageview');
</script>
</body></html>
